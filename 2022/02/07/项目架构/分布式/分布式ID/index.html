<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>分布式ID | Lemon-CS</title><meta name="keywords" content="分布式ID"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分布式唯一ID的解决方案"><meta property="og:type" content="article"><meta property="og:title" content="分布式ID"><meta property="og:url" content="https://lemon-cs.github.io/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="分布式唯一ID的解决方案"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/02/80bab5e678236c43.jpg"><meta property="article:published_time" content="2022-02-07T14:25:10.000Z"><meta property="article:modified_time" content="2021-02-13T07:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="分布式ID"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2022/02/80bab5e678236c43.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"分布式ID",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-02-13 15:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s3.bmp.ovh/imgs/2022/02/80bab5e678236c43.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式ID</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-07T14:25:10.000Z" title="发表于 2022-02-07 22:25:10">2022-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-13T07:37:35.000Z" title="更新于 2021-02-13 15:37:35">2021-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="分布式ID"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><h3 id="何为-ID？"><a href="#何为-ID？" class="headerlink" title="何为 ID？"></a>何为 ID？</h3><p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p><p><img src="https://segmentfault.com/img/remote/1460000040240957"></p><p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应</p><p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p><h3 id="何为分布式-ID？"><a href="#何为分布式-ID？" class="headerlink" title="何为分布式 ID？"></a>何为分布式 ID？</h3><p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p><p>我简单举一个分库分表的例子。</p><p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。</p><p>单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p><p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p><p><img src="https://segmentfault.com/img/remote/1460000040240958"></p><p>这个时候就需要生成<strong>分布式 ID</strong>了。</p><h3 id="分布式-ID-需要满足哪些要求"><a href="#分布式-ID-需要满足哪些要求" class="headerlink" title="分布式 ID 需要满足哪些要求?"></a>分布式 ID 需要满足哪些要求?</h3><p><img src="https://segmentfault.com/img/remote/1460000040240959"></p><p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。</p><p>一个最基本的分布式 ID 需要满足下面这些要求：</p><ul><li><strong>全局唯一</strong> ：ID 的全局唯一性肯定是首先要满足的！</li><li><strong>高性能</strong> ： 分布式 ID 的生成速度要快，对本地资源消耗要小。</li><li><strong>高可用</strong> ：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li><li><strong>方便易用</strong> ：拿来即用，使用方便，快速接入！</li></ul><p>除了这些之外，一个比较好的分布式 ID 还应保证：</p><ul><li><strong>安全</strong> ：ID 中不包含敏感信息。</li><li><strong>有序递增</strong> ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li><li><strong>有具体的业务含义</strong> ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li><li><strong>独立部署</strong> ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。</li></ul><h2 id="分布式-ID-常见解决方案"><a href="#分布式-ID-常见解决方案" class="headerlink" title="分布式 ID 常见解决方案"></a>分布式 ID 常见解决方案</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="数据库主键自增"><a href="#数据库主键自增" class="headerlink" title="数据库主键自增"></a>数据库主键自增</h4><p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。</p><p><img src="https://segmentfault.com/img/remote/1460000040240960"></p><p>以 MySQL 举例，我们通过下面的方式即可。</p><p><strong>1.创建一个数据库表。</strong></p><p>CREATE TABLE <code>sequence_id</code> (<br><code>id</code> bigint(20) unsigned NOT NULL AUTO_INCREMENT,<br><code>stub</code> char(10) NOT NULL DEFAULT ‘’,<br>PRIMARY KEY (<code>id</code>),<br>UNIQUE KEY <code>stub</code> (<code>stub</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p><p><code>stub</code> 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 <code>stub</code> 字段创建了唯一索引，保证其唯一性。</p><p><strong>2.通过 <code>replace into</code> 来插入数据。</strong></p><p>BEGIN;<br>REPLACE INTO sequence_id (stub) VALUES (‘stub’);<br>SELECT LAST_INSERT_ID();<br>COMMIT;</p><p>插入数据这里，我们没有使用 <code>insert into</code> 而是使用 <code>replace into</code> 来插入数据，具体步骤是这样的：</p><p>1)第一步： 尝试把数据插入到表中。</p><p>2)第二步： 如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</p><p>这种方式的优缺点也比较明显：</p><ul><li><strong>优点</strong> ：实现起来比较简单、ID 有序递增、存储消耗空间小</li><li><strong>缺点</strong> ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li></ul><h4 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h4><p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。</p><p>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 <strong>基于数据库的号段模式来生成分布式 ID。</strong></p><p>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=CSAfzhb9gUCRL5tigroe6g==.QiqmhD61z7dGZeaxvX3+CGuOYy8pQ3mtSJPjnJ3rpYTtaCZjd7u/E6liFSmxYG9fhfKRUbetoxBGbkVpNIbZQv5Dij3pZyytHZn6cvq8Djc=">Tinyid</a> 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p><p>以 MySQL 举例，我们通过下面的方式即可。</p><p><strong>1.创建一个数据库表。</strong></p><p>CREATE TABLE <code>sequence_id_generator</code> (<br><code>id</code> int(10) NOT NULL,<br><code>current_max_id</code> bigint(20) NOT NULL COMMENT ‘当前最大id’,<br><code>step</code> int(10) NOT NULL COMMENT ‘号段的长度’,<br><code>version</code> int(20) NOT NULL COMMENT ‘版本号’,<br><code>biz_type</code> int(20) NOT NULL COMMENT ‘业务类型’,<br>PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</p><p><code>current_max_id</code> 字段和<code>step</code>字段主要用于获取批量 ID，获取的批量 id 为： <code>current_max_id ~ current_max_id+step</code>。</p><p><img src="https://segmentfault.com/img/remote/1460000040240961"></p><p><code>version</code> 字段主要用于解决并发问题（乐观锁）,<code>biz_type</code> 主要用于表示业余类型。</p><p><strong>2.先插入一行数据。</strong></p><p>INSERT INTO <code>sequence_id_generator</code> (<code>id</code>, <code>current_max_id</code>, <code>step</code>, <code>version</code>, <code>biz_type</code>)<br>VALUES<br>(1, 0, 100, 0, 101);</p><p><strong>3.通过 SELECT 获取指定业务下的批量唯一 ID</strong></p><p>SELECT <code>current_max_id</code>, <code>step</code>,<code>version</code> FROM <code>sequence_id_generator</code> where <code>biz_type</code> = 101</p><p>结果：</p><p>id current_max_id step version biz_type<br>1 0 100 1 101</p><p><strong>4.不够用的话，更新之后重新 SELECT 即可。</strong></p><p>UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0 AND <code>biz_type</code> = 101<br>SELECT <code>current_max_id</code>, <code>step</code>,<code>version</code> FROM <code>sequence_id_generator</code> where <code>biz_type</code> = 101</p><p>结果：</p><p>id current_max_id step version biz_type<br>1 100 100 1 101</p><p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p><p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p><p><strong>数据库号段模式的优缺点:</strong></p><ul><li><strong>优点</strong> ：ID 有序递增、存储消耗空间小</li><li><strong>缺点</strong> ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p><img src="https://segmentfault.com/img/remote/1460000040240962"></p><p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 <code>incr</code> 命令即可实现对 id 原子顺序递增。</p><p>127.0.0.1:6379&gt; set sequence_id_biz_type 1<br>OK<br>127.0.0.1:6379&gt; incr sequence_id_biz_type<br>(integer) 2<br>127.0.0.1:6379&gt; get sequence_id_biz_type<br>“2”</p><p>为了提高可用性和并发，我们可以使用 Redis Cluser。Redis Cluser 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。</p><p>除了 Redis Cluser 之外，你也可以使用开源的 Redis 集群方案<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=lCiFryNGoQcJWJ93En46Lg==.lc4jm9jSuWNSXudQrBh+3sunqpQjuvqRAAoXaTBTlsCCpZVCsXz/aXFpOR6tLfBz">Codis</a> （大规模集群比如上百个节点的时候比较推荐）。</p><p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only file, AOF）</strong>。 并且，Redis 4.0 开始支持 <strong>RDB 和 AOF 的混合持久化</strong>（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=pEJGS5FsIfuyEMEG9LlfXg==.qiMbY/LvGxjzrqvSl2d+O/Bw9frXuWN8n8cp2wuqr8h8LAQQDYBOfdZQXw+eXf05mu28xoV4ovtedqS7bd96NzwzgV4FmtlRqQW4e/46BcQ=">JavaGuide 对于 Redis 知识点的总结</a>。</p><p><strong>Redis 方案的优缺点：</strong></p><ul><li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li><li><strong>缺点</strong> ： 和数据库主键自增方案的缺点类似</li></ul><p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。</p><p><img src="https://segmentfault.com/img/remote/1460000040240963"></p><p>MongoDB ObjectId 一共需要 12 个字节存储：</p><ul><li>0~3：时间戳</li><li>3~6： 代表机器 ID</li><li>7~8：机器进程 ID</li><li>9~11 ：自增值</li></ul><p><strong>MongoDB 方案的优缺点：</strong></p><ul><li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li><li><strong>缺点</strong> ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。</p><p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p><p>//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa<br>UUID.randomUUID()</p><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=0VhbFHIJ9GthH+NWZvGwNQ==.yySPGyJ7DggI6c4Eyf8vOHaYAfhUqMauCnFhtyUhi7E5T366hqHgZpbKXYmKE5RT">RFC 4122</a> 中关于 UUID 的示例是这样的：</p><p><img src="https://segmentfault.com/img/remote/1460000040240964"></p><p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。</p><p>5 种不同的 Version(版本)值分别对应的含义（参考<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=OFneA6fQDRdRtMmynqWJ5w==.ypHSFYXWfndxNXt/4IFccImzVHxO3ElRsZLJ9qXEtc6n5tZMjjfYThNWVjaOK32NzOZiAl4/rpBZ2gjSZOQ4WIWo1Cpwvqe+4XRLkOX5WtawJpOWtMZK0oPIa54nr+QR">维基百科对于 UUID 的介绍</a>）：</p><ul><li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li><li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li><li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li><li><strong>版本 4</strong> : UUID 使用<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=zmGVgA3Z9AreOg5u4pBoLQ==.IwXDZP6prbTZmoP9tZSR724A884DWWMPKJEs7EeAgvzROpIRVOkDiu/jMfd5vdWuIGX6ibJi3TwRik9O7CLiZQ==">随机性</a>或<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=NEZHuu0KguNv6cvtFljlxQ==.L+NMU92lQ6nWHDtbF9uwXSc2IrJjAa/+KMbQQ0kbr0fGIpKqKLnqXRE1p+Xpx0zApzTZoyGrCZ/qZ65UiM9KqmXAzRKt3rMUmcruFI6lvy0=">伪随机性</a>生成。</li></ul><p>下面是 Version 1 版本下生成的 UUID 的示例：</p><p><img src="https://segmentfault.com/img/remote/1460000040240965"></p><p>JDK 中通过 <code>UUID</code> 的 <code>randomUUID()</code> 方法生成的 UUID 的版本默认为 4。</p><p>UUID uuid = UUID.randomUUID();<br>int version = uuid.version();// 4</p><p>另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。</p><p>需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。</p><p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p><p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p><p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p><ul><li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li><li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li></ul><p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong> （面试的时候可能会被问到的哦！） :</p><ul><li><strong>优点</strong> ：生成速度比较快、简单易用</li><li><strong>缺点</strong> ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li></ul><h4 id="Snowflake-雪花算法"><a href="#Snowflake-雪花算法" class="headerlink" title="Snowflake(雪花算法)"></a>Snowflake(雪花算法)</h4><p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p><ul><li><strong>第 0 位</strong>： 符号位（标识正负），始终为 0，没有用，不用管。</li><li><strong>第 1~41 位</strong> ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li><li><strong>第 42~52 位</strong> ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li><li><strong>第 53~64 位</strong> ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000040240966"></p><p>如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。</p><p>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p><p>我们再来看看 Snowflake 算法的优缺点 ：</p><ul><li><strong>优点</strong> ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li><li><strong>缺点</strong> ： 需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li></ul><h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><h4 id="UidGenerator-百度"><a href="#UidGenerator-百度" class="headerlink" title="UidGenerator(百度)"></a>UidGenerator(百度)</h4><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=lgwjYbdhPyvDtkyhegIHjg==.Toh8qKLbXo8rijc6E+tIeqB1NeRX/8X+9gPxFD0fzuI4tcjkJh1pQpiiVxuL3rvI">UidGenerator</a> 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p><p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。</p><p><img src="https://segmentfault.com/img/remote/1460000040240967"></p><p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。</p><p>UidGenerator 官方文档中的介绍如下：</p><p><img src="https://segmentfault.com/img/remote/1460000040240968"></p><p>自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=prgkBpJexfxTYluclRL57g==.yS/ioWf54t2Aq+PguxrvWINqUBiZO2u8BDrHSFf74W8vBEaHDqqjAsyzsHOXnqLko0mW+BJlHo20jbBN24HKQFByiwDkCdvA83TPR2hAzBM=">UidGenerator 的官方介绍</a>。</p><h4 id="Leaf-美团"><a href="#Leaf-美团" class="headerlink" title="Leaf(美团)"></a>Leaf(美团)</h4><p><strong><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=6s7lBVjiwUTgDN7qm/XjjQ==.g2WDmGO1j1wZ8cWusZXzqBomq2pcrlumQWPjNDUQV4KqnUtlEtdW6V/3f77hN5Ik">Leaf</a></strong> 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p><p><img src="https://segmentfault.com/img/remote/1460000040240969"></p><p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p><p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。</p><p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=jlfWNd6sejP1Y8NaOMf9uw==.MNRDmlW4u+crsjbDjk4rMdbOSMhWpmXDOETxKYq+BQFkJSqRDAG7OZe6jlnvqH8IPLTIwkfatkzoUh2iG8y0kA==">《Leaf——美团点评分布式 ID 生成系统》</a>）。</p><p><img src="https://segmentfault.com/img/remote/1460000040240970"></p><p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。</p><h4 id="Tinyid-滴滴"><a href="#Tinyid-滴滴" class="headerlink" title="Tinyid(滴滴)"></a>Tinyid(滴滴)</h4><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=5mtuVY8jGnadP3ssF8flRw==.rwNewsQtquHwVlw7JKoM5OeRbviPR0yYZv0U9z1qs28=">Tinyid</a> 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p><p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid 有哪些亮点呢？</strong></p><p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=AP1CMicdFs0YbOCVKrMRzw==.xtKUUbEbC67Ck/2eib7j28ItwsEy4tBhlcboVqRWS4n9FZwsIRRmknIIo0E2veOv/TR+F7O4sWwYBP3JB8w2PeZbH8XGon4FWTIRx7ITxxY=">《Tinyid 原理介绍》</a>）</p><p><img src="https://segmentfault.com/img/remote/1460000040240971"></p><p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。</p><p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p><ul><li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li><li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li></ul><p>除此之外，HTTP 调用也存在网络开销。</p><p>Tinyid 的原理比较简单，其架构如下图所示：</p><p><img src="https://segmentfault.com/img/remote/1460000040240972"></p><p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p><ul><li><strong>双号段缓存</strong> ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li><li><strong>增加多 db 支持</strong> ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li><li><strong>增加 tinyid-client</strong> ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li></ul><p>Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。</p><h2 id="分布式ID方案"><a href="#分布式ID方案" class="headerlink" title="分布式ID方案"></a>分布式ID方案</h2><p>下表为一些常用方案对比：</p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupX4FqicNliaRle1bBLOWDRuKH5uOiav4CbqaMG58k0PguWmUQibG3QLWQ7y1oa2DxUs5d73ROEwic2r0kQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></a></p><p>目前流行的分布式ID解决方案有两种：「号段模式」和「雪花算法」。</p><p>「号段模式」依赖于数据库，但是区别于数据库主键自增的模式。假设100为一个号段100，200，300，每取一次可以获得100个ID，性能显著提高。</p><p>「雪花算法」是由符号位+时间戳+工作机器id+序列号组成的，如图所示：</p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247487551&idx=1&sn=18f64ba49f3f0f9d8be9d1fdef8857d9&chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&scene=21&token=899450012&lang=zh_CN#wechat_redirect"><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupX4FqicNliaRle1bBLOWDRuKHibYyHjTZickh4hp6Qz09QqnJ7C8CncU289fJGS8w2tYiath2sdOxT2nBw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></a></p><p>符号位为0，0表示正数，ID为正数。</p><p>时间戳位不用多说，用来存放时间戳，单位是ms。</p><p>工作机器id位用来存放机器的id，通常分为5个区域位+5个服务器标识位。</p><p>序号位是自增。</p><blockquote><p>雪花算法能存放多少数据？时间范围：2^41 / (3652460601000) = 69年 工作进程范围：2^10 = 1024 序列号范围：2^12 = 4096，表示1ms可以生成4096个ID。</p></blockquote><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。下面是推特版的Snowflake算法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 起始的时间戳  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_STMP = <span class="number">1480166465631L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>; <span class="comment">//序列号占用的位数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;   <span class="comment">//机器标识占用的位数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATACENTER_BIT = <span class="number">5</span>;<span class="comment">//数据中心占用的位数  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 每一部分的最大值  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATACENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATACENTER_BIT);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;  <span class="comment">//数据中心  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;     <span class="comment">//机器标识  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">//序列号  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastStmp = -<span class="number">1L</span>;<span class="comment">//上一次时间戳  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;datacenterId can&#x27;t be greater than MAX_DATACENTER_NUM or less than 0&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;machineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;  </span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 产生下一个ID  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> currStmp = getNewstmp();  </span><br><span class="line">        <span class="keyword">if</span> (currStmp &lt; lastStmp) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (currStmp == lastStmp) &#123;  </span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增  </span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;  </span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大  </span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;  </span><br><span class="line">                currStmp = getNextMill();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0  </span></span><br><span class="line">            sequence = <span class="number">0L</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        lastStmp = currStmp;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT <span class="comment">//时间戳部分  </span></span><br><span class="line">                | datacenterId &lt;&lt; DATACENTER_LEFT       <span class="comment">//数据中心部分  </span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分  </span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">long</span> mill = getNewstmp();  </span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastStmp) &#123;  </span><br><span class="line">            mill = getNewstmp();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> mill;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewstmp</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SnowFlake snowFlake = <span class="keyword">new</span> SnowFlake(<span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">12</span>); i++) &#123;  </span><br><span class="line">            System.out.println(snowFlake.nextId());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天主要分析一下以下9种，分布式ID生成器方式以及优缺点：</p><ul><li>UUID</li><li>数据库自增ID</li><li>数据库多主模式</li><li>号段模式</li><li>Redis</li><li>雪花算法（SnowFlake）</li><li>滴滴出品（TinyID）</li><li>百度 （Uidgenerator）</li><li>美团（Leaf）</li></ul><p>那么它们都是如何实现？以及各自有什么优缺点？我们往下看</p><p><img src="https://mmbiz.qpic.cn/mmbiz/CKvMdchsUwmvJKLibqWqBoicnq8kIziaqXfuUbAdrXvS9MALHr9eIMYnpMS5LVAm8b0U7MzekIUwtZUlVjTlWvfXA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片源自网络</p><blockquote><p>以上图片源自网络，如有侵权联系删除</p></blockquote><h3 id="1-基于UUID"><a href="#1-基于UUID" class="headerlink" title="1. 基于UUID"></a>1. 基于UUID</h3><p>在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是<code>UUID</code>，毕竟它有着全球唯一的特性。那么<code>UUID</code>可以做<code>分布式ID</code>吗？<strong>答案是可以的，但是并不推荐！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">	String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);  </span><br><span class="line">	System.out.println(uuid);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p><p><strong>优点：</strong></p><ul><li>生成足够简单，本地生成无网络消耗，具有唯一性</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性</li><li>没有具体的业务含义</li><li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li></ul><h3 id="2-基于数据库自增ID"><a href="#2-基于数据库自增ID" class="headerlink" title="2. 基于数据库自增ID"></a>2. 基于数据库自增ID</h3><p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CREATEDATABASE`SEQ_ID`;  </span><br><span class="line">CREATETABLE SEQID.SEQUENCE_ID (  </span><br><span class="line">idbigint(<span class="number">20</span>) unsignedNOTNULL auto_increment,  </span><br><span class="line">valuechar(<span class="number">10</span>) NOTNULLdefault<span class="string">&#x27;&#x27;</span>,  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id),  </span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SEQUENCE_ID(<span class="keyword">value</span>)  <span class="keyword">VALUES</span> (<span class="string">&#x27;values&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p><p><strong>优点：</strong></p><ul><li>实现简单，ID单调自增，数值类型查询速度快</li></ul><p><strong>缺点：</strong></p><ul><li>DB单点存在宕机风险，无法扛住高并发场景</li></ul><h3 id="3-基于数据库集群模式"><a href="#3-基于数据库集群模式" class="headerlink" title="3. 基于数据库集群模式"></a>3. 基于数据库集群模式</h3><p>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。</p><p>那这样还会有个问题，两个MySQL实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></p><p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code></p><p>MySQL_1 配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure><p>MySQL_2 配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure><p>这样两个MySQL实例的自增ID分别就是：</p><blockquote><p>1、3、5、7、9 2、4、6、8、10</p></blockquote><p>那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/CKvMdchsUwmvJKLibqWqBoicnq8kIziaqXfTn4noLbUTcrMxZ6Q8BlG4tPK51X1r9pxvun6UcSu81uaE6OGjoFLLQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>在这里插入图片描述</p><p>从上图可以看出，水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。</p><p>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</p><p><strong>优点：</strong></p><ul><li>解决DB单点问题</li></ul><p><strong>缺点：</strong></p><ul><li>不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。</li></ul><h3 id="4-基于数据库的号段模式"><a href="#4-基于数据库的号段模式" class="headerlink" title="4. 基于数据库的号段模式"></a>4. 基于数据库的号段模式</h3><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CREATETABLE id_generator (  </span><br><span class="line">idint(<span class="number">10</span>) NOTNULL,  </span><br><span class="line">max_id <span class="type">bigint</span>(<span class="number">20</span>) NOTNULLCOMMENT<span class="string">&#x27;当前最大id&#x27;</span>,  </span><br><span class="line">step <span class="type">int</span>(<span class="number">20</span>) NOTNULLCOMMENT<span class="string">&#x27;号段的布长&#x27;</span>,  </span><br><span class="line">biz_type <span class="type">int</span>(<span class="number">20</span>) NOTNULLCOMMENT<span class="string">&#x27;业务类型&#x27;</span>,  </span><br><span class="line">versionint(<span class="number">20</span>) NOTNULLCOMMENT<span class="string">&#x27;版本号&#x27;</span>,  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)  </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>biz_type ：代表不同业务类型</p><p>max_id ：当前最大的可用id</p><p>step ：代表号段的长度</p><p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p><p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update id_generator </span><br><span class="line"><span class="keyword">set</span> max_id <span class="operator">=</span> #&#123;max_id<span class="operator">+</span>step&#125;, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> version <span class="operator">=</span> # &#123;version&#125; </span><br><span class="line"><span class="keyword">and</span> biz_type <span class="operator">=</span> XXX</span><br></pre></td></tr></table></figure><p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p><h3 id="5-基于Redis模式"><a href="#5-基于Redis模式" class="headerlink" title="5. 基于Redis模式"></a>5. 基于Redis模式</h3><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回递增后的数值</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p><ul><li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li><li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li></ul><h3 id="6-基于雪花算法（Snowflake）模式"><a href="#6-基于雪花算法（Snowflake）模式" class="headerlink" title="6. 基于雪花算法（Snowflake）模式"></a>6. 基于雪花算法（Snowflake）模式</h3><p>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/CKvMdchsUwmvJKLibqWqBoicnq8kIziaqXfHj2joZBicKeaPH4yU8Ie4YdydvqKYCJicSQnN9yxUhpg72VSQRvOUAEw/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>在这里插入图片描述</p><blockquote><p>以上图片源自网络，如有侵权联系删除</p></blockquote><p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。</p><p>Snowflake ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p><ul><li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li><li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li><li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</li><li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p><p><strong>Java版本的<code>Snowflake</code>算法实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL * &lt;p&gt;  </span></span><br><span class="line"><span class="comment"> * https://github.com/beyondfengyu/SnowFlake */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlakeShortUrl</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 起始的时间戳 */</span> privatefinalstaticlong START_TIMESTAMP = <span class="number">1480166465631L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 每一部分占用的位数 */</span> privatefinalstaticlong SEQUENCE_BIT = <span class="number">12</span>;   <span class="comment">//序列号占用的位数  </span></span><br><span class="line"> privatefinalstaticlong MACHINE_BIT = <span class="number">5</span>;     <span class="comment">//机器标识占用的位数  </span></span><br><span class="line"> privatefinalstaticlong DATA_CENTER_BIT = <span class="number">5</span>; <span class="comment">//数据中心占用的位数  </span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">/** * 每一部分的最大值 */</span> privatefinalstaticlong MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);  </span><br><span class="line">    privatefinalstaticlong MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);  </span><br><span class="line">    privatefinalstaticlong MAX_DATA_CENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 每一部分向左的位移 */</span> privatefinalstaticlong MACHINE_LEFT = SEQUENCE_BIT;  </span><br><span class="line">    privatefinalstaticlong DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;  </span><br><span class="line">    privatefinalstaticlong TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;  </span><br><span class="line">  </span><br><span class="line">    privatelong dataCenterId;  <span class="comment">//数据中心  </span></span><br><span class="line"> privatelong machineId;     <span class="comment">//机器标识  </span></span><br><span class="line"> privatelong sequence = <span class="number">0L</span>; <span class="comment">//序列号  </span></span><br><span class="line"> privatelong lastTimeStamp = -<span class="number">1L</span>;  <span class="comment">//上一次时间戳  </span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">long</span> mill = getNewTimeStamp();  </span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastTimeStamp) &#123;  </span><br><span class="line"> mill = getNewTimeStamp();  </span><br><span class="line">        &#125;  </span><br><span class="line"> <span class="keyword">return</span> mill;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewTimeStamp</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> System.currentTimeMillis();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据指定的数据中心ID和机器标志ID生成指定的序列号 * * <span class="doctag">@param</span> dataCenterId 数据中心ID  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> machineId    机器标志ID  </span></span><br><span class="line"><span class="comment"> */</span> <span class="function"><span class="keyword">public</span> <span class="title">SnowFlakeShortUrl</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="number">0</span>) &#123;  </span><br><span class="line"> <span class="function">thrownew <span class="title">IllegalArgumentException</span> <span class="params">(<span class="string">&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;</span>)</span></span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"> <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;  </span><br><span class="line"> <span class="function">thrownew <span class="title">IllegalArgumentException</span> <span class="params">(<span class="string">&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;</span>)</span></span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"> <span class="keyword">this</span>.dataCenterId = dataCenterId;  </span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 产生下一个ID * * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">long</span> currTimeStamp = getNewTimeStamp();  </span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;  </span><br><span class="line"> <span class="function">thrownew <span class="title">RuntimeException</span> <span class="params">(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>)</span></span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;  </span><br><span class="line"> <span class="comment">//相同毫秒内，序列号自增  </span></span><br><span class="line"> sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;  </span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大  </span></span><br><span class="line"> <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;  </span><br><span class="line"> currTimeStamp = getNextMill();  </span><br><span class="line">            &#125;  </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"> <span class="comment">//不同毫秒内，序列号置为0  </span></span><br><span class="line"> sequence = <span class="number">0L</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line"> lastTimeStamp = currTimeStamp;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分  </span></span><br><span class="line"> | dataCenterId &lt;&lt; DATA_CENTER_LEFT <span class="comment">//数据中心部分  </span></span><br><span class="line"> | machineId &lt;&lt; MACHINE_LEFT <span class="comment">//机器标识部分  </span></span><br><span class="line"> | sequence;                             <span class="comment">//序列号部分  </span></span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"> SnowFlakeShortUrl snowFlake = <span class="keyword">new</span> SnowFlakeShortUrl(<span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) &#123;  </span><br><span class="line"> <span class="comment">//10进制  </span></span><br><span class="line"> System.out.println(snowFlake.nextId());  </span><br><span class="line">        &#125;  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-百度（uid-generator）"><a href="#7-百度（uid-generator）" class="headerlink" title="7. 百度（uid-generator）"></a>7. 百度（uid-generator）</h3><p><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 github.com/baidu/uid-g…</p><p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</p><p><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</p><p><strong>对于<code>uid-generator</code> ID组成结构</strong>：</p><p><code>workId</code>，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的<code>snowflake</code>不太一样，时间的单位是秒，而不是毫秒，<code>workId</code>也不一样，而且同一应用每次重启就会消费一个<code>workId</code>。</p><blockquote><p>参考文献 github.com/baidu/uid-g…</p></blockquote><h3 id="8-美团（Leaf）"><a href="#8-美团（Leaf）" class="headerlink" title="8. 美团（Leaf）"></a>8. 美团（Leaf）</h3><p><code>Leaf</code>由美团开发，github地址：github.com/Meituan-Dia…</p><p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p><h4 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h4><p>先导入源码 github.com/Meituan-Dia… ，在建一张表<code>leaf_alloc</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DROPTABLEIFEXISTS`leaf_alloc`;  </span><br><span class="line">  </span><br><span class="line">CREATETABLE`leaf_alloc` (  </span><br><span class="line">`biz_tag`<span class="type">varchar</span>(<span class="number">128</span>) NOTNULLDEFAULT<span class="string">&#x27;&#x27;</span>COMMENT<span class="string">&#x27;业务key&#x27;</span>,  </span><br><span class="line">`max_id`<span class="type">bigint</span>(<span class="number">20</span>) NOTNULLDEFAULT<span class="string">&#x27;1&#x27;</span>COMMENT<span class="string">&#x27;当前已经分配了的最大id&#x27;</span>,  </span><br><span class="line">`step`<span class="type">int</span>(<span class="number">11</span>) NOTNULLCOMMENT<span class="string">&#x27;初始步长，也是动态调整的最小步长&#x27;</span>,  </span><br><span class="line">`description`<span class="type">varchar</span>(<span class="number">256</span>) DEFAULTNULLCOMMENT<span class="string">&#x27;业务key的描述&#x27;</span>,  </span><br><span class="line">`update_time`timestampNOTNULLDEFAULTCURRENT_TIMESTAMPONUPDATECURRENT_TIMESTAMPCOMMENT<span class="string">&#x27;数据库维护的更新时间&#x27;</span>,  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`biz_tag`)  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">leaf.name</span>=<span class="string">com.sankuai.leaf.opensource.test</span></span><br><span class="line"><span class="meta">leaf.segment.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">leaf.jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span></span><br><span class="line"><span class="meta">leaf.jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">leaf.jdbc.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">leaf.snowflake.enable</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#leaf.snowflake.zk.address=</span></span><br><span class="line"><span class="comment">#leaf.snowflake.port=</span></span><br></pre></td></tr></table></figure><p>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</p><p>号段模式获取分布式自增ID的测试url ：http：&lt;//localhost&gt;：8080/api/segment/get/leaf-segment-test</p><p>监控号段模式：<a target="_blank" rel="noopener" href="http://localhost:8080/cache">http://localhost:8080/cache</a></p><h4 id="snowflake模式"><a href="#snowflake模式" class="headerlink" title="snowflake模式"></a>snowflake模式</h4><p><code>Leaf</code>的snowflake模式依赖于<code>ZooKeeper</code>，不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上，<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">leaf.snowflake.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">leaf.snowflake.zk.address</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">leaf.snowflake.port</span>=<span class="string">2181</span></span><br></pre></td></tr></table></figure><p>snowflake模式获取分布式自增ID的测试url：<a target="_blank" rel="noopener" href="http://localhost:8080/api/snowflake/get/test">http://localhost:8080/api/snowflake/get/test</a></p><h3 id="9、滴滴（Tinyid）"><a href="#9、滴滴（Tinyid）" class="headerlink" title="9、滴滴（Tinyid）"></a>9、滴滴（Tinyid）</h3><p><code>Tinyid</code>由滴滴开发，Github地址：github.com/didi/tinyid…</p><p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p><p><img src="https://mmbiz.qpic.cn/mmbiz/CKvMdchsUwmvJKLibqWqBoicnq8kIziaqXfPldzuU0Nw4A05UYZW9alI3TLicJWvsvkPkyxiapbBGg9mEYAiajSLiaRJg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>在这里插入图片描述</p><p><code>Tinyid</code>提供<code>http</code>和<code>tinyid-client</code>两种方式接入</p><h4 id="Http方式接入"><a href="#Http方式接入" class="headerlink" title="Http方式接入"></a>Http方式接入</h4><p>（1）导入Tinyid源码：</p><p>git clone github.com/didi/tinyid…</p><p>（2）创建数据表：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CREATETABLE`tiny_id_info` (  </span><br><span class="line">`id`<span class="type">bigint</span>(<span class="number">20</span>) unsignedNOTNULL AUTO_INCREMENT COMMENT<span class="string">&#x27;自增主键&#x27;</span>,  </span><br><span class="line">`biz_type`<span class="type">varchar</span>(<span class="number">63</span>) NOTNULLDEFAULT<span class="string">&#x27;&#x27;</span>COMMENT<span class="string">&#x27;业务类型，唯一&#x27;</span>,  </span><br><span class="line">`begin_id`<span class="type">bigint</span>(<span class="number">20</span>) NOTNULLDEFAULT<span class="string">&#x27;0&#x27;</span>COMMENT<span class="string">&#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;</span>,  </span><br><span class="line">`max_id`<span class="type">bigint</span>(<span class="number">20</span>) NOTNULLDEFAULT<span class="string">&#x27;0&#x27;</span>COMMENT<span class="string">&#x27;当前最大id&#x27;</span>,  </span><br><span class="line">`step`<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span><span class="string">&#x27;0&#x27;</span>COMMENT<span class="string">&#x27;步长&#x27;</span>,  </span><br><span class="line">`delta`<span class="type">int</span>(<span class="number">11</span>) NOTNULLDEFAULT<span class="string">&#x27;1&#x27;</span>COMMENT<span class="string">&#x27;每次id增量&#x27;</span>,  </span><br><span class="line">`remainder`<span class="type">int</span>(<span class="number">11</span>) NOTNULLDEFAULT<span class="string">&#x27;0&#x27;</span>COMMENT<span class="string">&#x27;余数&#x27;</span>,  </span><br><span class="line">`create_time`timestampNOTNULLDEFAULT<span class="string">&#x27;2010-01-01 00:00:00&#x27;</span>COMMENT<span class="string">&#x27;创建时间&#x27;</span>,  </span><br><span class="line">`update_time`timestampNOTNULLDEFAULT<span class="string">&#x27;2010-01-01 00:00:00&#x27;</span>COMMENT<span class="string">&#x27;更新时间&#x27;</span>,  </span><br><span class="line">`version`<span class="type">bigint</span>(<span class="number">20</span>) NOTNULLDEFAULT<span class="string">&#x27;0&#x27;</span>COMMENT<span class="string">&#x27;版本号&#x27;</span>,  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),  </span><br><span class="line">UNIQUEKEY`uniq_biz_type` (`biz_type`)  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span>DEFAULTCHARSET<span class="operator">=</span>utf8 COMMENT<span class="string">&#x27;id信息表&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line">CREATETABLE`tiny_id_token` (  </span><br><span class="line">`id`<span class="type">int</span>(<span class="number">11</span>) unsignedNOTNULL AUTO_INCREMENT COMMENT<span class="string">&#x27;自增id&#x27;</span>,  </span><br><span class="line">`token`<span class="type">varchar</span>(<span class="number">255</span>) NOTNULLDEFAULT<span class="string">&#x27;&#x27;</span>COMMENT<span class="string">&#x27;token&#x27;</span>,  </span><br><span class="line">`biz_type`<span class="type">varchar</span>(<span class="number">63</span>) NOTNULLDEFAULT<span class="string">&#x27;&#x27;</span>COMMENT<span class="string">&#x27;此token可访问的业务类型标识&#x27;</span>,  </span><br><span class="line">`remark`<span class="type">varchar</span>(<span class="number">255</span>) NOTNULLDEFAULT<span class="string">&#x27;&#x27;</span>COMMENT<span class="string">&#x27;备注&#x27;</span>,  </span><br><span class="line">`create_time`timestampNOTNULLDEFAULT<span class="string">&#x27;2010-01-01 00:00:00&#x27;</span>COMMENT<span class="string">&#x27;创建时间&#x27;</span>,  </span><br><span class="line">`update_time`timestampNOTNULLDEFAULT<span class="string">&#x27;2010-01-01 00:00:00&#x27;</span>COMMENT<span class="string">&#x27;更新时间&#x27;</span>,  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span>DEFAULTCHARSET<span class="operator">=</span>utf8 COMMENT<span class="string">&#x27;token信息表&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line">INSERTINTO`tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)  </span><br><span class="line"><span class="keyword">VALUES</span>  </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class="string">&#x27;2018-07-22 23:19:27&#x27;</span>, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">INSERTINTO`tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)  </span><br><span class="line"><span class="keyword">VALUES</span>  </span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;test_odd&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class="string">&#x27;2018-07-23 00:39:24&#x27;</span>, <span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">INSERTINTO`tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)  </span><br><span class="line"><span class="keyword">VALUES</span>  </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:48&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">INSERTINTO`tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)  </span><br><span class="line"><span class="keyword">VALUES</span>  </span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class="string">&#x27;test_odd&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class="string">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（3）配置数据库：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">datasource.tinyid.names</span>=<span class="string">primary</span></span><br><span class="line"><span class="meta">datasource.tinyid.primary.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">datasource.tinyid.primary.url</span>=<span class="string">jdbc:mysql://ip:port/databaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="meta">datasource.tinyid.primary.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">datasource.tinyid.primary.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>（4）启动<code>tinyid-server</code>后测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">获取分布式自增ID: </span><br><span class="line">http://localhost:9999/tinyid/id/nextIdSimple?bizType=<span class="built_in">test</span>&amp;token=0f673adf80504e2eaa552f5d791b644c<span class="string">&#x27;</span></span><br><span class="line"><span class="string">返回结果: 3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">批量获取分布式自增ID:</span></span><br><span class="line"><span class="string">http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=10&#x27;</span>返回结果:  4,5,6,7,8,9,10,11,12,13</span><br></pre></td></tr></table></figure><h4 id="Java客户端方式接入"><a href="#Java客户端方式接入" class="headerlink" title="Java客户端方式接入"></a>Java客户端方式接入</h4><p>重复Http方式的（2）（3）操作</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xiaoju.uemc.tinyid<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tinyid-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tinyid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">tinyid.server</span> = <span class="string">localhost:9999</span></span><br><span class="line"><span class="meta">tinyid.token</span> = <span class="string">0f673adf80504e2eaa552f5d791b644c</span></span><br></pre></td></tr></table></figure><p><code>test</code> 、<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code> 是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取单个分布式自增ID</span></span><br><span class="line">Long id =  TinyId . nextId( <span class="string">&quot; test &quot;</span> );</span><br><span class="line"><span class="comment">// 按需批量分布式自增</span></span><br><span class="line">IDList&lt; Long &gt; ids =  TinyId . nextId( <span class="string">&quot; test &quot;</span> , <span class="number">10</span> );</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040240955">(……) 「Java面试指北」为什么需要分布式ID？大厂的分布式 ID 生成方案是什么样的？| JavaGuide - SegmentFault 思否</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-_KLEGVmREI5Y2Y5HWImWw">一口气说出9种分布式ID生成方式，面试官有点懵了！ (qq.com)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5lVOT2E2j7HVVVdCuoUoiw">【面朝大厂】面试官：说几种常用的分布式 ID 解决方案 (qq.com)</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/">https://lemon-cs.github.io/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/">分布式ID</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2022/02/80bab5e678236c43.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/09/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2021/12/8ceea24ac1259251.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式锁</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2021/12/145436554af6720c.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">跳表原理及实现</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">108</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-ID"><span class="toc-text">分布式 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-ID%EF%BC%9F"><span class="toc-text">何为 ID？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%88%86%E5%B8%83%E5%BC%8F-ID%EF%BC%9F"><span class="toc-text">何为分布式 ID？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82"><span class="toc-text">分布式 ID 需要满足哪些要求?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">分布式 ID 常见解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E"><span class="toc-text">数据库主键自增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">数据库号段模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NoSQL"><span class="toc-text">NoSQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UUID"><span class="toc-text">UUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Snowflake-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="toc-text">Snowflake(雪花算法)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="toc-text">开源框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UidGenerator-%E7%99%BE%E5%BA%A6"><span class="toc-text">UidGenerator(百度)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leaf-%E7%BE%8E%E5%9B%A2"><span class="toc-text">Leaf(美团)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tinyid-%E6%BB%B4%E6%BB%B4"><span class="toc-text">Tinyid(滴滴)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FID%E6%96%B9%E6%A1%88"><span class="toc-text">分布式ID方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8EUUID"><span class="toc-text">1. 基于UUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9EID"><span class="toc-text">2. 基于数据库自增ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">3. 基于数据库集群模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">4. 基于数据库的号段模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9F%BA%E4%BA%8ERedis%E6%A8%A1%E5%BC%8F"><span class="toc-text">5. 基于Redis模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9F%BA%E4%BA%8E%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%88Snowflake%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-text">6. 基于雪花算法（Snowflake）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%99%BE%E5%BA%A6%EF%BC%88uid-generator%EF%BC%89"><span class="toc-text">7. 百度（uid-generator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BE%8E%E5%9B%A2%EF%BC%88Leaf%EF%BC%89"><span class="toc-text">8. 美团（Leaf）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">号段模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#snowflake%E6%A8%A1%E5%BC%8F"><span class="toc-text">snowflake模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%BB%B4%E6%BB%B4%EF%BC%88Tinyid%EF%BC%89"><span class="toc-text">9、滴滴（Tinyid）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Http%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5"><span class="toc-text">Http方式接入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5"><span class="toc-text">Java客户端方式接入</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/14/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Kubernetes集群搭建"><img src="https://s4.ax1x.com/2022/02/15/HRSnhQ.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Kubernetes集群搭建"></a><div class="content"><a class="title" href="/2022/02/14/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Kubernetes集群搭建">Kubernetes集群搭建</a><time datetime="2022-02-14T09:51:10.000Z" title="发表于 2022-02-14 17:51:10">2022-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/12/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/Kubernetes%E5%85%A5%E9%97%A8/" title="Kubernetes入门"><img src="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Kubernetes入门"></a><div class="content"><a class="title" href="/2022/02/12/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/Kubernetes%E5%85%A5%E9%97%A8/" title="Kubernetes入门">Kubernetes入门</a><time datetime="2022-02-12T09:51:10.000Z" title="发表于 2022-02-12 17:51:10">2022-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/09/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="分布式锁"><img src="https://s3.bmp.ovh/imgs/2021/12/8ceea24ac1259251.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="分布式锁"></a><div class="content"><a class="title" href="/2022/02/09/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="分布式锁">分布式锁</a><time datetime="2022-02-09T14:25:10.000Z" title="发表于 2022-02-09 22:25:10">2022-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/" title="分布式ID"><img src="https://s3.bmp.ovh/imgs/2022/02/80bab5e678236c43.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="分布式ID"></a><div class="content"><a class="title" href="/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID/" title="分布式ID">分布式ID</a><time datetime="2022-02-07T14:25:10.000Z" title="发表于 2022-02-07 22:25:10">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img src="https://s3.bmp.ovh/imgs/2021/12/145436554af6720c.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跳表原理及实现"></a><div class="content"><a class="title" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现">跳表原理及实现</a><time datetime="2022-02-07T13:19:43.000Z" title="发表于 2022-02-07 21:19:43">2022-02-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>