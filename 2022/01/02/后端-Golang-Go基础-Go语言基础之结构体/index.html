<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go语言基础之结构体 | Lemon-CS</title><meta name="keywords" content="Go"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Go语言基础之结构体"><meta property="og:type" content="article"><meta property="og:title" content="Go语言基础之结构体"><meta property="og:url" content="https://lemon-cs.github.io/2022/01/02/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="Go语言基础之结构体"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg"><meta property="article:published_time" content="2022-01-02T14:09:50.000Z"><meta property="article:modified_time" content="2022-01-05T03:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="Go"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2022/01/02/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Go语言基础之结构体",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-05 11:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go语言基础之结构体</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-02T14:09:50.000Z" title="发表于 2022-01-02 22:09:50">2022-01-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-05T03:37:35.000Z" title="更新于 2022-01-05 11:37:35">2022-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Go语言基础之结构体"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Go语言基础之结构体"><a href="#Go语言基础之结构体" class="headerlink" title="Go语言基础之结构体"></a>Go语言基础之结构体</h1><p><strong>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</strong> Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h1 id="1-类型别名和自定义类型"><a href="#1-类型别名和自定义类型" class="headerlink" title="1. 类型别名和自定义类型"></a>1. 类型别名和自定义类型</h1><h2 id="1-1-自定义类型"><a href="#1-1-自定义类型" class="headerlink" title="1.1 自定义类型"></a>1.1 自定义类型</h2><blockquote><p>无等号-定义自定义类型</p></blockquote><p>在 Go 语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go 语言中可以使用type关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过 struct 定义。例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span> <span class="comment">// 类型为main.MyInt，即为包名.自定义类型名</span></span><br></pre></td></tr></table></figure><p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p><h2 id="1-2-类型别名"><a href="#1-2-类型别名" class="headerlink" title="1.2 类型别名"></a>1.2 类型别名</h2><blockquote><p>有等号-类型仍是Type，只是加了个别名。</p></blockquote><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码中设置的别名byte和rune</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><h2 id="1-3-类型定义和类型别名的区别"><a href="#1-3-类型定义和类型别名的区别" class="headerlink" title="1.3 类型定义和类型别名的区别"></a>1.3 类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a NewInt</span><br><span class="line">	<span class="keyword">var</span> b MyInt</span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h1 id="2-结构体（struct）"><a href="#2-结构体（struct）" class="headerlink" title="2. 结构体（struct）"></a>2. 结构体（struct）</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><ol><li><p>常规面向对象语言（java，c#）使用类来实现属性和方法的聚合以及继承的概念。</p></li><li><p>Go语言不是一种 “传统” 的面向对象编程语言，它没有类和继承的概念。Go语言通过结构体来实现上述功能。</p></li><li><p>结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。</p></li></ol><h2 id="2-1-结构体的定义"><a href="#2-1-结构体的定义" class="headerlink" title="2.1 结构体的定义"></a>2.1 结构体的定义</h2><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>类型名：标识自定义结构体的名称，在同一个包内不能重复。</p></li><li><p>字段名：表示结构体字段名。结构体中的字段名必须唯一。</p></li><li><p>字段类型：表示结构体字段的具体类型。</p></li></ul><p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, city <span class="keyword">string</span></span><br><span class="line">	age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型。</p><h2 id="2-2-结构体实例化"><a href="#2-2-结构体实例化" class="headerlink" title="2.2 结构体实例化"></a>2.2 结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><ol><li>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。</li><li>Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</li></ol><h3 id="基本实例化形式"><a href="#基本实例化形式" class="headerlink" title="基本实例化形式"></a>基本实例化形式</h3><p>举个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p1 person</span><br><span class="line">	p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">	p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	p1.age = <span class="number">18</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个匿名的就够提并进行初始化</span></span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><blockquote><p>关键字new(返回基本数据类型的指针)</p></blockquote><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p><strong>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">&quot;上海&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><blockquote><p>关键字&amp;( <code>&amp;person&#123;&#125;</code> )</p></blockquote><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h2 id="2-3-结构体初始化"><a href="#2-3-结构体初始化" class="headerlink" title="2.3 结构体初始化"></a>2.3 结构体初始化</h2><p>初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p4 person</span><br><span class="line">	fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><p>普通结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式且不能混用：</p><ol><li>字段“键值对”形式：适合选择性填充字段较多的结构体。</li><li>多个值的列表形式：适合填充字段较少的结构体。</li></ol><h4 id="1-字段“键值对”形式"><a href="#1-字段“键值对”形式" class="headerlink" title="1.  字段“键值对”形式"></a>1. 字段“键值对”形式</h4><ol><li>键值对的填充是可选的，不需要初始化的字段可以不填入到初始化列表中。这些字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 “”（空字符串）、布尔为 false、指针为 nil 等。</li><li>键值之间以<code>:</code>分隔，键值对之间以<code>,</code>分隔。</li></ol><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">	name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化（常用），例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">	name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。<strong>此时，没有指定初始值的字段的值就是该字段类型的零值。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-多个值的列表形式"><a href="#2-多个值的列表形式" class="headerlink" title="2. 多个值的列表形式"></a>2. 多个值的列表形式</h4><blockquote><p>类似终端输入</p></blockquote><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">	<span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	<span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的<code>所有字段</code>。</li><li>初始值的填充顺序必须与字段在结构体中的声明<code>顺序一致</code>。</li><li><code>该方式不能和键值初始化方式混用。</code></li></ol><h3 id="匿名结构体-1"><a href="#匿名结构体-1" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><ol><li><p>匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。</p></li><li><p>匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p></li><li><p>匿名结构体的初始化写法由两部分组成：</p><ul><li>结构体的定义：没有结构体名，只有字段和类型定义。</li><li>键值对初始化：由可选的多个键值对组成。该部分是可选的。</li></ul></li></ol><h4 id="1-匿名结构体的定义和初始化"><a href="#1-匿名结构体的定义和初始化" class="headerlink" title="1. 匿名结构体的定义和初始化"></a>1. 匿名结构体的定义和初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="comment">// 字段值初始化</span></span><br><span class="line">    初始化字段<span class="number">1</span>: 字段<span class="number">1</span>的值,</span><br><span class="line">    初始化字段<span class="number">2</span>: 字段<span class="number">2</span>的值,</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line">msg := <span class="keyword">struct</span> &#123;  <span class="comment">// 定义部分</span></span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    data <span class="keyword">string</span></span><br><span class="line">&#125;&#123;  <span class="comment">// 值初始化部分</span></span><br><span class="line">    <span class="number">1024</span>,</span><br><span class="line">    <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-匿名结构体不初始化成员时"><a href="#2-匿名结构体不初始化成员时" class="headerlink" title="2.匿名结构体不初始化成员时"></a>2.匿名结构体不初始化成员时</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsgType</span><span class="params">(msg <span class="keyword">struct</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    id   <span class="keyword">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用动词%T打印msg的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-结构体内存布局"><a href="#2-4-结构体内存布局" class="headerlink" title="2.4 结构体内存布局"></a>2.4 结构体内存布局</h2><p>结构体占用一块连续的内存。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int8</span></span><br><span class="line">	b <span class="keyword">int8</span></span><br><span class="line">	c <span class="keyword">int8</span></span><br><span class="line">	d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n.a <span class="number">0xc0000a0060</span></span><br><span class="line">n.b <span class="number">0xc0000a0061</span></span><br><span class="line">n.c <span class="number">0xc0000a0062</span></span><br><span class="line">n.d <span class="number">0xc0000a0063</span></span><br></pre></td></tr></table></figure><p>进阶知识点】关于Go语言中的内存对齐推荐阅读:<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">在 Go 中恰到好处的内存对齐</a></p><h2 id="2-5-空结构体"><a href="#2-5-空结构体" class="headerlink" title="2.5 空结构体"></a>2.5 空结构体</h2><p><strong>空结构体是不占用空间的。</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h1 id="3-结构体的其他知识点"><a href="#3-结构体的其他知识点" class="headerlink" title="3. 结构体的其他知识点"></a>3. 结构体的其他知识点</h1><h2 id="3-1-模拟构造函数实现"><a href="#3-1-模拟构造函数实现" class="headerlink" title="3.1 模拟构造函数实现"></a>3.1 模拟构造函数实现</h2><blockquote><p>约定成俗以new开头</p></blockquote><blockquote><p>其他编程语言构造函数的一些常见功能及特性如下：</p><ol><li>每个类可以添加构造函数，多个构造函数使用函数重载实现。</li><li>构造函数一般与类名同名，且没有返回值。</li><li>构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。</li><li>对于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 来说，还有默认构造函数、拷贝构造函数等。</li></ol></blockquote><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson1</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> <span class="title">person</span></span> &#123;<span class="comment">// 值拷贝性能开销会比较大；不推荐</span></span><br><span class="line">	<span class="keyword">return</span> person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		city: city,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson2</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">person</span></span> &#123;<span class="comment">// 返回的是结构体指针类型开销较小</span></span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		city: city,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1 := newPerson1(<span class="string">&quot;hao&quot;</span>, <span class="string">&quot;wuhan&quot;</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %#v\n&quot;</span>, p1, p1)<span class="comment">// main.person、main.person&#123;name:&quot;hao&quot;, city:&quot;wuhan&quot;, age:23&#125;</span></span><br><span class="line">p2 := newPerson2(<span class="string">&quot;hao&quot;</span>, <span class="string">&quot;wuhan&quot;</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %#v\n&quot;</span>, p2, p2)<span class="comment">// *main.person、&amp;main.person&#123;name:&quot;hao&quot;, city:&quot;wuhan&quot;, age:23&#125;</span></span><br></pre></td></tr></table></figure><ol><li>Go语言的结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。</li><li>我们通常通过 <code>New?</code> 或 <code>New?By?</code> 来模式构造方法，实现重载。</li></ol><h3 id="多种方式创建和初始化结构体"><a href="#多种方式创建和初始化结构体" class="headerlink" title="多种方式创建和初始化结构体"></a>多种方式创建和初始化结构体</h3><blockquote><p>模拟构造函数重载</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCatByName</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cat&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCatByColor</span><span class="params">(color <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cat&#123;</span><br><span class="line">        Color: color,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带有父子关系的结构体的构造和初始化"><a href="#带有父子关系的结构体的构造和初始化" class="headerlink" title="带有父子关系的结构体的构造和初始化"></a>带有父子关系的结构体的构造和初始化</h3><blockquote><p>模拟父级构造调用</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// “构造基类”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCat</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cat&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BlackCat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Cat  <span class="comment">// 嵌入Cat, 类似于派生</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// “构造子类”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlackCat</span><span class="params">(color <span class="keyword">string</span>)</span> *<span class="title">BlackCat</span></span> &#123;</span><br><span class="line">    cat := &amp;BlackCat&#123;&#125;</span><br><span class="line">    cat.Color = color</span><br><span class="line">    <span class="keyword">return</span> cat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-方法和接收者"><a href="#3-2-方法和接收者" class="headerlink" title="3.2 方法和接收者"></a>3.2 方法和接收者</h2><blockquote><p>常用：相当于给 <code>接收者</code> 【<strong>接收者的类型可以是任何类型，不仅仅是结构体</strong>】添加方法!!!</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><ol><li><p>在Go语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？Go语言中类方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。一个类型加上它的方法等价于面向对象中的一个类。</p></li><li><p>在Go语言中，绑定在接收器上的方法可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。</p></li><li><p>一个接收器类型上的所有方法的集合叫做该接收器的方法集。</p></li><li><p>接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。</p><ul><li>接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误<code>invalid receiver type…</code>。</li><li>接收器不能是一个指针类型，但是它可以是任何其他允许类型的指针。</li></ul></li></ol><p><strong>方法的定义格式如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在关键字和方法名之间添加了`(接收者变量 接收者类型)`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><p>接收者变量：接收者中的参数变量名在命名时，官方建议常用：使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</p></li><li><p>接收者类型：接收者类型和参数类似，可以是<code>指针类型和非指针类型</code>。 两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中：</p><ul><li>指针类型 ：大对象因为复制性能较低，在接收器和参数间传递时不进行复制，只是传递指针。</li><li>非指针类型：小对象由于值复制时的速度较快，所以适合使用非指针接收器。</li></ul></li><li><p>方法名、参数列表、返回参数：具体格式与函数定义相同。</p></li><li><p><strong>注意</strong>：方法仅支持该结构体构造函数的实例去调用且接收者变量可以代表实例在方法内部使用。</p></li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><blockquote><p>可以修改实例</p></blockquote><ol><li>指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。</li><li>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，都是有效的。</li></ol><p>例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">	p1.SetAge(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><blockquote><p>修改的知识实例的副本，无法影响实例</p></blockquote><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">	p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者？"><a href="#什么时候应该使用指针类型接收者？" class="headerlink" title="什么时候应该使用指针类型接收者？"></a>什么时候应该使用指针类型接收者？</h3><ol><li><p>需要修改接收者中的值</p></li><li><p>接收者是拷贝代价比较大的大对象</p></li><li><p>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</p></li></ol><h2 id="3-3-任意类型添加方法"><a href="#3-3-任意类型添加方法" class="headerlink" title="3.3 任意类型添加方法"></a>3.3 任意类型添加方法</h2><p>在Go语言中，<strong>接收者的类型可以是任何类型，不仅仅是结构体</strong>，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m1 MyInt</span><br><span class="line">	m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">	m1 = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项：</strong><br><code>非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</code>扩展出不能给内置或其他包的类型添加方法，如上述例子给MyInt添加方法实现给int添加方法。</p></blockquote><h2 id="3-4-结构体的匿名字段"><a href="#3-4-结构体的匿名字段" class="headerlink" title="3.4 结构体的匿名字段"></a>3.4 结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">string</span> <span class="comment">// 没有字段名！！！</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;</span><br><span class="line">		<span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		<span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span></span><br><span class="line">	fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong><br>这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p></blockquote><h2 id="3-5-嵌套结构体"><a href="#3-5-嵌套结构体" class="headerlink" title="3.5 嵌套结构体"></a>3.5 嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user1 := User&#123;</span><br><span class="line">		Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		Address: Address&#123;</span><br><span class="line">			Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">			City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ol><li><p>结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时内嵌结构体的字段名为类型名。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。</p></li><li><p>可以粗略地将这个和面向对象语言中的继承概念相比较，Go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性，从而实现类似继承功能。</p></li><li><p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p></li><li><p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。内嵌结构体字段仍然可以使用详细的字段进行一层层访问，</p></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    in1 <span class="keyword">int</span></span><br><span class="line">    in2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">int</span> <span class="comment">// anonymous field</span></span><br><span class="line">    innerS <span class="comment">//anonymous field</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">    outer.b = <span class="number">6</span></span><br><span class="line">    outer.c = <span class="number">7.5</span></span><br><span class="line">    outer.<span class="keyword">int</span> = <span class="number">60</span></span><br><span class="line">    outer.in1 = <span class="number">5</span></span><br><span class="line">    outer.in2 = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.b is: %d\n&quot;</span>, outer.b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.c is: %f\n&quot;</span>, outer.c)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.int is: %d\n&quot;</span>, outer.<span class="keyword">int</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.in1 is: %d\n&quot;</span>, outer.in1)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer.in2 is: %d\n&quot;</span>, outer.in2)</span><br><span class="line">    <span class="comment">// 使用结构体字面量</span></span><br><span class="line">    outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;outer2 is:&quot;</span>, outer2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line">outer.b is: <span class="number">6</span></span><br><span class="line">outer.c is: <span class="number">7.500000</span></span><br><span class="line">outer.<span class="keyword">int</span> is: <span class="number">60</span></span><br><span class="line">outer.in1 is: <span class="number">5</span></span><br><span class="line">outer.in2 is: <span class="number">10</span></span><br><span class="line">outer2 is:&#123;<span class="number">6</span> <span class="number">7.5</span> <span class="number">60</span> &#123;<span class="number">5</span> <span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名字段"><a href="#嵌套匿名字段" class="headerlink" title="嵌套匿名字段"></a>嵌套匿名字段</h3><p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user2 User</span><br><span class="line">	user2.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">	user2.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">	user2.Address.Province = <span class="string">&quot;山东&quot;</span>    <span class="comment">// 匿名字段默认使用类型名作为字段名</span></span><br><span class="line">	user2.City = <span class="string">&quot;威海&quot;</span>                <span class="comment">// 匿名字段可以省略</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) <span class="comment">//user2=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</strong></p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><p>在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。</p><p>上述例子中可以省略匿名字段，但是两个匿名字段中存在相同字段名则不能省略。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province   <span class="keyword">string</span></span><br><span class="line">	City       <span class="keyword">string</span></span><br><span class="line">	CreateTime <span class="keyword">string</span><span class="comment">//字段重名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">	Account    <span class="keyword">string</span></span><br><span class="line">	CreateTime <span class="keyword">string</span><span class="comment">//字段重名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Address</span><br><span class="line">	Email</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user3 User</span><br><span class="line">	user3.Name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">	user3.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">	<span class="comment">// user3.CreateTime = &quot;2022&quot; // 报错: ambiguous selector user3.CreateTime</span></span><br><span class="line">	user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">	user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用如上错误方式时，编译阶段会报错：<code>.\main.go:13:3: ambiguous selector user3.CreateTime</code></p><h2 id="3-6-结构体的“继承”"><a href="#3-6-结构体的“继承”" class="headerlink" title="3.6 结构体的“继承”"></a>3.6 结构体的“继承”</h2><p>Go语言中没有继承的概念，但是使用结构体也可以实现其他编程语言中面向对象的继承。</p><p><strong>通过嵌套匿名结构体模拟实现继承：Dog中没有的属性和方法，会去嵌套的匿名结构体中去找。</strong></p><blockquote><p>比如集成gin框架的路由引擎，再在其上扩展新的路由。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Feet    <span class="keyword">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := &amp;Dog&#123;</span><br><span class="line">		Feet: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">	d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-结构体字段的可见性"><a href="#3-7-结构体字段的可见性" class="headerlink" title="3.7 结构体字段的可见性"></a>3.7 结构体字段的可见性</h2><p>结构体中<code>字段大写</code>开头表示可<code>公开访问</code>，<code>小写表示私有</code>（仅在定义当前结构体的包中可访问）。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220228161125.png"></p><h2 id="3-8-结构体与JSON序列化"><a href="#3-8-结构体与JSON序列化" class="headerlink" title="3.8 结构体与JSON序列化"></a>3.8 结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220228161224.png"></p><p>通过包 “encoding/json”的 <code>data, err := json.Marshal(c)</code> 和 <code>err = json.Unmarshal([]byte(str), c1)</code> 方法实现序列化和反序列化。原理是字符串类型是由切片类型组成的，两者可以互相转换。序列化时返回的是切片，通过string(切片)转成字符串；反序列化的第二个参数是指针，若不是指针无法存储，因为修改的是副本。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title    <span class="keyword">string</span></span><br><span class="line">	Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := &amp;Class&#123;</span><br><span class="line">		Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">		Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		stu := &amp;Student&#123;</span><br><span class="line">			Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">			Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">			ID:     i,</span><br><span class="line">		&#125;</span><br><span class="line">		c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">	data, err := json.Marshal(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line">	<span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">	str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">	c1 := &amp;Class&#123;&#125;</span><br><span class="line">	err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-结构体标签（Tag）"><a href="#3-9-结构体标签（Tag）" class="headerlink" title="3.9 结构体标签（Tag）"></a>3.9 结构体标签（Tag）</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在<code>3.7 结构体字段的可见性</code>中知道第三方包想要使用当前包的值，必须首字母是大写状态。所以使用”encoding/json”格式化时，内部所有字段名必须首字母大写，但是序列化的字符串的字段不是想要的，可以通过Tag指定想要的格式。</p><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span></span><br><span class="line"><span class="comment">// 常用的如json、db、ini配置文件</span></span><br><span class="line"><span class="string">`json:&quot;name&quot; db:&quot;name&quot; ini:&quot;name&quot;`</span></span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><blockquote><p><strong>注意事项：</strong><br>为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p></blockquote><p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">	Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">	name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-10-结构体和方法补充知识点"><a href="#3-10-结构体和方法补充知识点" class="headerlink" title="3.10 结构体和方法补充知识点"></a>3.10 结构体和方法补充知识点</h2><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int8</span></span><br><span class="line">	dreams []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.dreams = dreams</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	data := []<span class="keyword">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>&#125;</span><br><span class="line">	p1.SetDreams(data) <span class="comment">//[吃饭 睡觉 打豆豆]</span></span><br><span class="line">	<span class="comment">// 你真的想要修改 p1.dreams 吗？</span></span><br><span class="line">	data[<span class="number">1</span>] = <span class="string">&quot;不睡觉&quot;</span></span><br><span class="line">	fmt.Println(p1.dreams)  <span class="comment">// [吃饭 不睡觉 打豆豆] ???指针相同，同时被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.dreams = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(dreams))</span><br><span class="line">	<span class="built_in">copy</span>(p.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p><p><code>基本数据类型的函数参数是操作副本；而引用数据类型在函数参数和返回值的时候是指针，因此需要copy副本。</code></p><blockquote><p>参考感谢<br><a target="_blank" rel="noopener" href="https://www.yuque.com/topazur/golang/tzgeo3">Go语言基础之结构体 · 语雀 (yuque.com)</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/blog.kang/im3lp1/xgpwc7">06.结构体 · 语雀 (yuque.com)</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/mingzibaliao/golang/gbq6ha#L3Xqn">struct 结构体 · 语雀 (yuque.com)</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2022/01/02/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/">https://lemon-cs.github.io/2022/01/02/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/03/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/"><img class="prev-cover" src="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go语言基础之接口</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/31/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/"><img class="next-cover" src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go语言基础之函数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/28/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Go开发环境搭建"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRSnhQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-28</div><div class="title">Go开发环境搭建</div></div></a></div><div><a href="/2021/12/30/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/" title="Go语言基础之map"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-30</div><div class="title">Go语言基础之map</div></div></a></div><div><a href="/2021/12/30/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/" title="Go语言基础之切片Slice"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-30</div><div class="title">Go语言基础之切片Slice</div></div></a></div><div><a href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img class="cover" src="https://static01.imgkr.com/temp/f64b83005c0248dca40c71705366ac18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-07</div><div class="title">跳表原理及实现</div></div></a></div><div><a href="/2021/12/29/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" title="Go语言基础之依赖管理"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/7f02b700ddd8d712.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-29</div><div class="title">Go语言基础之依赖管理</div></div></a></div><div><a href="/2021/12/30/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%97%E8%A1%A8list/" title="Go语言基础之列表list"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-30</div><div class="title">Go语言基础之列表list</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">Go语言基础之结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 类型别名和自定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.1 自定义类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">1.2 类型别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.3 类型定义和类型别名的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88struct%EF%BC%89"><span class="toc-text">2. 结构体（struct）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 结构体的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">2.2 结构体实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="toc-text">基本实例化形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">匿名结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">创建指针类型结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">取结构体的地址实例化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.3 结构体初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">普通结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5%E2%80%9C%E9%94%AE%E5%80%BC%E5%AF%B9%E2%80%9D%E5%BD%A2%E5%BC%8F"><span class="toc-text">1. 字段“键值对”形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84%E5%88%97%E8%A1%A8%E5%BD%A2%E5%BC%8F"><span class="toc-text">2. 多个值的列表形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="toc-text">匿名结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1. 匿名结构体的定义和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E6%97%B6"><span class="toc-text">2.匿名结构体不初始化成员时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">2.4 结构体内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.5 空结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">3. 结构体的其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A8%A1%E6%8B%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.1 模拟构造函数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">多种方式创建和初始化结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">带有父子关系的结构体的构造和初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-text">3.2 方法和接收者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-text">指针类型的接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-text">值类型的接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6%E8%80%85%EF%BC%9F"><span class="toc-text">什么时候应该使用指针类型接收者？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-text">3.3 任意类型添加方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">3.4 结构体的匿名字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">3.5 嵌套结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">嵌套匿名字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-text">嵌套结构体的字段名冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D"><span class="toc-text">3.6 结构体的“继承”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">3.7 结构体字段的可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8EJSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">3.8 结构体与JSON序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%EF%BC%88Tag%EF%BC%89"><span class="toc-text">3.9 结构体标签（Tag）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">3.10 结构体和方法补充知识点</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img src="https://static01.imgkr.com/temp/f64b83005c0248dca40c71705366ac18.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跳表原理及实现"></a><div class="content"><a class="title" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现">跳表原理及实现</a><time datetime="2022-02-07T13:19:43.000Z" title="发表于 2022-02-07 21:19:43">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/" title="Go并发编程之Goroutine和Channel"><img src="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go并发编程之Goroutine和Channel"></a><div class="content"><a class="title" href="/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/" title="Go并发编程之Goroutine和Channel">Go并发编程之Goroutine和Channel</a><time datetime="2022-01-18T14:09:50.000Z" title="发表于 2022-01-18 22:09:50">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2022-01-17T14:09:50.000Z" title="发表于 2022-01-17 22:09:50">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/%E5%90%8E%E7%AB%AF/Golang/Go%E5%AE%9E%E7%8E%B0/Go%E4%B8%8EJava%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" title="Go与Java实现生产者消费者"><img src="https://s3.bmp.ovh/imgs/2022/02/87365d0f071b194f.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go与Java实现生产者消费者"></a><div class="content"><a class="title" href="/2022/01/12/%E5%90%8E%E7%AB%AF/Golang/Go%E5%AE%9E%E7%8E%B0/Go%E4%B8%8EJava%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" title="Go与Java实现生产者消费者">Go与Java实现生产者消费者</a><time datetime="2022-01-12T03:37:35.000Z" title="发表于 2022-01-12 11:37:35">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/" title="进程、线程、协程"><img src="https://s3.bmp.ovh/imgs/2021/12/adda988fb50270fe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="进程、线程、协程"></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/" title="进程、线程、协程">进程、线程、协程</a><time datetime="2022-01-11T15:03:55.000Z" title="发表于 2022-01-11 23:03:55">2022-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>