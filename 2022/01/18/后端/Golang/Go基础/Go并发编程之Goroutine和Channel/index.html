<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go并发编程之Goroutine和Channel | Lemon-CS</title><meta name="keywords" content="Go"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Go并发编程之Goroutine和Channel"><meta property="og:type" content="article"><meta property="og:title" content="Go并发编程之Goroutine和Channel"><meta property="og:url" content="https://lemon-cs.github.io/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="Go并发编程之Goroutine和Channel"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg"><meta property="article:published_time" content="2022-01-18T14:09:50.000Z"><meta property="article:modified_time" content="2022-01-31T03:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="Go"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Go并发编程之Goroutine和Channel",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-31 11:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go并发编程之Goroutine和Channel</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-18T14:09:50.000Z" title="发表于 2022-01-18 22:09:50">2022-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-31T03:37:35.000Z" title="更新于 2022-01-31 11:37:35">2022-01-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Go并发编程之Goroutine和Channel"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Go语言基础之并发"><a href="#Go语言基础之并发" class="headerlink" title="Go语言基础之并发"></a>Go语言基础之并发</h1><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。</p><p>在学习Go的并发编程之前，首先要了解进程、线程、协程三者的区别，以及为什么需要协程。</p><blockquote><p>进程、线程、协程三者的区别详情见文章：<a href="https://lemon-cs.github.io/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/">进程、线程、协程 | Lemon-CS</a></p></blockquote><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h2 id="1-1-只执行一个任务"><a href="#1-1-只执行一个任务" class="headerlink" title="1.1 只执行一个任务"></a>1.1 只执行一个任务</h2><p>早期的单进程的操作系统，对于进程的执行，有以下的执行特点，就比如有多个进程，他们都是按照顺序进行执行的，当然执行<strong>线程</strong>也是， 对于 CPU 来说，他是无法区分进程和线程的。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143210.png"></p><p>同一时刻，单核 CPU只能处理一个任务。但是这种方式存在两个问题：</p><ul><li>单一执行流程，计算机只能一个任务一个任务的执行处理</li><li>继承阻塞所带来的 CPU 浪费时间，因为 CPU 是单核，没有什么切换能力，所以只能等待。</li></ul><h2 id="1-2-能不能宏观的执行多个任务呢？"><a href="#1-2-能不能宏观的执行多个任务呢？" class="headerlink" title="1.2 能不能宏观的执行多个任务呢？"></a>1.2 能不能宏观的执行多个任务呢？</h2><p>这时候，出现了一个 CPU 调度器。让这个 CPU 调度器进行轮询调度。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143338.png"></p><p>举个例子，假设现在有多个进程，CPU 调度器先调度<code>进程A</code>进行执行。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143416.png"></p><p>然后再调用<code>进程B</code>执行：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143501.png"></p><p>依次类推，但上面的问题依旧存在</p><ul><li>我的<code>进程 A</code> 是否已经跑完然后切换到<code>进程 B</code>，还是没有跑完切换到了进程 B</li><li>要在宏观上展示出来我们是在同时执行多个任务</li></ul><p>所以，<strong>调度器做了一个时间片的切分</strong>，如下图：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143601.png"></p><p>一个进程允许执行的最大时间不能超过我的时间片长度，如果超过时间片，则强制切换进程，也就是说，一个进程在 CPU 的执行时间长度是一定的，比如是 10 毫秒，那当 10 毫秒之后，不管这个进程有没有执行结束，CPU 调度器都会终止当前进程的运算，而把 CPU 给下一个进程使用。</p><p>如果<code>进程A</code>在被切换之前，没有运算完成，那么当 CPU 调度器轮询一圈后，则继续执行<code>进程A</code>的计算。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143743.png"></p><p>然后再执行<code>进程B</code></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143809.png"></p><p>再次执行<code>进程C</code></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143852.png"></p><p><strong>此时，在宏观上看，三个进程一起在往前走，一起在执行，****从而实现并发执行的效果。</strong></p><p>所以，多进程/多线程解决了阻塞问题，即使其中一个阻塞，但也无需等待，CPU 始终是在执行中的。</p><p>但也同时存在新的问题：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304143952.png"></p><p>如图，CPU 从一个进程，切换到另一个进程，是<strong>存在切换成本</strong>的，如果当前线程还未执行结束，那么在切换下一个线程的时候，CPU 是要去计算和保存当前进程的状态，中间会存在很多的系统调用，上下文切换等操作，这一定会浪费一部分时间的。CPU 不是在计算我们的业务，而是在计算切换的中间状态。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304144041.png"></p><p><strong>所以，这种弊端，就会导致 进程/线程的数量越多，切换成本就越大，也就越浪费。</strong></p><p>故而 CPU 看着是百分之百的利用率，而实际情况是只有60%的利用率在执行程序，而40%的利用率在执行切换状态的计算。</p><p>并且随着开发设计变得越来越复杂，因为多线程或者多进程存在 同步竞争，比如锁，竞争资源冲突等，随着任务的增多，CPU 的切换频率也相对增加，就会造成高消耗调度 CPU。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304144242.png"></p><p>一个进程占用内存为 4GB 左右，一个线程占用 4MB 大小的内存，故而进程线程越多，还会造成高内存的占用。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304144312.png"></p><h2 id="1-3-线程的实现模型"><a href="#1-3-线程的实现模型" class="headerlink" title="1.3 线程的实现模型"></a>1.3 线程的实现模型</h2><p>Go并发编程模型在底层是由操作系统所提供的线程库支撑的，这里先简要介绍一下线程实现模型的相关概念。</p><p>线程的实现模型主要有3个，分别是：<strong>用户级线程模型</strong>、<strong>内核级线程模型和两级线程模型</strong>。它们之间最大的差异在于用户线程与内核调度实体（KSE）之间的对应关系上。内核调度实体就是可以被操作系统内核调度器调度的对象，也称为内核级线程，是操作系统内核的最小调度单元。</p><h3 id="1-用户级线程模型"><a href="#1-用户级线程模型" class="headerlink" title="1. 用户级线程模型"></a>1. 用户级线程模型</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304155440.png"></p><p><code>用户线程与KSE为多对一（N:1）的映射关系</code>。此模型下的线程由用户级别的线程库全权管理，线程库存储在进程的用户空间之中，这些线程的存在对于内核来说是无法感知的，所以这些线程也不是内核调度器调度的对象。</p><p>一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，内核的所有调度都是基于用户进程的。对于线程的调度则是在用户层面完成的，相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程模型可以做的很轻量级，对系统资源的消耗会小很多，上下文切换所花费的代价也会小得多。许多语言实现的协程库基本上都属于这种方式。但是，此模型下的多线程并不能真正的并发运行。</p><blockquote><p>例如，如果某个线程在I/O操作过程中被阻塞，那么其所属进程内的所有线程都被阻塞，整个进程将被挂起。</p></blockquote><h3 id="2-内核级线程模型"><a href="#2-内核级线程模型" class="headerlink" title="2. 内核级线程模型"></a>2. 内核级线程模型</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304155627.png"></p><p><code>用户线程与KSE为一对一（1:1)的映射关系</code>。此模型下的线程由内核负责管理，应用程序对线程的创建、终止和同步都必须通过内核提供的系统调用来完成，内核可以分别对每一个线程进行调度。</p><p>所以，一对一线程模型可以真正的实现线程的并发运行，大部分语言实现的线程库基本上都属于这种方式。但是，此模型下线程的创建、切换和同步都需要花费更多的内核资源和时间，如果一个进程包含了大量的线程，那么它会给内核的调度器造成非常大的负担，甚至会影响到操作系统的整体性能。</p><h3 id="3-两级线程模型"><a href="#3-两级线程模型" class="headerlink" title="3. 两级线程模型"></a>3. 两级线程模型</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304155723.png"></p><p>用户线程与KSE为多对多（N:M）的映射关系。两级线程模型吸收前两种线程模型的优点并且尽量规避了它们的缺点，区别于用户级线程模型，两级线程模型中的进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。</p><p>所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是一种自身调度与系统调度协同工作的中间态，<strong>即用户调度器实现用户线程到KSE的调度，内核调度器实现KSE到CPU上的调度</strong>。</p><h2 id="1-4-并发和并行"><a href="#1-4-并发和并行" class="headerlink" title="1.4 并发和并行"></a>1.4 并发和并行</h2><p>并发：同一时间段内执行多个任务，一个cpu上能同时执行多项任务，在很短时间内，cpu来回切换任务执行(在某段很短时间内执行程序a，然后又迅速得切换到程序b去执行)，有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是并发。</p><p>并行：同一时刻执行多个任务，当系统有多个CPU时，每个CPU同一时刻都运行任务，互不抢占自己所在的CPU资源，同时进行，称为并行。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="1-5-协程"><a href="#1-5-协程" class="headerlink" title="1.5 协程"></a>1.5 协程</h2><p>协程， 我们又称为微线程，协程它不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由开发人员决定的。</p><p>协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：</p><p>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。同时协程也称为微线程，它的开销比线程更小，因此更适合用来做高并发的任务。</p><p><strong>协程相对于多线程的优点：</strong></p><p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断。</p><p>而协程默认会做好全方位保护， 以防止中断。我们必须显示产出才能让程序的余下部分运行。对协程来说， 无需保留锁， 而在多个线程之间同步操作， 协程自身就会同步， 因为在任意时刻， 只有一个协程运行。</p><p>总结下大概下面几点：</p><ul><li>无需系统内核的上下文切换，减小开销，节省CPU，避免系统内核级的线程频繁切换，造成的CPU资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。</li><li>无需原子操作锁定及同步的开销，不用担心资源共享的问题；</li><li>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中</li><li>节约内存，在64位的Linux中，一个线程需要分配8MB栈内存和64MB堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。</li></ul><h2 id="1-6-为什么需要协程？"><a href="#1-6-为什么需要协程？" class="headerlink" title="1.6 为什么需要协程？"></a>1.6 为什么需要协程？</h2><p><strong>Goroutines相对于线程的优势：</strong></p><h3 id="1-动态栈"><a href="#1-动态栈" class="headerlink" title="1. 动态栈"></a>1. 动态栈</h3><ul><li>修改固定的大小可以提升空间的利用率，允许创建更多的线程。</li></ul><blockquote><p>一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。2MB的栈对于一个小小的goroutine来说是很大的内存浪费，对于很大的goroutine来说又不够。</p></blockquote><ul><li>许更深的递归调用。</li></ul><blockquote><p>固定大小的栈对于更复杂或者更深层次的[递归函数]调用来说显然是不够的。</p></blockquote><ul><li>具体实现</li></ul><blockquote><p>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。最大为1GB</p></blockquote><h3 id="2-调度的性能更好"><a href="#2-调度的性能更好" class="headerlink" title="2. 调度的性能更好"></a>2. 调度的性能更好</h3><ul><li>切换开销更小<br>使用操作系统的 threads 的最大能力一般在万级别，而Goroutine却能有上百万个。很大原因是在上下文切换的延迟不同。<blockquote><ul><li><p>线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，就会被其它可执行的线程抢占。在线程切换的过程中需要保存/恢复所有的寄存器信息。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。</p></li><li><p>而goroutine的调度是协同式的，它不会直接地与操作系统内核打交道。多个 goroutine 在发生切换的时候，由于是在同一个 thread 下面，切换的时候只会保存/恢复三个寄存器当中的内容：Program Counter, Stack Pointer and DX。并且同一时刻同一个 thread 只会执行一个 goroutine，未被执行但是已经准备好的 goroutine 都是放在一个 queue 中的，他们是被串行处理的。</p></li><li><p>所以，即使一个程序创建了成千上万的 goroutine 也不会对上下文的切换造成什么影响。最重要的是，golang scheduler 在切换不同 goroutine 的操作上基本上达到了 O(1) 的时间复杂度。这就使得上下文切换的时间已经和 goroutine 的规模完全不相关了。</p></li></ul></blockquote></li></ul><p><strong>Go 的行为有何不同：在一个操作系统线程上运行多个 Goroutines。</strong></p><ul><li>更好的支持高并发</li></ul><blockquote><ol><li><p>支持真正的高并发需要另外一种优化思路：<br>当你知道这个线程能做有用的工作的时候，才去调度这个线程！如果你正在运行多线程，其实无论何时，只有少部分的线程在做有用的工作。最好的并发不是利用共享内存来通信，而是用通信来共享内存。</p></li><li><p>Go 语言引入了 channel 的机制来协助这种调度机制。如果一个 goroutine 正在一个空的 channel 上等待，那么调度器就能看到这些，并不再运行这个 goroutine 。同时 Go 语言更进了一步。它把很多个大部分时间空闲的 goroutines 合并到了一个自己的操作系统线程上。这样可以通过一个线程来调度活动的 Goroutine（这个数量小得多），而是数百万大部分状态处于睡眠的 goroutines 被分离出来。这种机制也有助于降低延迟。</p></li></ol></blockquote><h3 id="3-Goroutine没有显示暴露ID号"><a href="#3-Goroutine没有显示暴露ID号" class="headerlink" title="3. Goroutine没有显示暴露ID号"></a>3. Goroutine没有显示暴露ID号</h3><p>在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)。<br>goroutine不可以被程序员很容易获取到身份(id)。这一点是设计上故意而为之，在一定程度上防止thread-local storage被滥用。</p><h1 id="2-Goroutine"><a href="#2-Goroutine" class="headerlink" title="2. Goroutine"></a>2. Goroutine</h1><p>在Go的并发编程模型中，不受操作系统内核管理的独立控制流不叫用户线程或线程，而称为Goroutine。Goroutine通常被认为是协程的Go实现，实际上Goroutine并不是传统意义上的协程，传统的协程库属于用户级线程模型，而Goroutine结合Go调度器的底层实现上属于两级线程模型。</p><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><ol><li><p>Go语言的并发是基于 goroutine 的，中文称协程，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。</p></li><li><p>Go语言运行时会调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。</p></li><li><p>多个 goroutine 中，Go语言使用通道（channel）进行通信，通道是一种内置的数据结构，可以让用户在不同的 goroutine 之间同步发送具有类型的消息。这让编程模型更倾向于在 goroutine 之间发送消息，而不是让多个 goroutine 争夺同一个数据的使用权。</p></li><li><p>如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go语言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。</p></li></ol><p>我们先来介绍如何使用goroutine再来介绍它的调度模型。</p><h2 id="2-2-使用goroutine"><a href="#2-2-使用goroutine" class="headerlink" title="2.2 使用goroutine"></a>2.2 使用goroutine</h2><ul><li>任何函数只需要加上 <strong>go</strong> 就能送给调度器运行</li><li>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</li><li>不需要再定义时区分是否是异步函数</li><li>调度器会在合适点切换</li><li>使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。如果需要在 goroutine 中返回数据，请使用后面介绍的通道（channel）特性，通过通道把数据从 goroutine 中作为返回值传出。</li><li>所有 goroutine 在 main() 函数结束时会一同结束。</li></ul><h3 id="1-启动单个goroutine"><a href="#1-启动单个goroutine" class="headerlink" title="1. 启动单个goroutine"></a>1. 启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p><h3 id="2-启动多个goroutine"><a href="#2-启动多个goroutine" class="headerlink" title="2. 启动多个goroutine"></a>2. 启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子：</p><blockquote><p>这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h3 id="3-GOMAXPROCS"><a href="#3-GOMAXPROCS" class="headerlink" title="3. GOMAXPROCS"></a>3. GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;A：&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;B：&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">6</span>) <span class="comment">// 占用 6 个 CPU 核心</span></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Goroutine的调度模型（GMP模型）"><a href="#2-3-Goroutine的调度模型（GMP模型）" class="headerlink" title="2.3 Goroutine的调度模型（GMP模型）"></a>2.3 Goroutine的调度模型（GMP模型）</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304161755.png"></p><p>groutine能拥有强大的并发实现是通过GMP调度模型实现，下面就来解释下goroutine的调度模型。</p><p>Go的调度器内部三个重要的结构：M，P，G</p><ul><li><p><code>G</code>表示Goroutine。每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。当Goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在G对象的成员变量之中，当Goroutine被调度起来运行时，调度器代码又负责把G对象的成员变量所保存的寄存器的值恢复到CPU的寄存器。</p></li><li><p><code>M</code>代表内核级线程，goroutine就是跑在M之上的；OS底层线程的抽象，它本身就与一个内核线程进行绑定，每个工作线程都有唯一的一个M结构体的实例对象与之对应，它代表着真正执行计算的资源，由操作系统的调度器调度和管理。M结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的Goroutine以及是否空闲等等状态信息之外，还通过指针维持着与P结构体的实例对象之间的绑定关系。</p></li></ul><ul><li><code>P</code>全称是Processor，表示逻辑处理器，默认与机器的核心数相同，它的主要用途就是用来执行goroutine的。对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。它维护一个局部Goroutine可运行G队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这可以大大减少锁冲突，提高工作线程的并发性，并且可以良好的运用程序的局部性原理。</li></ul><p>一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文）。每个P都包含一个可运行的G的队列（runq）。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。</p><p>M与KSE之间总是一一对应的关系，一个M仅能代表一个内核线程。M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联，而M与P、P与G之间的关联都是可变的，M与P也是一对一的关系，P与G则是一对多的关系。</p><blockquote><p>本地队列与全局队列：</p><ul><li>相同点：都是用来存储待运行的goroutine；</li><li>不同点：本地队列有大小限制，最多能存放256个，并且在创建goroutine时回会优先存储在P的本地队列，如果P的本地队列满了，则拿一半放到全局队列中。</li></ul></blockquote><h3 id="2-G"><a href="#2-G" class="headerlink" title="2. G"></a>2. G</h3><p>运行时，G在调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。它是Go语言在用户态提供的线程，作为一种粒度更细的资源调度单元，使用得当，能够在高并发的场景下更高效地利用机器的CPU。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304162333.png"></p><p><strong>g结构体部分源码（src/runtime/runtime2.go</strong>）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack      stack    <span class="comment">// Goroutine的栈内存范围[stack.lo, stack.hi)</span></span><br><span class="line">    stackguard0    <span class="keyword">uintptr</span>  <span class="comment">// 用于调度器抢占式调度</span></span><br><span class="line">    m        *m    <span class="comment">// Goroutine占用的线程</span></span><br><span class="line">    sched      gobuf    <span class="comment">// Goroutine的调度相关数据</span></span><br><span class="line">    atomicstatus  <span class="keyword">uint32</span>  <span class="comment">// Goroutine的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="keyword">uintptr</span>    <span class="comment">// 栈指针</span></span><br><span class="line">    pc   <span class="keyword">uintptr</span>    <span class="comment">// 程序计数器</span></span><br><span class="line">    g   guintptr    <span class="comment">// gobuf对应的Goroutine</span></span><br><span class="line">    ret   sys.Uintewg  <span class="comment">// 系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gobuf中保存的内容会在调度器保存或恢复上下文时使用，其中栈指针和程序计数器会用来存储或恢复寄存器中的值，改变程序即将执行的代码。</p><p>atomicstatus字段存储了当前Goroutine的状态，Goroutine主要可能处于以下几种状态：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304162453.png"></p><p>Goroutine的状态迁移是一个十分复杂的过程，触发状态迁移的方法也很多。这里主要介绍一下比较常见的<strong>五种状态_Grunnable、_Grunning、_Gsyscall、_Gwaiting和_Gpreempted</strong>。</p><p>可以将这些不同的状态聚合成三种：等待中、可运行、运行中，运行期间会在这三种状态来回切换：</p><ul><li><p><strong>等待中</strong>：Goroutine正在等待某些条件满足，例如：系统调用结束等，包括_Gwaiting、_Gsyscall和_Gpreempted几个状态；</p></li><li><p><strong>可运行</strong>：Goroutine已经准备就绪，可以在线程运行，如果当前程序中有非常多的Goroutine，每个Goroutine就可能会等待更多的时间，即_Grunnable；</p></li><li><p><strong>运行中</strong>：Goroutine正在某个线程上运行，即_Grunning。</p></li></ul><p>G常见的状态转换图：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304162519.png"></p><p>进入死亡状态的G可以重新初始化并使用。</p><h3 id="3-M"><a href="#3-M" class="headerlink" title="3. M"></a>3. M</h3><p>Go语言并发模型中的M是操作系统线程。调度器最多可以创建10000个线程，但是最多只会有GOMAXPROCS（P的数量）个活跃线程能够正常运行。在默认情况下，运行时会将 GOMAXPROCS设置成当前机器的核数，我们也可以在程序中使用runtime.GOMAXPROCS来改变最大的活跃线程数。</p><p>例如，对于一个四核的机器，runtime会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的runtime.m结构体。在大多数情况下，我们都会使用Go的默认设置，也就是线程数等于CPU数，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由Go语言调度器触发，能够减少很多额外开销。</p><p><strong>m结构体源码（部分）</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g      <span class="comment">// 一个特殊的goroutine，执行一些运行时任务</span></span><br><span class="line">    gsignal    *g      <span class="comment">// 处理signal的G</span></span><br><span class="line">    curg    *g      <span class="comment">// 当前M正在运行的G的指针</span></span><br><span class="line">    p      puintptr  <span class="comment">// 正在与当前M关联的P</span></span><br><span class="line">    nextp    puintptr  <span class="comment">// 与当前M潜在关联的P</span></span><br><span class="line">    oldp    puintptr  <span class="comment">// 执行系统调用之前使用线程的P</span></span><br><span class="line">    spinning  <span class="keyword">bool</span>    <span class="comment">// 当前M是否正在寻找可运行的G</span></span><br><span class="line">    lockedg    *g      <span class="comment">// 与当前M锁定的G</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g0表示一个特殊的Goroutine，由Go运行时系统在启动之处创建，它会深度参与运行时的调度过程，包括Goroutine的创建、大内存分配和CGO函数的执行。curg是在当前线程上运行的用户Goroutine。</p><h3 id="4-P"><a href="#4-P" class="headerlink" title="4. P"></a>4. P</h3><p>调度器中的处理器P是线程和Goroutine的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器P的调度，每一个内核线程都能够执行多个Goroutine，它能在Goroutine进行一些I/O操作时及时让出计算资源，提高线程的利用率。</p><p>P的数量等于GOMAXPROCS，设置GOMAXPROCS的值只能限制P的最大数量，对M和G的数量没有任何约束。当M上运行的G进入系统调用导致M被阻塞时，运行时系统会把该M和与之关联的P分离开来，这时，如果该P的可运行G队列上还有未被运行的G，那么运行时系统就会找一个空闲的M，或者新建一个M与该P关联，满足这些G的运行需要。因此，M的数量很多时候都会比P多。</p><p><strong>p结构体源码（部分）</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// p 的状态</span></span><br><span class="line">  status   <span class="keyword">uint32</span>  </span><br><span class="line">  <span class="comment">// 对应关联的 M</span></span><br><span class="line">  m        muintptr    </span><br><span class="line">  <span class="comment">// 可运行的Goroutine队列，可无锁访问</span></span><br><span class="line">  runqhead <span class="keyword">uint32</span></span><br><span class="line">  runqtail <span class="keyword">uint32</span></span><br><span class="line">  runq     [<span class="number">256</span>]guintptr</span><br><span class="line">  <span class="comment">// 缓存可立即执行的G</span></span><br><span class="line">  runnext    guintptr </span><br><span class="line">  <span class="comment">// 可用的G列表，G状态等于Gdead </span></span><br><span class="line">  gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">    gList</span><br><span class="line">    n <span class="keyword">int32</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P可能处于的状态如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304162845.png"></p><h2 id="2-4-Goroutine的调度过程"><a href="#2-4-Goroutine的调度过程" class="headerlink" title="2.4 Goroutine的调度过程"></a>2.4 Goroutine的调度过程</h2><p>首先介绍一下在GMP调度模型中，如果没有P的话会怎么样？</p><h3 id="1-没有P层会发生什么？"><a href="#1-没有P层会发生什么？" class="headerlink" title="1. 没有P层会发生什么？"></a>1. 没有P层会发生什么？</h3><p>如果没有P层，调度器的实现流程如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304165525.png"></p><p>M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。</p><p><strong>缺点：</strong></p><ol><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li><li>M 转移 G 会造成<strong>延迟和额外的系统负载</strong>。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了<strong>很差的局部性</strong>，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。</li><li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><h3 id="2-调度过程"><a href="#2-调度过程" class="headerlink" title="2. 调度过程"></a>2. 调度过程</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304165825.png"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><strong>Goroutine的创建</strong>：<br>在调用go func()的时候，会调用runtime.newproc来创建一个goroutine，这个goroutine会新建一个自己的栈空间，同时在G的sched中维护栈地址与程序计数器这些信息（<strong>备注</strong>：这些数据在goroutine被调度的时候会被用到。准确的说该goroutine在放弃cpu之后，下一次在重新获取cpu的时候，这些信息会被重新加载到cpu的寄存器中。） 创建好的这个goroutine会被放到，它所对应的内核线程M所使用的上下文P中的runqueue中。等待调度器来决定何时取出该goroutine并执行，通常调度是按时间顺序被调度的，这个队列是一个先进先出的队列。</li><li><strong>P的创建</strong> ：<br>runqueue P 指定GOMAXPROCS之后，会在程序运行之初创建好对应数目的P</li></ul><ul><li><strong>M的创建</strong> ：<br>当满足以下三个条件以后，M就会被创建：<ul><li>队列中G太多</li><li>系统级线程M太少</li><li>有空闲的P</li></ul></li></ul><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>goroutine在创建好了之后，调度器会决定何时执行这个goroutine，这个过程就叫做调度。</p><p>新建好的goroutine，最开始都会存储在某一个线程M，所关联的上下文P的runqueue中，但是在后续的调度中，有些goroutine因为调用了<strong>runtime.gosched，</strong>会被放到全局队列中。</p><p><strong>线程M的选择过程，按照下面的顺序执行：</strong></p><blockquote><ol><li><p>从M对应的P中的runqueue中取出goroutine，来执行，没有的话，执行2。</p></li><li><p>从全局队列里面尝试取出一个goroutine来执行，有的话，执行！没有的话，执行3。</p></li><li><p>从其他的线程M的P中，偷出一些goroutine来执行，偷失败了，执行4。（<strong>备注</strong>：这里偷的话，一偷就偷一半，使用的算法叫做work stealing。）</p></li><li><p>线程M发现无事可做，就去休息了，也就是线程的sleep，放入线程缓存，它等待被唤醒。</p></li><li><p>当一个OS线程也就是一个M陷入阻塞的时候，会释放出P，P转而寻找另一个M（M可能是被新创建，也可能来自于线程缓存），继续执行其他G</p></li><li><p>如果没有其他的空闲 M，但是P的Local Runqueue（本地队列）中仍有G需要执行，就会创建一个新的M。</p></li></ol></blockquote><p>当上述阻塞完成后，G会尝试寻找一个空闲的P进入它的Local Runqueue中恢复执行，如果没有找到，G就会进入Global Runqueue，等待其他P从队列中取出。</p><blockquote><p>P调度G的时候，首先从P的Local Runqueue中获取G，如果Local Queue中没有的话，就从Global Runqueue中获取，如果Global Runqueue中也没有的话，就随机从其他P的Local Runqueue中偷一半的G出来。</p></blockquote><h3 id="3-调度器原理"><a href="#3-调度器原理" class="headerlink" title="3. 调度器原理"></a>3. 调度器原理</h3><ul><li><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。<ol><li><code>work stealing 机制</code><br>当本线程无可运行的 G 时，则P随机选择一个的其他处理器（P）并尝试从其队列中窃取一半可运行的goroutine。，而不是销毁线程。</li><li><code>hand off 机制</code><br>当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</li></ol></li><li><strong>利用并行：</strong> GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。</li><li><strong>抢占：</strong> 在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。</li><li><strong>旋转线程：</strong> 线程自旋相对于线程阻塞，表现为循环执行指定的逻辑，而不进入阻塞状态。在go的调度逻辑中，为了实现高性能的并发，如果全局队列和本地队列都为空，绑定P的M没有G可以执行，会进入自旋状态等待新的G，不会进入阻塞状态休眠，减少了经常性的抢占和M的上下文切换成本。 在任何时候，都有最多 GOMAXPROCS 个线程在旋转。当一个旋转的线程找到工作后，它就会脱离自旋状态。</li><li><strong>全局 G 队列</strong>：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。</li></ul><h3 id="4-用户态阻塞和系统调用阻塞"><a href="#4-用户态阻塞和系统调用阻塞" class="headerlink" title="4.  用户态阻塞和系统调用阻塞"></a>4. 用户态阻塞和系统调用阻塞</h3><h4 id="用户态阻塞"><a href="#用户态阻塞" class="headerlink" title="用户态阻塞"></a>用户态阻塞</h4><p>当goroutine因为channel操作或者network I/O而阻塞时（实际上golang已经用netpoller实现了goroutine网络I/O阻塞不会导致M被阻塞，仅阻塞G，这里仅仅是举个例子），对应的G会被放置到某个wait队列(<code>如channel的waitq</code>)，该G的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而M会跳过该G尝试获取并执行下一个G，如果此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态；当阻塞的G被另一端的G2唤醒时（比如channel的可读/写通知），G被标记为<code>runnable</code>，尝试加入G2所在P的runnext，然后再是P的Local队列和Global队列。</p><h4 id="系统调用阻塞"><a href="#系统调用阻塞" class="headerlink" title="系统调用阻塞"></a>系统调用阻塞</h4><ol><li>当G被阻塞在某个系统调用上时，此时G会阻塞在<code>_Gsyscall</code>状态，M也处于 <code>block on syscall</code>状态，</li></ol><ol start="2"><li>此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它空闲的M绑定，继续执行其它G。</li></ol><ol start="3"><li>如果没有其它空闲的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；当系统调用完成后，G会重新尝试获取一个空闲的P进入它的Local队列恢复执行，如果没有空闲的P，G会被标记为runnable加入到Global队列。</li></ol><h3 id="5-线程自旋"><a href="#5-线程自旋" class="headerlink" title="5. 线程自旋"></a>5. 线程自旋</h3><p>线程自旋相对于线程阻塞，表现为循环执行指定的逻辑，而不进入阻塞状态。在go的调度逻辑中，为了实现高性能的并发，如果全局队列和本地队列都为空，绑定P的M没有G可以执行，会进入自旋状态等待新的G，不会进入阻塞状态休眠，减少了M的上下文切换成本。</p><p>注意只有绑定了P的M会进入自旋状态，因此最多会有GOMAXPROCS个自旋线程，避免了浪费过多系统资源，其余未绑定的空闲M依然会进入休眠状态。</p><h3 id="6-抢占式调度逻辑："><a href="#6-抢占式调度逻辑：" class="headerlink" title="6. 抢占式调度逻辑："></a>6. 抢占式调度逻辑：</h3><p>M绑定的P首先有1/61概率从全局队列获取G，60/61概率从本地队列获取G；</p><p>全局队列情况下如果没有获取到G，那么从本地队列获取G；</p><p>如果本地队列没有G，那么P从其他P的本地队列窃取G；</p><p>如果窃取不到G，那么从全局队列中获取一部分G到本地队列，获取n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))个；</p><p>P获取到G后，绑定的M负责执行G，M必须是运行状态的线程，否则不会真正执行。</p><h2 id="2-5-Goroutine如何停止"><a href="#2-5-Goroutine如何停止" class="headerlink" title="2.5 Goroutine如何停止"></a>2.5 Goroutine如何停止</h2><p>讲完了goroutine的调度之后，我们便要考虑一个问题，正在被执行的goroutine何时停止，停止了之后会发生什么？而挂在M对应的P后面的runqueue中的goroutine该怎么办？</p><h3 id="1-情况1-runtime·park"><a href="#1-情况1-runtime·park" class="headerlink" title="1. 情况1: runtime·park"></a>1. 情况1: runtime·park</h3><p>当调用了runtime·park函数之后，goroutine会被设置成waiting状态，线程M会放弃它自身关联的上下文P，而系统会分配一个新的线程M1来接管这个上下文P，（<strong>备注</strong>：当然这里面的M1也有可能是本来就创建好的，处于闲置状态中的）。</p><p>原来的线程M0则会与上下文断开连接，M0因为无事可做，就去sleep了，等待下次被唤醒。如下图所示：</p><p>channel的读写操作，定时器中，网络poll等都有可能park goroutine。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304172524.png"></p><h3 id="2-情况2-runtime·gosched"><a href="#2-情况2-runtime·gosched" class="headerlink" title="2. 情况2: runtime·gosched"></a>2. 情况2: runtime·gosched</h3><p>调用runtime·gosched函数也可以让当前goroutine放弃cpu，这种情况下会将goroutine设置称runnable，放置到全局队列中。</p><blockquote><p>备注：这个也就是为什么全局变量的queue里面会有goroutine的原因。</p></blockquote><h1 id="3-Goroutine-的其他操作"><a href="#3-Goroutine-的其他操作" class="headerlink" title="3. Goroutine 的其他操作"></a>3. Goroutine 的其他操作</h1><h2 id="3-1-Goroutine异常捕捉"><a href="#3-1-Goroutine异常捕捉" class="headerlink" title="3.1 Goroutine异常捕捉"></a>3.1 Goroutine异常捕捉</h2><p>当启动多个goroutine时，如果其中一个goroutine异常了，并且我们并没有对进行异常处理，那么整个程序都会终止，所以我们在编写程序时候最好每个goroutine所运行的函数都做异常处理，异常处理采用recover。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addele</span><span class="params">(a []<span class="keyword">int</span> ,i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="comment">//匿名函数捕获错误</span></span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;add ele fail&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">   a[i]=i</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Arry := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> addele(Arry,i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Goroutine-中的-panic"><a href="#3-2-Goroutine-中的-panic" class="headerlink" title="3.2 Goroutine 中的 panic"></a>3.2 Goroutine 中的 panic</h2><p>一般来说，Go 应用程序中的 panic 是违反最佳实践的，应该避免。代替 panic，你应该返回并处理函数中的错误。但是，如果有必要使用  <code>panic</code>，必须知道，在 goroutine 如果没有 defer 的 recover，panic 会导致整个应用程序崩溃。</p><blockquote><p><strong>最佳实践：</strong>不要 Panic！</p></blockquote><h1 id="4-Channel"><a href="#4-Channel" class="headerlink" title="4. Channel"></a>4. Channel</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>Go中经常被人提及的一个设计模式：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。Goroutine之间会通过 channel传递数据，作为Go语言的核心数据结构和Goroutine之间的通信方式，channel是支撑Go语言高性能并发编程模型的重要结构。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304174503.png"></p><p>channel在运行时的内部表示是runtime.hchan，该结构体中包含了用于保护成员变量的互斥锁，从某种程度上说，channel是一个用于同步和通信的有锁队列。hchan结构体源码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount    <span class="keyword">uint</span>        <span class="comment">// 循环列表元素个数</span></span><br><span class="line">    dataqsiz  <span class="keyword">uint</span>        <span class="comment">// 循环队列的大小</span></span><br><span class="line">    buf      unsafe.Pointer  <span class="comment">// 循环队列的指针</span></span><br><span class="line">    elemsize  <span class="keyword">uint16</span>      <span class="comment">// chan中元素的大小</span></span><br><span class="line">    closed    <span class="keyword">uint32</span>      <span class="comment">// 是否已close</span></span><br><span class="line">    elemtype  *_type      <span class="comment">// chan中元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>        <span class="comment">// chan的发送操作处理到的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>        <span class="comment">// chan的接收操作处理到的位置</span></span><br><span class="line">    recvq    waitq        <span class="comment">// 等待接收数据的Goroutine列表</span></span><br><span class="line">    sendq    waitq        <span class="comment">// 等待发送数据的Goroutine列表</span></span><br><span class="line">    </span><br><span class="line">    lock    mutex        <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;        <span class="comment">// 双向链表</span></span><br><span class="line">    first  *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitq</code>中连接的是一个<code>sudog</code>双向链表，保存的是等待中的Goroutine。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220304174601.png"></p><ol><li><p>channel 是Go语言在语言级别提供的 goroutine 间的通信方式。我们可以使用 channel 在多个 goroutine 之间传递消息。</p></li><li><p>channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go语言对于网络方面也有非常完善的支持。</p></li><li><p>channel 是类型相关的，也就是说，一个 channel 只能传递一种类型的值，这个类型需要在声明 channel 时指定。如果对 Unix 管道有所了解的话，就不难理解 channel，可以将其认为是一种类型安全的管道。</p></li><li><p>Go语言提倡使用通信的方法代替共享内存。多个 goroutine 为了争抢数据，势必造成执行的低效率，使用队列的方式是最高效的，channel 就是一种队列一样的结构。</p></li><li><p>在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。</p></li><li><p>通道的内部实现代码在Go语言开发包的 src/runtime/chan.go 中，经过分析后大概了解到通道也是用常见的互斥量等进行同步。因此通道虽然是一个语言级特性，但也不是被神化的特性，通道的运行和使用都要比传统互斥量、等待组（sync.WaitGroup）有一定的消耗。</p></li></ol><h2 id="4-2-Channel的使用"><a href="#4-2-Channel的使用" class="headerlink" title="4.2 Channel的使用"></a>4.2 Channel的使用</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h3><ul><li><p>带缓冲区channel：定义声明时候制定了缓冲区大小(长度)，可以保存多个数据。用于通信</p></li><li><p>channel :=make(chan int,3)</p></li><li><p>不带缓冲区channel：只能只能存一个数据，用于两个groutine的同步，阻塞式</p></li><li><p>channel :=make(chan bool)</p></li><li><p>只读管道 read_only := make (&lt;-chan int)</p></li><li><p>只写管道 rite_only := make (chan&lt;- int)</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义</span></span><br><span class="line">	channel :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	<span class="comment">//存数据</span></span><br><span class="line">	channel &lt;- <span class="number">1</span></span><br><span class="line">	channel &lt;- <span class="number">2</span></span><br><span class="line">	channel &lt;- <span class="number">3</span></span><br><span class="line">	<span class="comment">//channel &lt;- 4,报错，容量已经满了</span></span><br><span class="line">	<span class="comment">//取数据，如果只想删掉该值，直接&lt;- channel</span></span><br><span class="line">	num :=&lt;- channel</span><br><span class="line">	fmt.Println(num)<span class="comment">//1</span></span><br><span class="line">	channel &lt;- <span class="number">4</span></span><br><span class="line">	num2,ok:=&lt;- channel</span><br><span class="line">    <span class="keyword">if</span> ok&#123;</span><br><span class="line">    	fmt.Println(num2)<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-发送"><a href="#2-发送" class="headerlink" title="2. 发送"></a>2. 发送</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通道变量 &lt;- 值</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">ch &lt;- <span class="number">0</span> <span class="comment">// 将0放入通道中</span></span><br><span class="line">ch &lt;- <span class="string">&quot;hello&quot;</span><span class="comment">// 将hello字符串放入通道中</span></span><br></pre></td></tr></table></figure><p>把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时会发现一些永远无法发送成功的语句并抛出 <code>panic：fatal error: all goroutines are asleep - deadlock!</code></p><h3 id="3-接收"><a href="#3-接收" class="headerlink" title="3. 接收"></a>3. 接收</h3><ol><li><p>通道的收发操作在不同的两个 goroutine 间进行。</p></li><li><p>接收将持续阻塞直到收到发送方发送的数据。</p></li><li><p>通道一次只能接收一个数据元素。</p></li><li><p>通道的数据接收一共有以下 4 种写法：</p></li></ol><h4 id="阻塞接收数据"><a href="#阻塞接收数据" class="headerlink" title="阻塞接收数据"></a>阻塞接收数据</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := &lt;-ch</span><br></pre></td></tr></table></figure><h4 id="非阻塞接收数据"><a href="#非阻塞接收数据" class="headerlink" title="非阻塞接收数据"></a>非阻塞接收数据</h4><p>非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行，可以参见后面的内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。</span></span><br><span class="line"><span class="comment">// ok：表示是否接收到数据。</span></span><br><span class="line">data, ok := &lt;-ch</span><br></pre></td></tr></table></figure><h4 id="接收任意数据，忽略接收的数据"><a href="#接收任意数据，忽略接收的数据" class="headerlink" title="接收任意数据，忽略接收的数据"></a>接收任意数据，忽略接收的数据</h4><p>执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure><p>并发同步：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;go goroutine&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;wait goroutine&quot;</span>)</span><br><span class="line">    <span class="comment">// 等待匿名goroutine</span></span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历式接收"><a href="#遍历式接收" class="headerlink" title="遍历式接收"></a>遍历式接收</h4><ul><li>使用 for range 遍历，同go程中编译器发现channel未被关闭，则会引发deadlock错误</li><li>如果channel无数据可读，那么for range会处于等待状态，只有当channel关闭，for range循环才会退出</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义</span></span><br><span class="line">	channel :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">	<span class="comment">//存数据</span></span><br><span class="line">	channel &lt;- <span class="number">1</span></span><br><span class="line">	channel &lt;- <span class="number">2</span></span><br><span class="line">	channel &lt;- <span class="number">3</span></span><br><span class="line">	<span class="built_in">close</span>(channel)</span><br><span class="line">	<span class="keyword">for</span> k :=<span class="keyword">range</span> channel&#123;</span><br><span class="line">		fmt.Println(k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果采用for循环已经被关闭的管道，当管道没有数据时，读取的数据是管道的默认值，并且循环不会退出。res,ok :=&lt;- channel,其中ok为false</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	channel :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">	channel &lt;- <span class="number">1</span></span><br><span class="line">	channel &lt;- <span class="number">2</span></span><br><span class="line">	channel &lt;- <span class="number">3</span></span><br><span class="line">	<span class="built_in">close</span>(channel)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		res,ok :=&lt;-channel</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(res)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;channel无数据，取到的只为%v\n&quot;</span>,res)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3 注意事项"></a>4.3 注意事项</h2><ul><li><p>管道只能存放指定类型数据</p></li><li><p>非缓冲通道上如果发生了流入无流出，或者流出无流入，就会引起死锁。</p></li><li><p>当一个协程存一个协程取，虽然存的快而取得慢，导致容量占满，也不会发生错误，而是负责存的协程会堵塞在channel &lt;- num</p></li><li><p>当一个协程存一个协程取，虽然存的慢而取得快，导致channel为空，也不会发生错误，而是负责取的协程会堵塞在   num  ：= &lt;- channel</p></li><li><p>存满了的channel就不能继续存了，当从存满了的channel取出数据后还可以继续存</p></li><li><p>当要取某一个值时，要将它前面的值剔除</p></li></ul><h2 id="4-4-关闭"><a href="#4-4-关闭" class="headerlink" title="4.4 关闭"></a>4.4 关闭</h2><h3 id="1-普通使用"><a href="#1-普通使用" class="headerlink" title="1. 普通使用"></a>1. 普通使用</h3><p>通道是一个引用对象，在没有任何外部引用时，Go语言程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection, GC）。当然，通道也可以被主动关闭。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><h3 id="2-判断关闭"><a href="#2-判断关闭" class="headerlink" title="2. 判断关闭"></a>2. 判断关闭</h3><p>如何判断一个 channel 是否已经被关闭？我们可以在读取的时候使用非阻塞式方式来判断。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">data,ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;close ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-给被关闭通道发送数据将会触发-panic"><a href="#3-给被关闭通道发送数据将会触发-panic" class="headerlink" title="3. 给被关闭通道发送数据将会触发 panic"></a>3. 给被关闭通道发送数据将会触发 panic</h3><p>被关闭的通道不会被置为 nil。如果尝试对已经关闭的通道进行发送，将会触发 <code>panic：panic: send on closed channel</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个整型的通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="comment">// 打印通道的指针, 容量和长度</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ptr:%p cap:%d len:%d\n&quot;</span>, ch, <span class="built_in">cap</span>(ch), <span class="built_in">len</span>(ch))</span><br><span class="line">    <span class="comment">// 给关闭的通道发送数据</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-从已关闭的通道接收数据时将不会发生阻塞"><a href="#4-从已关闭的通道接收数据时将不会发生阻塞" class="headerlink" title="4. 从已关闭的通道接收数据时将不会发生阻塞"></a>4. 从已关闭的通道接收数据时将不会发生阻塞</h3><p>从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个整型带两个缓冲的通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 给通道放入两个数据</span></span><br><span class="line">    ch &lt;- <span class="number">0</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 关闭缓冲</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="comment">// 遍历缓冲所有数据, 且多遍历1个</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ch)+<span class="number">1</span>; i++ &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 从通道中取出数据</span></span><br><span class="line">        v, ok := &lt;-ch</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 打印取出数据的状态</span></span><br><span class="line">        fmt.Println(v, ok)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="literal">true</span></span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="4-5-Channel类型"><a href="#4-5-Channel类型" class="headerlink" title="4.5 Channel类型"></a>4.5 Channel类型</h2><h3 id="1-单向Channel"><a href="#1-单向Channel" class="headerlink" title="1. 单向Channel"></a>1. 单向Channel</h3><p>Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 就是只能用于写入或者只能用于读取数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制，没有实际意义。因此，单向通道只是有利于代码接口的严谨性。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 通道实例 chan&lt;- 元素类型    // 只能写入数据的通道</span></span><br><span class="line"><span class="comment">// var 通道实例 &lt;-chan 元素类型    // 只能读取数据的通道</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 声明一个只能写入数据的通道类型, 并赋值为ch</span></span><br><span class="line"><span class="keyword">var</span> chSendOnly <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = ch</span><br><span class="line"><span class="comment">//声明一个只能读取数据的通道类型, 并赋值为ch</span></span><br><span class="line"><span class="keyword">var</span> chRecvOnly &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = ch</span><br></pre></td></tr></table></figure><p>上面的例子中，chSendOnly 只能写入数据，如果尝试读取数据，将会抛出<code>panic：invalid operation: &lt;-chSendOnly (receive from send-only type chan&lt;- int)</code>。同理，chRecvOnly 也是不能写入数据的。</p><p><strong>例子：</strong></p><p>time 包中的计时器会返回一个 timer 实例，代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个 Timer，它会在最少过去时间段 d 后到期，向其自身的 C 字段发送当时的时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">defer</span> t.Stop()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		&lt;-t.C</span><br><span class="line">		fmt.Println(<span class="string">&quot;timer running...&quot;</span>)</span><br><span class="line">		<span class="comment">// 需要重置Reset 使 t 重新开始计时</span></span><br><span class="line">		t.Reset(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-无缓冲-channel"><a href="#2-无缓冲-channel" class="headerlink" title="2. 无缓冲 channel"></a>2. 无缓冲 channel</h3><ol><li>Go语言中无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。</li><li>如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</li></ol><blockquote><ol><li>阻塞指的是由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足才解除阻塞。</li><li>同步指的是在两个或多个协程（线程）之间，保持数据内容一致性的机制。</li></ol></blockquote><h3 id="3-缓冲-channel"><a href="#3-缓冲-channel" class="headerlink" title="3. 缓冲 channel"></a>3. 缓冲 channel</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ol><li><p>Go语言中有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。</p></li><li><p>通道阻塞的条件发送和接收也不同。</p><ul><li>通道为空时，尝试接收数据时发生阻塞。</li><li>通道填满时，尝试发送数据时发生阻塞。</li></ul></li><li><p>有缓冲的通道和无缓冲的通道之间的一个很大的不同：</p><ul><li>无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换</li><li>有缓冲的通道没有这种保证，是一个异步过程。</li></ul></li><li><p>带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。</p></li><li><p>为什么Go语言对通道要限制长度而不提供无限长度的通道？</p><ul><li>我们知道通道（channel）是在两个 goroutine 间通信的桥梁。使用 goroutine 的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。</li></ul></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通道实例 := make(chan 通道类型, 缓冲大小)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个3个元素缓冲大小的整型通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 查看当前通道的大小</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(ch))</span><br><span class="line">    <span class="comment">// 发送3个整型元素到通道</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    <span class="comment">// 查看当前通道的大小</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-Select-多路复用"><a href="#4-6-Select-多路复用" class="headerlink" title="4.6 Select 多路复用"></a>4.6 Select 多路复用</h2><blockquote><ol><li>多路复用是通信和网络中的专业术语。多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术</li><li>go 提供了select 来实现多通道复用，可以同时处理接收和发送多个通道的数据。</li></ol></blockquote><ol><li><p>select 语句实现了一种监听模式，通常用在（无限）循环中。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。在某种情况下，通过 break 或 goto 语句使循环退出。</p></li><li><p>select 的用法与 switch 语言非常类似：</p><ul><li><p>default 语句是可选的；</p></li><li><p>fallthrough 是不允许的；</p></li><li><p>只要其中有一个 case 已经完成，程序就会继续往下执行，而不会考虑其他 case 的情况。</p></li><li><p>在任何一个 case 中执行 break 或者 return，select 就结束了，每一个case默认最后带有break。</p></li></ul></li><li><p>select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作。</p></li><li><p>在一个 select 语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。</p></li><li><p>如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有如下两种可能的情况：</p><ul><li>如果给出 default 语句，就会执行 default 语句，然后程序会跳出 select 语句，执行后面的程序。</li><li>如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。</li></ul></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-chan1: 		  <span class="comment">// 接收任意数据</span></span><br><span class="line">    <span class="keyword">case</span> data := &lt;-chan2: <span class="comment">// 接收data从chan2</span></span><br><span class="line">    <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:	  <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-channel-超时"><a href="#4-7-channel-超时" class="headerlink" title="4.7 channel 超时"></a>4.7 channel 超时</h2><p>Go语言没有提供直接的超时处理机制。我们可以使用 select 来设置超时，虽然 select 机制不是专门为超时而设计的，却能很方便的解决超时问题。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> num := &lt;-ch:</span><br><span class="line">                fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">                fmt.Println(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">                <span class="keyword">goto</span> StopHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        StopHere:</span><br><span class="line">    		fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">        	quit &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-quit</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num =  <span class="number">0</span></span><br><span class="line">num =  <span class="number">1</span></span><br><span class="line">num =  <span class="number">2</span></span><br><span class="line">num =  <span class="number">3</span></span><br><span class="line">num =  <span class="number">4</span></span><br><span class="line">超时</span><br><span class="line">程序结束</span><br></pre></td></tr></table></figure><h1 id="5-Goroutine和Channel案例"><a href="#5-Goroutine和Channel案例" class="headerlink" title="5. Goroutine和Channel案例"></a>5. Goroutine和Channel案例</h1><h2 id="5-1-死锁现场一："><a href="#5-1-死锁现场一：" class="headerlink" title="5.1 死锁现场一："></a>5.1 死锁现场一：</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    &lt;- ch <span class="comment">// 阻塞main goroutine, 通道被锁</span></span><br><span class="line">&#125;</span><br><span class="line">解决：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch&lt;<span class="number">-1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	res :=&lt;- ch</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：groutine一定要在主线程对channel操作前开启，不然主线程阻塞在channel操作造成死锁，如果上面的管道是有缓冲的，则不会堵死。</p></blockquote><h2 id="5-2-死锁现场二："><a href="#5-2-死锁现场二：" class="headerlink" title="5.2 死锁现场二："></a>5.2 死锁现场二：</h2><p>（无缓冲channel的陷阱）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cha, chb := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cha &lt;- <span class="number">1</span> <span class="comment">// cha通道的数据没有被其他goroutine读取走，堵塞当前goroutine</span></span><br><span class="line">		chb &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;- chb <span class="comment">// chb 等待数据的写</span></span><br><span class="line">&#125;</span><br><span class="line">解决：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cha, chb := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cha &lt;- <span class="number">1</span> <span class="comment">// cha通道的数据没有被其他goroutine读取走，堵塞当前goroutine</span></span><br><span class="line">		chb &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">    &lt;- cha <span class="comment">//将cha也读出来。因为都是无缓冲的通道，同时也要注意，要严格按照存的顺序来取</span></span><br><span class="line">	&lt;- chb <span class="comment">// chb 等待数据的写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-生产者与消费者"><a href="#5-3-生产者与消费者" class="headerlink" title="5.3 生产者与消费者"></a>5.3 生产者与消费者</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producter</span><span class="params">(apples <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;生产者：我生产了第&quot;</span>,i,<span class="string">&quot;个苹果&quot;</span>)</span><br><span class="line">		apples &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(apples)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(apples <span class="keyword">chan</span> <span class="keyword">int</span>,flag <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		res ,ok := &lt;- apples</span><br><span class="line">		<span class="keyword">if</span> ok&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;消费者：我吃了第&quot;</span>,res,<span class="string">&quot;个苹果&quot;</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	flag &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="built_in">close</span>(flag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	apples := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">20</span>)</span><br><span class="line">	flag := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> producter(apples)</span><br><span class="line">	<span class="keyword">go</span> consumer(apples,flag)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		_ ,ok := &lt;- flag</span><br><span class="line">		<span class="keyword">if</span> ok&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考感谢<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43626309/article/details/115727444">Goroutines 与线程 ，并发原理，GPM模型，调度过程_菜菜今天学习了吗的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82740001">Go并发(二)：goroutine的实现原理 - 知乎 (zhihu.com)</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74036955">Golang中Goroutine的调度流程 - 知乎 (zhihu.com)</a><br><a target="_blank" rel="noopener" href="https://cn.bing.com/search?q=goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B&cvid=90b07a00023345278580eb3d98c4f436&aqs=edge..69i57.11557j0j1&FORM=ANAB01&PC=U531">goroutine的调度过程 - 搜索 (bing.com)</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4afa0679851d">【深度知识】GO语言的goroutine并发原理和调度机制 - 简书 (jianshu.com)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/K33ShgM-cCacsgzHMWLBuA">关于Go并发编程，你不得不知的“左膀右臂”——并发与通道！ (qq.com)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/V0krCjWrndzz71cVOPBxdg">​Golang 并发编程指南 (qq.com)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o4uFiaJRIH25wt6X9LYFmw">Go 原生并发原语和最佳实践 (qq.com)</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/">https://lemon-cs.github.io/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://static01.imgkr.com/temp/f64b83005c0248dca40c71705366ac18.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">跳表原理及实现</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go语言实现分布式crontab任务系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/28/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Go开发环境搭建"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRSnhQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-28</div><div class="title">Go开发环境搭建</div></div></a></div><div><a href="/2021/12/30/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/" title="Go语言基础之map"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-30</div><div class="title">Go语言基础之map</div></div></a></div><div><a href="/2021/12/30/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/" title="Go语言基础之切片Slice"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-30</div><div class="title">Go语言基础之切片Slice</div></div></a></div><div><a href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img class="cover" src="https://static01.imgkr.com/temp/f64b83005c0248dca40c71705366ac18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-07</div><div class="title">跳表原理及实现</div></div></a></div><div><a href="/2021/12/29/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/" title="Go语言基础之依赖管理"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/7f02b700ddd8d712.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-29</div><div class="title">Go语言基础之依赖管理</div></div></a></div><div><a href="/2021/12/30/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%97%E8%A1%A8list/" title="Go语言基础之列表list"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-30</div><div class="title">Go语言基础之列表list</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">78</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91"><span class="toc-text">Go语言基础之并发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="toc-text">1.1 只执行一个任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AE%8F%E8%A7%82%E7%9A%84%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">1.2 能不能宏观的执行多个任务呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.3 线程的实现模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 用户级线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. 内核级线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%A4%E7%BA%A7%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">3. 两级线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">1.4 并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%8D%8F%E7%A8%8B"><span class="toc-text">1.5 协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-text">1.6 为什么需要协程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E6%A0%88"><span class="toc-text">1. 动态栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD"><span class="toc-text">2. 调度的性能更好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Goroutine%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E6%9A%B4%E9%9C%B2ID%E5%8F%B7"><span class="toc-text">3. Goroutine没有显示暴露ID号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Goroutine"><span class="toc-text">2. Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8goroutine"><span class="toc-text">2.2 使用goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E5%8D%95%E4%B8%AAgoroutine"><span class="toc-text">1. 启动单个goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAgoroutine"><span class="toc-text">2. 启动多个goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-GOMAXPROCS"><span class="toc-text">3. GOMAXPROCS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%88GMP%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-text">2.3 Goroutine的调度模型（GMP模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-G"><span class="toc-text">2. G</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-M"><span class="toc-text">3. M</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-P"><span class="toc-text">4. P</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4 Goroutine的调度过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B2%A1%E6%9C%89P%E5%B1%82%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. 没有P层会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B"><span class="toc-text">2. 调度过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-text">调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">3. 调度器原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E6%80%81%E9%98%BB%E5%A1%9E%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9E"><span class="toc-text">4. 用户态阻塞和系统调用阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E9%98%BB%E5%A1%9E"><span class="toc-text">用户态阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%98%BB%E5%A1%9E"><span class="toc-text">系统调用阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E8%87%AA%E6%97%8B"><span class="toc-text">5. 线程自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">6. 抢占式调度逻辑：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Goroutine%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="toc-text">2.5 Goroutine如何停止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%83%85%E5%86%B51-runtime%C2%B7park"><span class="toc-text">1. 情况1: runtime·park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%83%85%E5%86%B52-runtime%C2%B7gosched"><span class="toc-text">2. 情况2: runtime·gosched</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Goroutine-%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">3. Goroutine 的其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Goroutine%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89"><span class="toc-text">3.1 Goroutine异常捕捉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Goroutine-%E4%B8%AD%E7%9A%84-panic"><span class="toc-text">3.2 Goroutine 中的 panic</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Channel"><span class="toc-text">4. Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.1 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Channel%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2 Channel的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA"><span class="toc-text">1. 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81"><span class="toc-text">2. 发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A5%E6%94%B6"><span class="toc-text">3. 接收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">阻塞接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">非阻塞接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%BF%BD%E7%95%A5%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">接收任意数据，忽略接收的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%BC%8F%E6%8E%A5%E6%94%B6"><span class="toc-text">遍历式接收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4.3 注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%85%B3%E9%97%AD"><span class="toc-text">4.4 关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E4%BD%BF%E7%94%A8"><span class="toc-text">1. 普通使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E5%85%B3%E9%97%AD"><span class="toc-text">2. 判断关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%99%E8%A2%AB%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%B0%86%E4%BC%9A%E8%A7%A6%E5%8F%91-panic"><span class="toc-text">3. 给被关闭通道发送数据将会触发 panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8E%E5%B7%B2%E5%85%B3%E9%97%AD%E7%9A%84%E9%80%9A%E9%81%93%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%97%B6%E5%B0%86%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E9%98%BB%E5%A1%9E"><span class="toc-text">4. 从已关闭的通道接收数据时将不会发生阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Channel%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.5 Channel类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E5%90%91Channel"><span class="toc-text">1. 单向Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E7%BC%93%E5%86%B2-channel"><span class="toc-text">2. 无缓冲 channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2-channel"><span class="toc-text">3. 缓冲 channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Select-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">4.6 Select 多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-channel-%E8%B6%85%E6%97%B6"><span class="toc-text">4.7 channel 超时</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Goroutine%E5%92%8CChannel%E6%A1%88%E4%BE%8B"><span class="toc-text">5. Goroutine和Channel案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%AD%BB%E9%94%81%E7%8E%B0%E5%9C%BA%E4%B8%80%EF%BC%9A"><span class="toc-text">5.1 死锁现场一：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%AD%BB%E9%94%81%E7%8E%B0%E5%9C%BA%E4%BA%8C%EF%BC%9A"><span class="toc-text">5.2 死锁现场二：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">5.3 生产者与消费者</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img src="https://static01.imgkr.com/temp/f64b83005c0248dca40c71705366ac18.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跳表原理及实现"></a><div class="content"><a class="title" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现">跳表原理及实现</a><time datetime="2022-02-07T13:19:43.000Z" title="发表于 2022-02-07 21:19:43">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/" title="Go并发编程之Goroutine和Channel"><img src="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go并发编程之Goroutine和Channel"></a><div class="content"><a class="title" href="/2022/01/18/%E5%90%8E%E7%AB%AF/Golang/Go%E5%9F%BA%E7%A1%80/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGoroutine%E5%92%8CChannel/" title="Go并发编程之Goroutine和Channel">Go并发编程之Goroutine和Channel</a><time datetime="2022-01-18T14:09:50.000Z" title="发表于 2022-01-18 22:09:50">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2022-01-17T14:09:50.000Z" title="发表于 2022-01-17 22:09:50">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/%E5%90%8E%E7%AB%AF/Golang/Go%E5%AE%9E%E7%8E%B0/Go%E4%B8%8EJava%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" title="Go与Java实现生产者消费者"><img src="https://s3.bmp.ovh/imgs/2022/02/87365d0f071b194f.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go与Java实现生产者消费者"></a><div class="content"><a class="title" href="/2022/01/12/%E5%90%8E%E7%AB%AF/Golang/Go%E5%AE%9E%E7%8E%B0/Go%E4%B8%8EJava%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" title="Go与Java实现生产者消费者">Go与Java实现生产者消费者</a><time datetime="2022-01-12T03:37:35.000Z" title="发表于 2022-01-12 11:37:35">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/" title="进程、线程、协程"><img src="https://s3.bmp.ovh/imgs/2021/12/adda988fb50270fe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="进程、线程、协程"></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/" title="进程、线程、协程">进程、线程、协程</a><time datetime="2022-01-11T15:03:55.000Z" title="发表于 2022-01-11 23:03:55">2022-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>