<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>单元测试之Mock | Lemon-CS</title><meta name="keywords" content="Mock"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="单元测试之Mock入门学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="单元测试之Mock"><meta property="og:url" content="https://lemon-cs.github.io/2020/02/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="单元测试之Mock入门学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static01.imgkr.com/temp/7e2ff0bcacb94fe1a60c065dd5773565.jpg"><meta property="article:published_time" content="2020-02-21T13:32:12.000Z"><meta property="article:modified_time" content="2021-12-27T07:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="单元测试"><meta property="article:tag" content="Mock"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static01.imgkr.com/temp/7e2ff0bcacb94fe1a60c065dd5773565.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/02/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"单元测试之Mock",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-27 15:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://static01.imgkr.com/temp/7e2ff0bcacb94fe1a60c065dd5773565.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">单元测试之Mock</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-21T13:32:12.000Z" title="发表于 2020-02-21 21:32:12">2020-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-27T07:37:35.000Z" title="更新于 2021-12-27 15:37:35">2021-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>99分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="单元测试之Mock"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="单元测试之Mock"><a href="#单元测试之Mock" class="headerlink" title="单元测试之Mock"></a>单元测试之Mock</h1><h2 id="1-Mock详解"><a href="#1-Mock详解" class="headerlink" title="1-Mock详解"></a>1-Mock详解</h2><h3 id="1-1-什么是Mock？"><a href="#1-1-什么是Mock？" class="headerlink" title="1.1-什么是Mock？"></a>1.1-什么是Mock？</h3><p>mock是在测试过程中，对于一些不容易构造/获取的对象，创建一个mock对象来模拟对象的行为。比如说你需要调用B服务，可是B服务还没有开发完成，那么你就可以将调用B服务的那部分给Mock掉，并编写你想要的返回结果。 Mock有很多的实现框架，例如Mockito、EasyMock、Jmockit、PowerMock、Spock等等，SpringBoot默认的Mock框架是Mockito，和junit一样，只需要依赖spring-boot-starter-test就可以了。</p><p><code>Mock</code> 的中文译为仿制的，模拟的，虚假的。对于测试框架来说，即构造出一个模拟/虚假的对象，使我们的测试能顺利进行下去。</p><p><code>Mock</code> 测试就是在测试过程中，对于某些 <strong>不容易构造</strong>（如 <code>HttpServletRequest</code> 必须在 <code>Servlet</code> 容器中才能构造出来）或者不容易获取 <strong>比较复杂</strong> 的对象（如 <code>JDBC</code> 中的 <code>ResultSet</code> 对象），用一个 <strong>虚拟</strong> 的对象（<code>Mock</code> 对象）来创建，以便测试方法。</p><p>Mock 测试就是在测试过程中，创建一个假的对象，避免你为了测试一个方法，却要自行构建整个 Bean 的依赖链。</p><p>像是以下这张图，类 A 需要调用类 B 和类 C，而类 B 和类 C 又需要调用其他类如 D、E、F 等，假设类 D 是一个外部服务，那就会很难测，因为你的返回结果会直接的受外部服务影响，导致你的单元测试可能今天会过、但明天就过不了了。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Mock%E6%B5%8B%E8%AF%951.png"></p><p>而当我们引入 Mock 测试时，就可以创建一个假的对象，替换掉真实的 Bean B 和 C，这样在调用B、C的方法时，实际上就会去调用这个假的 Mock 对象的方法，而我们就可以自己设定这个 Mock 对象的参数和期望结果，让我们可以专注在测试当前的类 A，而不会受到其他的外部服务影响，这样测试效率就能提高很多。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Mock%E6%B5%8B%E8%AF%952.png"></p><h3 id="1-2-为什么使用Mock对象？"><a href="#1-2-为什么使用Mock对象？" class="headerlink" title="1.2-为什么使用Mock对象？"></a>1.2-为什么使用Mock对象？</h3><p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p><p><strong>在以下情况可以采用模拟对象来替代真实对象：</strong></p><ul><li>真实对象的行为是不确定的（例如，当前的时间或温度）；</li><li>真实对象很难搭建起来；</li><li>真实对象的行为很难触发（例如，网络错误）；</li><li>真实对象速度很慢（例如，一个完整的数据库，在测试之前可能需要初始化）；</li><li>真实的对象是用户界面，或包括用户界面在内；</li><li>真实的对象使用了回调机制；</li><li>真实对象可能还不存在；</li><li>真实对象可能包含不能用作测试（而不是为实际工作）的信息和方法。</li></ul><p><strong>单元测试</strong> 是为了验证我们的代码运行正确性，我们注重的是代码的流程以及结果的正确与否。</p><p>对比真实运行代码，可能其中有一些 <strong>外部依赖</strong> 的构建步骤相对麻烦，如果我们还是按照真实代码的构建规则构造出外部依赖，会大大增加单元测试的工作，代码也会参杂太多非测试部分的内容，测试用例显得复杂难懂。</p><p>采用 <code>Mock</code> 框架，我们可以 <strong>虚拟</strong> 出一个 <strong>外部依赖</strong>，只注重代码的 <strong>流程与结果</strong>，真正地实现测试目的。</p><h3 id="1-3-Mock测试框架的好处"><a href="#1-3-Mock测试框架的好处" class="headerlink" title="1.3-Mock测试框架的好处"></a>1.3-Mock测试框架的好处</h3><ol><li>可以很简单的虚拟出一个复杂对象（比如虚拟出一个接口的实现类）；</li><li>可以配置 <code>mock</code> 对象的行为；</li><li>可以使测试用例只注重测试流程与结果；</li><li>减少外部类、系统和依赖给单元测试带来的耦合。</li></ol><h3 id="1-4-Spring-Boot的测试类库"><a href="#1-4-Spring-Boot的测试类库" class="headerlink" title="1.4-Spring Boot的测试类库"></a>1.4-Spring Boot的测试类库</h3><p>现在绝大多数的java服务都是Spring框架搭建的，并且也会使用到Spring boot来进行快速搭建开发，在Spring Boot提供了许多实用工具和注解来帮助测试应用程序，主要包括以下两个模块：</p><ul><li>spring-boot-test：支持测试的核心内容。</li><li>spring-boot-test-autoconfigure：支持测试的自动化配置。</li></ul><p>开发进行只要使用 spring-boot-starter-test 启动器就能引入这些 Spring Boot 测试模块，还能引入一些像 JUnit, AssertJ, Hamcrest 及其他一些有用的类库，具体如下所示：</p><ul><li>JUnit：Java 应用程序单元测试标准类库。</li><li>Spring Test &amp; Spring Boot Test：Spring Boot 应用程序功能集成化测试支持。</li><li>AssertJ：一个轻量级的断言类库。</li><li>Mockito：一个Java Mock测试框架，默认支付 1.x，可以修改为 2.x。</li><li>JsonPath：一个JSON操作类库。</li></ul><h3 id="1-5-MockMvc"><a href="#1-5-MockMvc" class="headerlink" title="1.5-MockMvc"></a>1.5-MockMvc</h3><p><code>MockMvc</code>是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p><p><strong>接口<code>MockMvcBuilder</code>，提供一个唯一的<code>build</code>方法，用来构造MockMvc。</strong></p><p>主要有两个实现：<code>StandaloneMockMvcBuilder</code>和<code>DefaultMockMvcBuilder</code>，分别对应两种测试方式，即独立安装和集成Web环境测试（并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。MockMvcBuilders提供了对应的创建方法standaloneSetup方法和webAppContextSetup方法，在使用时直接调用即可。</p><h3 id="1-6-MockMvc测试用例"><a href="#1-6-MockMvc测试用例" class="headerlink" title="1.6-MockMvc测试用例"></a>1.6-MockMvc测试用例</h3><h4 id="1-6-1-引入pom依赖"><a href="#1-6-1-引入pom依赖" class="headerlink" title="1.6.1. 引入pom依赖"></a>1.6.1. 引入pom依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-6-2-MockMVC基于RESTful风格的测试"><a href="#1-6-2-MockMVC基于RESTful风格的测试" class="headerlink" title="1.6.2. MockMVC基于RESTful风格的测试"></a>1.6.2. MockMVC基于RESTful风格的测试</h4><blockquote><p>对于前后端分离的项目而言，无法直接从前端静态代码中测试接口的正确性，因此可以通过MockMVC来模拟HTTP请求。基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。</p></blockquote><ul><li><p>request</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>response</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写一个简单的Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebResponse&lt;String&gt; <span class="title">ping</span><span class="params">(<span class="meta">@RequestBody</span> WebRequest webRequest)</span></span>&#123;</span><br><span class="line">        System.out.println(webRequest);</span><br><span class="line">        WebResponse&lt;String&gt; response = <span class="keyword">new</span> WebResponse&lt;&gt;();</span><br><span class="line">        response.setBody(<span class="string">&quot;create 完成---&quot;</span>);</span><br><span class="line">        response.setCode(<span class="string">&quot;00000&quot;</span>);</span><br><span class="line">        response.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个测试用例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebControllerIT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext mac;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ping</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//请求的json</span></span><br><span class="line">        String json = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;mobile\&quot;:\&quot;12345678901\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//perform,执行一个RequestBuilders请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理</span></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                <span class="comment">//构造一个post请求</span></span><br><span class="line">                .post(<span class="string">&quot;/web/create&quot;</span>)</span><br><span class="line">                <span class="comment">//json类型</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                <span class="comment">//使用writeValueAsString()方法来获取对象的JSON字符串表示</span></span><br><span class="line">                .content(json))</span><br><span class="line">                <span class="comment">//andExpect，添加ResultMathcers验证规则，验证控制器执行完成后结果是否正确，【这是一个断言】</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().is(<span class="number">200</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                <span class="comment">//使用jsonPaht验证返回的json中code字段的返回值</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.code&quot;</span>).value(<span class="string">&quot;00000&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.message&quot;</span>).value(<span class="string">&quot;成功&quot;</span>))</span><br><span class="line">                <span class="comment">//body属性不为空</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.body&quot;</span>).isNotEmpty())</span><br><span class="line">                <span class="comment">//添加ResultHandler结果处理器，比如调试时 打印结果(print方法)到控制台</span></span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                <span class="comment">//返回相应的MvcResult</span></span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-6-3-常用API"><a href="#1-6-3-常用API" class="headerlink" title="1.6.3-常用API"></a>1.6.3-常用API</h4><ul><li><p><strong>常用的期望</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用jsonPaht验证返回的json中code、message字段的返回值</span></span><br><span class="line">.andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.code&quot;</span>).value(<span class="string">&quot;00000&quot;</span>))</span><br><span class="line">.andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.message&quot;</span>).value(<span class="string">&quot;成功&quot;</span>))</span><br><span class="line"><span class="comment">//body属性不为空</span></span><br><span class="line">.andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.body&quot;</span>).isNotEmpty())</span><br><span class="line"><span class="comment">// 期望的返回结果集合有2个元素 ， $: 返回结果</span></span><br><span class="line">.andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.length()&quot;</span>).value(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>常用API解释</strong></p><ul><li><p><strong>RequestBuilder/MockMvcRequestBuilders</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据uri模板和uri变量值得到一个GET请求方式的MockHttpServletRequestBuilder；</span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">get</span><span class="params">(String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同get类似，但是是POST方法；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">post</span><span class="params">(String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同get类似，但是是PUT方法；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">put</span><span class="params">(String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同get类似，但是是DELETE方法；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">delete</span><span class="params">(String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同get类似，但是是OPTIONS方法；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">options</span><span class="params">(String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//提供自己的Http请求方法及uri模板和uri变量，如上API都是委托给这个API；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">request</span><span class="params">(HttpMethod httpMethod, String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//提供文件上传方式的请求，得到MockMultipartHttpServletRequestBuilder；</span></span></span><br><span class="line"><span class="function">MockMultipartHttpServletRequestBuilder <span class="title">fileUpload</span><span class="params">(String urlTemplate, Object... urlVariables)</span></span></span><br><span class="line"><span class="function"><span class="comment">//创建一个从启动异步处理的请求的MvcResult进行异步分派的RequestBuilder；</span></span></span><br><span class="line"><span class="function">RequestBuilder <span class="title">asyncDispatch</span><span class="params">(<span class="keyword">final</span> MvcResult mvcResult)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>MockHttpServletRequestBuilder：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//：添加头信息；</span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">header</span><span class="params">(String name, Object... values)</span>/MockHttpServletRequestBuilder <span class="title">headers</span><span class="params">(HttpHeaders httpHeaders)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求的contentType头信息；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">contentType</span><span class="params">(MediaType mediaType)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求的Accept头信息；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">accept</span><span class="params">(MediaType... mediaTypes)</span>/MockHttpServletRequestBuilder <span class="title">accept</span><span class="params">(String... mediaTypes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求Body体内容；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">content</span><span class="params">(<span class="keyword">byte</span>[] content)</span>/MockHttpServletRequestBuilder <span class="title">content</span><span class="params">(String content)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：请求传入参数</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">param</span><span class="params">(String name,String... values)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求的Cookie；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">cookie</span><span class="params">(Cookie... cookies)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求的Locale；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">locale</span><span class="params">(Locale locale)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求字符编码；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">characterEncoding</span><span class="params">(String encoding)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：设置请求属性数据；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">requestAttr</span><span class="params">(String name, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//：设置请求session属性数据；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">sessionAttr</span><span class="params">(String name, Object value)</span>/MockHttpServletRequestBuilder <span class="title">sessionAttrs</span><span class="params">(Map&lt;string, object=<span class="string">&quot;&quot;</span>&gt; sessionAttributes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//指定请求的flash信息，比如重定向后的属性信息；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">flashAttr</span><span class="params">(String name, Object value)</span>/MockHttpServletRequestBuilder <span class="title">flashAttrs</span><span class="params">(Map&lt;string, object=<span class="string">&quot;&quot;</span>&gt; flashAttributes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求的Session；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">session</span><span class="params">(MockHttpSession session)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ：指定请求的Principal；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">principal</span><span class="params">(Principal principal)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：指定请求的上下文路径，必须以“/”开头，且不能以“/”结尾；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">contextPath</span><span class="params">(String contextPath)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//：请求的路径信息，必须以“/”开头；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">pathInfo</span><span class="params">(String pathInfo)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//：请求是否使用安全通道；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">secure</span><span class="params">(<span class="keyword">boolean</span> secure)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：请求的后处理器，用于自定义一些请求处理的扩展点；</span></span></span><br><span class="line"><span class="function">MockHttpServletRequestBuilder <span class="title">with</span><span class="params">(RequestPostProcessor postProcessor)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>MockMultipartHttpServletRequestBuilder</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//：指定要上传的文件；</span></span><br><span class="line"><span class="function">MockMultipartHttpServletRequestBuilder <span class="title">file</span><span class="params">(String name, <span class="keyword">byte</span>[] content)</span>/MockMultipartHttpServletRequestBuilder <span class="title">file</span><span class="params">(MockMultipartFile file)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>ResultActions</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//：添加验证断言来判断执行请求后的结果是否是预期的；</span></span><br><span class="line"><span class="function">ResultActions <span class="title">andExpect</span><span class="params">(ResultMatcher matcher)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//：添加结果处理器，用于对验证成功后执行的动作，如输出下请求/结果信息用于调试；</span></span></span><br><span class="line"><span class="function">ResultActions <span class="title">andDo</span><span class="params">(ResultHandler handler)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//：返回验证成功后的MvcResult；用于自定义验证/下一步的异步处理；</span></span></span><br><span class="line"><span class="function">MvcResult <span class="title">andReturn</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>ResultMatcher/MockMvcResultMatchers</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//：请求的Handler验证器，比如验证处理器类型/方法名；此处的Handler其实就是处理请求的控制器；</span></span><br><span class="line"><span class="function">HandlerResultMatchers <span class="title">handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到RequestResultMatchers验证器；</span></span></span><br><span class="line"><span class="function">RequestResultMatchers <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到模型验证器；</span></span></span><br><span class="line"><span class="function">ModelResultMatchers <span class="title">model</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到视图验证器；</span></span></span><br><span class="line"><span class="function">ViewResultMatchers <span class="title">view</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到Flash属性验证；</span></span></span><br><span class="line"><span class="function">FlashAttributeResultMatchers <span class="title">flash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到响应状态验证器；</span></span></span><br><span class="line"><span class="function">StatusResultMatchers <span class="title">status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到响应Header验证器；</span></span></span><br><span class="line"><span class="function">HeaderResultMatchers <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到响应Cookie验证器；</span></span></span><br><span class="line"><span class="function">CookieResultMatchers <span class="title">cookie</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到响应内容验证器；</span></span></span><br><span class="line"><span class="function">ContentResultMatchers <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到Json表达式验证器；</span></span></span><br><span class="line"><span class="function">JsonPathResultMatchers <span class="title">jsonPath</span><span class="params">(String expression, Object ... args)</span>/ResultMatcher <span class="title">jsonPath</span><span class="params">(String expression, Matcher matcher)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：得到Xpath表达式验证器；</span></span></span><br><span class="line"><span class="function">XpathResultMatchers <span class="title">xpath</span><span class="params">(String expression, Object... args)</span>/XpathResultMatchers <span class="title">xpath</span><span class="params">(String expression, Map&lt;string, string=<span class="string">&quot;&quot;</span>&gt; namespaces, Object... args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：验证处理完请求后转发的url（绝对匹配）；</span></span></span><br><span class="line"><span class="function">ResultMatcher <span class="title">forwardedUrl</span><span class="params">(<span class="keyword">final</span> String expectedUrl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：验证处理完请求后转发的url（Ant风格模式匹配，@since spring4）；</span></span></span><br><span class="line"><span class="function">ResultMatcher <span class="title">forwardedUrlPattern</span><span class="params">(<span class="keyword">final</span> String urlPattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：验证处理完请求后重定向的url（绝对匹配）；</span></span></span><br><span class="line"><span class="function">ResultMatcher <span class="title">redirectedUrl</span><span class="params">(<span class="keyword">final</span> String expectedUrl)</span></span></span><br><span class="line"><span class="function"><span class="comment">//：验证处理完请求后重定向的url（Ant风格模式匹配，@since spring4）；</span></span></span><br><span class="line"><span class="function">ResultMatcher <span class="title">redirectedUrlPattern</span><span class="params">(<span class="keyword">final</span> String expectedUrl)</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-Mockito"><a href="#2-Mockito" class="headerlink" title="2-Mockito"></a>2-Mockito</h2><h3 id="2-1-什么是Mockito？"><a href="#2-1-什么是Mockito？" class="headerlink" title="2.1-什么是Mockito？"></a>2.1-什么是Mockito？</h3><p>Mockito是mocking框架，它让你用简洁的API做测试。而且Mockito简单易学，它可读性强和验证语法简洁。<br>Mockito是GitHub上使用最广泛的Mock框架,并与JUnit结合使用.Mockito框架可以创建和配置mock对象.使用Mockito简化了具有外部依赖的类的测试开发。</p><p>Mockito 是一种 Java Mock 框架，他主要就是用来做 Mock 测试的，它可以模拟任何 Spring 管理的 Bean、模拟方法的返回值、模拟抛出异常等等，同时也会记录调用这些模拟方法的参数、调用顺序，从而可以校验出这个 Mock 对象是否有被正确的顺序调用，以及按照期望的参数被调用。</p><p>像是 Mockito 可以在单元测试中模拟一个 Service 返回的数据，而不会真正去调用该 Service，这就是上面提到的 Mock 测试精神，也就是通过模拟一个假的 Service 对象，来快速的测试当前我想要测试的类。</p><p>目前在 Java 中主流的 Mock 测试工具有 Mockito、JMock、EasyMock等等，而 SpringBoot 目前内建的是 Mockito 框架。</p><h3 id="2-2-使用模拟对象进行测试"><a href="#2-2-使用模拟对象进行测试" class="headerlink" title="2.2-使用模拟对象进行测试"></a>2.2-使用模拟对象进行测试</h3><h4 id="2-2-1-单元测试的目标和挑战"><a href="#2-2-1-单元测试的目标和挑战" class="headerlink" title="2.2.1-单元测试的目标和挑战"></a>2.2.1-单元测试的目标和挑战</h4><p>单元测试应单独测试功能。如有可能，应消除其他类别或系统的副作用，以进行单元测试。</p><p>这可以通过对真正的依赖项使用测试替换（<em>test doubles</em>）来完成。双重测试可以分为以下几类：</p><ul><li>一个<em>虚拟对象</em>被传来传去，但从来没有使用过，即它的方法永远不会被调用。这样的对象可以例如用于填充方法的参数列表。</li><li><em>伪</em>对象具有有效的实现，但通常可以简化。例如，他们使用内存数据库而不是真实数据库。</li><li><em>存根</em>类是一个接口或类与在测试过程中使用该存根类的一个实例的目的的部分实施。存根通常不对测试中编程的内容做出任何反应。存根可能还会记录有关呼叫的信息。</li><li><em>模拟对象</em>是在其中定义某些方法调用的输出接口或类伪实现。模拟对象配置为在测试期间执行某些行为。他们通常记录与系统的交互，测试可以验证这一点。</li></ul><p>可以将测试双打传递给其他要测试的对象。您的测试可以验证该类在测试过程中的正确反应。例如，您可以验证是否调用了模拟对象上的某些方法。这有助于确保您仅在运行测试时对类进行测试，并且确保测试不受任何副作用的影响。</p><h4 id="2-2-2-模拟对象生成"><a href="#2-2-2-模拟对象生成" class="headerlink" title="2.2.2-模拟对象生成"></a>2.2.2-模拟对象生成</h4><p>您可以手动（通过代码）创建模拟对象，也可以使用模拟框架来模拟这些类。模拟框架允许您在运行时创建模拟对象并定义其行为。</p><p>模拟对象的经典示例是数据提供程序。在生产中，使用了连接到真实数据源的实现。但是对于测试，模拟对象会模拟数据源并确保测试条件始终相同。</p><p>可以将这些模拟对象提供给要测试的类。因此，要测试的类应避免对外部数据的任何硬性依赖。</p><p>模拟或模拟框架允许测试与模拟对象的预期交互。例如，您可以验证仅在模拟对象上调用了某些方法。</p><h4 id="2-2-3-使用Mockito模拟对象"><a href="#2-2-3-使用Mockito模拟对象" class="headerlink" title="2.2.3-使用Mockito模拟对象"></a>2.2.3-使用Mockito模拟对象</h4><p><em>Mockito</em>是一种流行的模拟框架，可以与JUnit结合使用。Mockito允许您创建和配置模拟对象。使用Mockito大大简化了具有外部依赖项的类的测试开发。</p><p>如果在测试中使用Mockito，通常会按照以下步骤：</p><ul><li>模拟掉外部依赖关系并将模拟插入待测代码</li><li>执行被测代码</li><li>验证代码是否正确执行</li></ul><h4 id="2-2-4-mock和stub"><a href="#2-2-4-mock和stub" class="headerlink" title="2.2.4-mock和stub"></a>2.2.4-mock和stub</h4><p>stub存在的意图是为了让测试对象可以正常的执行，其实现一般会硬编码一些输入和输出。</p><p>mock除了保证stub的功能之外，还可深入的模拟对象之间的交互方式，如：调用了几次、在某种情况下是否会抛出异常</p><ul><li><p>Mock和Stub都是通过一种更加快捷的方式让我们能够及时迅速的获取到我们期望的对象和数据。</p></li><li><p>Stub更关注于状态，它可以通过硬编码一些输入或者输出，让我们获取我们需要的数据。</p></li><li><p>Mock更关注于行为，它可以记录对象中各个方法都调用情况，如：是否被调用，调用了几次、在某种情况下是否会抛出异常等。</p></li></ul><blockquote><ol><li>stub一个mock对象的方法后，不能在同一个mock对象上再一次stub这个方法，第二次的stub无效。</li><li>不可stub一个非mock对象的方法，这种操作stub是无效的。</li></ol></blockquote><h3 id="2-3-Mockito的使用"><a href="#2-3-Mockito的使用" class="headerlink" title="2.3-Mockito的使用"></a>2.3-Mockito的使用</h3><h4 id="2-3-1-引入pom依赖"><a href="#2-3-1-引入pom依赖" class="headerlink" title="2.3.1-引入pom依赖"></a>2.3.1-引入pom依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-测试类中引入静态资源"><a href="#2-3-2-测试类中引入静态资源" class="headerlink" title="2.3.2-测试类中引入静态资源"></a>2.3.2-测试类中引入静态资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*; </span><br></pre></td></tr></table></figure><h4 id="2-3-3-常用的Mockito方法"><a href="#2-3-3-常用的Mockito方法" class="headerlink" title="2.3.3-常用的Mockito方法"></a>2.3.3-常用的Mockito方法</h4><table><thead><tr><th><strong>方法名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Mockito.mock(classToMock)</td><td>模拟对象</td></tr><tr><td>Mockito.verify(mock)</td><td>验证行为是否发生</td></tr><tr><td>Mockito.when(methodCall).thenReturn(value1).thenReturn(value2)</td><td>触发时第一次返回value1，第n次都返回value2</td></tr><tr><td>Mockito.doThrow(toBeThrown).when(mock).[method]</td><td>模拟抛出异常。</td></tr><tr><td>Mockito.mock(classToMock,defaultAnswer)</td><td>使用默认Answer模拟对象</td></tr><tr><td>Mockito.when(methodCall).thenReturn(value)</td><td>参数匹配</td></tr><tr><td>Mockito.doReturn(toBeReturned).when(mock).[method]</td><td>参数匹配（直接执行不判断）</td></tr><tr><td>Mockito.when(methodCall).thenAnswer(answer))</td><td>预期回调接口生成期望值</td></tr><tr><td>Mockito.doAnswer(answer).when(methodCall).[method]</td><td>预期回调接口生成期望值（直接执行不判断）</td></tr><tr><td>Mockito.spy(Object)</td><td>用spy监控真实对象,设置真实对象行为</td></tr><tr><td>Mockito.doNothing().when(mock).[method]</td><td>不做任何返回</td></tr><tr><td>Mockito.doCallRealMethod().when(mock).[method] //等价于 Mockito.when(mock.[method]).thenCallRealMethod();</td><td>调用真实的方法</td></tr><tr><td>reset(mock)</td><td>重置mock</td></tr></tbody></table><h4 id="2-3-4-示例"><a href="#2-3-4-示例" class="headerlink" title="2.3.4-示例"></a>2.3.4-示例</h4><h5 id="1-验证某些行为确实发生过（有没有被调用过）"><a href="#1-验证某些行为确实发生过（有没有被调用过）" class="headerlink" title="1. 验证某些行为确实发生过（有没有被调用过）"></a>1. 验证某些行为确实发生过（有没有被调用过）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态导入会使代码更简洁</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock creation 创建mock对象</span></span><br><span class="line">List mockedList = mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using mock object 使用mock对象</span></span><br><span class="line"><span class="comment">//验证add方法是否在前面被调用了一次，且参数为“one”。clear方法同样。</span></span><br><span class="line">mockedList.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">mockedList.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//verification 验证</span></span><br><span class="line"><span class="comment">//下面的验证会失败。因为没有调用过add(&quot;two&quot;)。</span></span><br><span class="line">verify(mockedList).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">verify(mockedList).clear();</span><br></pre></td></tr></table></figure><p>一旦mock对象被创建了，mock对象会记住所有的交互。然后你就可能选择性的验证你感兴趣的交互。</p><h5 id="2-如何做一些测试桩（Stub）"><a href="#2-如何做一些测试桩（Stub）" class="headerlink" title="2. 如何做一些测试桩（Stub）"></a>2. 如何做一些测试桩（Stub）</h5><p>Mockito可以预设方法返回值，称为stubbing。如果这个方法没被stubbing，则默认返回null，0，false，空集合之类的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你可以mock具体的类型,不仅只是接口</span></span><br><span class="line">LinkedList mockedList = mock(LinkedList.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//stubbing</span></span><br><span class="line"><span class="comment">// 测试桩</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出“first”</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 因为get(999) 没有打桩，因此输出null</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证get(0)被调用的次数</span></span><br><span class="line">verify(mockedList).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>插桩：使mock对象的方法返回期望值<br>对于没有stub过的有返回值的方法，会返回默认值（0，false，null等）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stubbing。当get(0)被调用时，返回&quot;first&quot;. 方法get(1)被调用时，抛异常。</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br></pre></td></tr></table></figure><ul><li>重复stub</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重复stub，以最后一次为准，如下将返回&quot;second&quot;：</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;second&quot;</span>);</span><br><span class="line"><span class="comment">//如下表示第一次调用时返回“first”，第二次调用时返回“second”。可以写n个。</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;first&quot;</span>).thenReturn(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">如果实际调用的次数超过了stub过的次数，则返回最后一次stub的值。</span><br><span class="line">例如第三次调用get(<span class="number">0</span>)时，则会返回<span class="string">&quot;second&quot;</span>.</span><br></pre></td></tr></table></figure><ul><li>默认情况下，所有的函数都有返回值。mock函数默认返回的是null，一个空的集合或者一个被对象类型包装的内置类型，例如0、false对应的对象类型为Integer、Boolean；</li><li>测试桩函数可以被覆写 : 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；</li><li>一旦测试桩函数被调用，该函数将会一致返回固定的值；</li><li>上一次调用测试桩函数有时候极为重要-当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。</li></ul><h5 id="3-参数匹配器（matchers）"><a href="#3-参数匹配器（matchers）" class="headerlink" title="3. 参数匹配器（matchers）"></a>3. 参数匹配器（matchers）</h5><p>Mockito以自然的java风格来验证参数值: 使用equals()函数。有时，当需要额外的灵活性时你可能需要使用参数匹配器，也就是argument matchers :</p><p><code>Mockito.anyInt()</code> 任何 int 值 ；<br><code>Mockito.anyLong()</code> 任何 long 值 ；<br><code>Mockito.anyString()</code> 任何 String 值 ；</p><p><code>Mockito.any(XXX.class)</code> 任何 XXX 类型的值 等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用内置的anyInt()参数匹配器</span></span><br><span class="line"> when(mockedList.get(anyInt())).thenReturn(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"> <span class="comment">// 使用自定义的参数匹配器( 在isValid()函数中返回你自己的匹配器实现 )</span></span><br><span class="line"> when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"> <span class="comment">// 输出element</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"> <span class="comment">// 你也可以验证参数匹配器</span></span><br><span class="line"> verify(mockedList).get(anyInt());</span><br><span class="line"><span class="comment">//argument matchers can also be written as Java 8 Lambdas</span></span><br><span class="line">verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; <span class="number">5</span>));</span><br><span class="line"><span class="comment">// 需要注意的是，如果使用Argument matchers，那么所有参数都必须由其提供。</span></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">&quot;third argument&quot;</span>));</span><br><span class="line"><span class="comment">//above is correct - eq() is also an argument matcher</span></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">&quot;third argument&quot;</span>);</span><br><span class="line"><span class="comment">//above is incorrect - exception will be thrown because third argument is givenwithout an argument matcher.</span></span><br></pre></td></tr></table></figure><p>参数匹配器使验证和测试桩变得更灵活。<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Matchers.html">点击这里</a>查看更多内置的匹配器以及自定义参数匹配器或者hamcrest 匹配器的示例。</p><p>如果仅仅是获取自定义参数匹配器的信息，查看<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentMatcher.html">ArgumentMatcher类文档</a>即可。</p><p>为了合理的使用复杂的参数匹配，使用equals()与anyX() 的匹配器会使得测试代码更简洁、简单。有时，会迫使你重构代码以使用equals()匹配或者实现equals()函数来帮助你进行测试。</p><p>同时建议你阅读<a target="_blank" rel="noopener" href="https://github.com/hehonghui/mockito-doc-zh#sec_15">第15章节</a>或者<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentCaptor.html">ArgumentCaptor类文档</a>。ArgumentCaptor是一个能够捕获参数值的特俗参数匹配器。</p><p><strong>参数匹配器的注意点 :</strong></p><p>如果你使用参数匹配器,所有参数都必须由匹配器提供。</p><p>示例 : ( 该示例展示了如何多次应用于测试桩函数的验证 )</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">&quot;third argument&quot;</span>));</span><br><span class="line"><span class="comment">//above is correct - eq() is also an argument matcher</span></span><br><span class="line"><span class="comment">// 上述代码是正确的,因为eq()也是一个参数匹配器</span></span><br><span class="line"></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">&quot;third argument&quot;</span>);</span><br><span class="line"><span class="comment">//above is incorrect - exception will be thrown because third argument </span></span><br><span class="line"><span class="comment">// 上述代码是错误的,因为所有参数必须由匹配器提供，而参数&quot;third argument&quot;并非由参数匹配器提供，因此的缘故会抛出异常</span></span><br></pre></td></tr></table></figure><p>像anyObject(), eq()这样的匹配器函数不会返回匹配器。它们会在内部将匹配器记录到一个栈当中，并且返回一个假的值，通常为null。<code>这样的实现是由于被Java编译器强加的静态类型安全</code>。结果就是你不能在验证或者测试桩函数之外使用anyObject(), eq()函数。</p><h5 id="4-验证函数的确切、最少、从未调用次数"><a href="#4-验证函数的确切、最少、从未调用次数" class="headerlink" title="4. 验证函数的确切、最少、从未调用次数"></a>4. 验证函数的确切、最少、从未调用次数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using mock</span></span><br><span class="line"> mockedList.add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line"></span><br><span class="line"> mockedList.add(<span class="string">&quot;twice&quot;</span>);</span><br><span class="line"> mockedList.add(<span class="string">&quot;twice&quot;</span>);</span><br><span class="line"></span><br><span class="line"> mockedList.add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"> mockedList.add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"> mockedList.add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//following two verifications work exactly the same - times(1) is used by default</span></span><br><span class="line"> <span class="comment">// 下面的两个验证函数效果一样,因为verify默认验证的就是times(1)</span></span><br><span class="line"> verify(mockedList).add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line"> verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//exact number of invocations verification</span></span><br><span class="line"> <span class="comment">// 验证具体的执行次数</span></span><br><span class="line"> verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">&quot;twice&quot;</span>);</span><br><span class="line"> verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//verification using never(). never() is an alias to times(0)</span></span><br><span class="line"> <span class="comment">// 使用never()进行验证,never相当于times(0)</span></span><br><span class="line"> verify(mockedList, never()).add(<span class="string">&quot;never happened&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//verification using atLeast()/atMost()</span></span><br><span class="line"> <span class="comment">// 使用atLeast()/atMost()</span></span><br><span class="line"> verify(mockedList, atLeastOnce()).add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"> verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">&quot;five times&quot;</span>);</span><br><span class="line"> verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">&quot;three times&quot;</span>);</span><br></pre></td></tr></table></figure><p>verify函数默认验证的是执行了times(1)，也就是某个测试函数是否执行了1次.因此，times(1)通常被省略了。</p><h5 id="5-为返回值为void的函数通过Stub抛出异常"><a href="#5-为返回值为void的函数通过Stub抛出异常" class="headerlink" title="5. 为返回值为void的函数通过Stub抛出异常"></a>5. 为返回值为void的函数通过Stub抛出异常</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//following throws RuntimeException:</span></span><br><span class="line"><span class="comment">// 调用这句代码会抛出异常</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><p>最初，<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#stubVoid(T)">stubVoid(Object)</a> 函数用于为无返回值的函数打桩。现在stubVoid()函数已经过时,doThrow(Throwable)成为了它的继承者。这是为了提升与 doAnswer(Answer) 函数族的可读性与一致性。</p><h5 id="6-验证调用执行顺序"><a href="#6-验证调用执行顺序" class="headerlink" title="6. 验证调用执行顺序"></a>6. 验证调用执行顺序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A. 验证mock一个对象的函数执行顺序</span></span><br><span class="line">List singleMock = mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using a single mock</span></span><br><span class="line">singleMock.add(<span class="string">&quot;was added first&quot;</span>);</span><br><span class="line">singleMock.add(<span class="string">&quot;was added second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为该mock对象创建一个inOrder对象</span></span><br><span class="line">InOrder inOrder = inOrder(singleMock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保add函数首先执行的是add(&quot;was added first&quot;),然后才是add(&quot;was added second&quot;)</span></span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">&quot;was added first&quot;</span>);</span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">&quot;was added second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B .验证多个mock对象的函数执行顺序</span></span><br><span class="line">List firstMock = mock(List.class);</span><br><span class="line">List secondMock = mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using mocks</span></span><br><span class="line">firstMock.add(<span class="string">&quot;was called first&quot;</span>);</span><br><span class="line">secondMock.add(<span class="string">&quot;was called second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为这两个Mock对象创建inOrder对象</span></span><br><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证它们的执行顺序</span></span><br><span class="line">inOrder.verify(firstMock).add(<span class="string">&quot;was called first&quot;</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">&quot;was called second&quot;</span>);</span><br><span class="line"><span class="comment">// Oh, and A + B can be mixed together at will</span></span><br></pre></td></tr></table></figure><p>验证执行顺序是非常灵活的-你不需要一个一个的验证所有交互,只需要验证你感兴趣的对象即可。 另外，你可以仅通过那些需要验证顺序的mock对象来创建InOrder对象。</p><h5 id="7-确保交互-interaction-操作不会执行在mock对象上"><a href="#7-确保交互-interaction-操作不会执行在mock对象上" class="headerlink" title="7. 确保交互(interaction)操作不会执行在mock对象上"></a>7. 确保交互(interaction)操作不会执行在mock对象上</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Mock对象</span></span><br><span class="line">mockOne.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="comment">// 普通验证</span></span><br><span class="line">verify(mockOne).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="comment">// 验证某个交互是否从未被执行</span></span><br><span class="line">verify(mockOne, never()).add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"><span class="comment">// 验证mock对象没有交互过</span></span><br><span class="line">verifyZeroInteractions(mockTwo, mockThree);</span><br></pre></td></tr></table></figure><h5 id="8-查找冗余的调用"><a href="#8-查找冗余的调用" class="headerlink" title="8. 查找冗余的调用"></a>8. 查找冗余的调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using mocks</span></span><br><span class="line">mockedList.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">mockedList.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line">verify(mockedList).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//following verification will fail</span></span><br><span class="line"><span class="comment">// 下面的验证将会失败</span></span><br><span class="line">verifyNoMoreInteractions(mockedList);</span><br></pre></td></tr></table></figure><p>一些用户可能会在频繁地使用<code>verifyNoMoreInteractions()</code>，甚至在每个测试函数中都用。但是<code>verifyNoMoreInteractions()</code>并不建议在每个测试函数中都使用。<code>verifyNoMoreInteractions()</code>在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。你可以阅读<a target="_blank" rel="noopener" href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">这篇文档</a>来了解更多相关信息。</p><p><code>never()</code>是一种更为明显且易于理解的形式。</p><h5 id="9-简化mock对象的创建"><a href="#9-简化mock对象的创建" class="headerlink" title="9. 简化mock对象的创建"></a>9. 简化mock对象的创建</h5><ul><li>最小化重复的创建代码</li><li>使测试类的代码可读性更高</li><li>使验证错误更易于阅读，因为字段名可用于标识mock对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleManagerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleCalculator calculator;</span><br><span class="line">   <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line">   <span class="meta">@Mock</span> <span class="keyword">private</span> UserProvider userProvider;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ArticleManager manager;</span><br></pre></td></tr></table></figure><p>注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者test runner中:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MockitoAnnotations.initMocks(testClass);</span><br></pre></td></tr></table></figure><p>你可以使用内置的runner: <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html">MockitoJUnitRunner</a> <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html">runner</a> 或者一个rule : <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html">MockitoRule</a>。 关于mock注解的更多信息可以阅读<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html">MockitoAnnotations文档</a>。</p><p><strong>有2种启用Mockito注解的方法：</strong></p><ul><li>写个@Before(JUnit4)方法，里边调用MockitoAnnotations.initMocks(this)方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMocks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以直接使用built-in runner: MockitoJUnitRunner。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br></pre></td></tr></table></figure><h5 id="10-为连续的调用做测试桩-stub"><a href="#10-为连续的调用做测试桩-stub" class="headerlink" title="10. 为连续的调用做测试桩 (stub)"></a>10. 为连续的调用做测试桩 (stub)</h5><p>有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。典型的运用就是使用mock迭代器。 原始版本的Mockito并没有这个特性，例如，可以使用Iterable或者简单的集合来替换迭代器。这些方法提供了更自然的方式，在一些场景中为连续的调用做测试桩会很有用。示例如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">when(mock.someMethod(<span class="string">&quot;some arg&quot;</span>))</span><br><span class="line">  .thenThrow(<span class="keyword">new</span> RuntimeException())</span><br><span class="line">  .thenReturn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//First call: throws runtime exception:</span></span><br><span class="line"><span class="comment">// 第一次调用 : 抛出运行时异常</span></span><br><span class="line">mock.someMethod(<span class="string">&quot;some arg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Second call: prints &quot;foo&quot;</span></span><br><span class="line"><span class="comment">// 第二次调用 : 输出&quot;foo&quot;</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">&quot;some arg&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Any consecutive call: prints &quot;foo&quot; as well (last stubbing wins).</span></span><br><span class="line"><span class="comment">// 后续调用 : 也是输出&quot;foo&quot;</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">&quot;some arg&quot;</span>));</span><br></pre></td></tr></table></figure><p>另外，连续调用的另一种更简短的版本 :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次调用时返回&quot;one&quot;,第二次返回&quot;two&quot;,第三次返回&quot;three&quot;</span></span><br><span class="line"> when(mock.someMethod(<span class="string">&quot;some arg&quot;</span>))</span><br><span class="line">   .thenReturn(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="11-为回调做测试桩"><a href="#11-为回调做测试桩" class="headerlink" title="11. 为回调做测试桩"></a>11. 为回调做测试桩</h5><p>Allows stubbing with generic Answer interface. 运行为泛型接口Answer打桩。</p><p>在最初的Mockito里也没有这个具有争议性的特性。我们建议使用thenReturn() 或thenThrow()来打桩。这两种方法足够用于测试或者测试驱动开发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">when(mock.someMethod(anyString())).thenAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">    <span class="function">Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        Object mock = invocation.getMock();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;called with arguments: &quot;</span> + args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Following prints &quot;called with arguments: foo&quot;</span></span><br><span class="line"><span class="comment">// 输出 : &quot;called with arguments: foo&quot;</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">&quot;foo&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="12-doReturn-、doThrow-、doAnswer-、doNothing-、doCallRealMethod-系列方法的运用"><a href="#12-doReturn-、doThrow-、doAnswer-、doNothing-、doCallRealMethod-系列方法的运用" class="headerlink" title="12. doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用"></a>12. doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用</h5><p>通过<code>when(Object)</code>为无返回值的函数打桩有不同的方法,因为编译器不喜欢void函数在括号内…</p><p>使用<code>doThrow(Throwable)</code> 替换<code>stubVoid(Object)</code>来为void函数打桩是为了与<code>doAnswer()</code>等函数族保持一致性。</p><p>当你想为void函数打桩时使用含有一个exception 参数的<code>doAnswer()</code> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doThrow(new RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line">//following throws RuntimeException:</span><br><span class="line">// 下面的代码会抛出异常</span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><p>当你调用<code>doThrow()</code>, <code>doAnswer()</code>, <code>doNothing()</code>, <code>doReturn()</code> and <code>doCallRealMethod()</code> 这些函数时可以在适当的位置调用<code>when()</code>函数. 当你需要下面这些功能时这是必须的:</p><ul><li>测试void函数</li><li>在受监控的对象上测试函数</li><li>不知一次的测试为同一个函数，在测试过程中改变mock对象的行为。</li></ul><p>但是在调用<code>when()</code>函数时你可以选择是否调用这些上述这些函数。</p><ul><li><p><strong>doReturn(Object toBeReturned)</strong></p><p>使用<code>doReturn()</code>在那些极少数情况下，你不能使用<a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>。</p><p><strong>注意<a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>始终建议进行存根，因为它是参数类型安全的，并且更具可读性</strong>（尤其是在存续的调用存根时）。</p><p>以下是doReturn（）派上用场的罕见情况：</p><ol><li><p>监视真实对象并在间谍上调用真实方法时会带来副作用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)</span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">doReturn(<span class="string">&quot;foo&quot;</span>).when(spy).get(<span class="number">0</span>);</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li><p>覆盖先前的异常处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">when(mock.foo()).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line">     </span><br><span class="line"><span class="comment">//Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.</span></span><br><span class="line">when(mock.foo()).thenReturn(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">doReturn(<span class="string">&quot;bar&quot;</span>).when(mock).foo();</span><br></pre></td></tr></table></figure></li></ol><p>以上方案展示了Mockito优雅语法的折衷方案。请注意，这种情况很少见。间谍活动应该是零星的，并且覆盖异常例外非常少见。更不用说总的来说，过度存根是一种潜在的代码气味，它指出了太多的存根。</p></li><li><p><strong>doThrow(Throwable… toBeThrown)</strong></p><p>使用<code>doThrow()</code>时要与存根异常的无效方法。</p><p><a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>对空进行 存根需要的方法与之不同，因为编译器不喜欢方括号内的空方法…</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mock).someVoidMethod();</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><p><code>toBeThrown</code> -调用存根方法时抛出</p></li><li><p>返回值：</p><p>存根-选择存根方法</p></li></ul></li><li><p><strong>doThrow(Class&lt;? extends Throwable&gt; toBeThrown)</strong></p><p>使用<code>doThrow()</code>时要与存根异常的无效方法。</p><p>将为每个方法调用创建一个新的异常实例。</p><p><a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>对空进行 存根需要的方法与之不同，因为编译器不喜欢方括号内的空方法…</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doThrow(RuntimeException.class).when(mock).someVoidMethod();</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><p><code>toBeThrown</code> -调用存根方法时抛出</p></li><li><p>返回值：</p><p>存根-选择存根方法</p></li></ul></li><li><p><strong>doAnswer(Answer answer)</strong></p><p><code>doAnswer()</code>当您想用generic对无效方法进行存根时使用<a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/stubbing/Answer.html"><code>Answer</code></a>。</p><p><a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html#when-T-"><code>when(Object)</code></a>对空进行 存根需要的方法与之不同，因为编译器不喜欢方括号内的空方法…</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        Mock mock = invocation.getMock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">.when(mock).someMethod();</span><br></pre></td></tr></table></figure><p>请参阅Javadoc中的<a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html"><code>Mockito</code></a>类示例</p><ul><li><p>参数：</p><p><code>answer</code> -在调用存根方法时回答</p></li><li><p>返回值：</p><p>存根-选择存根方法</p></li></ul></li><li><p><strong>doNothing（）</strong></p><p>使用<code>doNothing()</code>设置无效的方法什么也不做。<strong>注意，默认情况下，模拟上的void方法什么也不做！</strong> 但是，在少数情况下，doNothing（）会派上用场：</p><ol><li><p>取消对void方法的连续调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doNothing().</span><br><span class="line">doThrow(<span class="keyword">new</span> RuntimeException())</span><br><span class="line">.when(mock).someVoidMethod();</span><br><span class="line">     </span><br><span class="line"><span class="comment">//does nothing the first time:</span></span><br><span class="line">mock.someVoidMethod();</span><br><span class="line">     </span><br><span class="line"><span class="comment">//throws RuntimeException the next time:</span></span><br><span class="line">mock.someVoidMethod();</span><br></pre></td></tr></table></figure></li><li><p>当您监视真实对象并且您希望void方法不执行任何操作时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//let&#x27;s make clear() do nothing</span></span><br><span class="line">doNothing().when(spy).clear();</span><br><span class="line">     </span><br><span class="line">spy.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//clear() does nothing, so the list still contains &quot;one&quot;</span></span><br><span class="line">spy.clear();</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>doCallRealMethod（）</strong></p><p>使用<code>doCallRealMethod()</code>时要调用真正执行的方法。</p><p>像往常一样，您将阅读<strong>部分模拟警告</strong>：面向对象的编程通过将复杂度划分为单独的，特定的SRPy对象来解决复杂度问题。部分模拟如何适应这种范例？好吧，事实并非如此……部分模拟通常意味着复杂性已移至同一对象的不同方法。在大多数情况下，这不是您设计应用程序的方式。</p><p>但是，在少数情况下，局部模拟会派上用场：处理您无法轻松更改的代码（第三方接口，遗留代码的临时重构等）。但是，我不会将局部模拟用于新的，测试驱动的以及设计的代码。</p><p>另请参见javadoc <a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html#spy-T-"><code>spy(Object)</code></a>以了解有关部分模拟的更多信息。 <strong>Mockito.spy（）是创建部分模拟的推荐方法。</strong> 原因是它保证针对正确构造的对象调用真实方法，因为您负责构造传递给spy（）方法的对象。</p><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo mock = mock(Foo.class);</span><br><span class="line">doCallRealMethod().when(mock).someVoidMethod();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// this will call the real implementation of Foo.someVoidMethod()</span></span><br><span class="line">mock.someVoidMethod();</span><br></pre></td></tr></table></figure><p>请参阅Javadoc中的<a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html"><code>Mockito</code></a>类示例</p><ul><li><p>返回值：</p><p>存根-选择存根方法</p></li></ul></li></ul><h5 id="13-监控真实对象"><a href="#13-监控真实对象" class="headerlink" title="13.  监控真实对象"></a>13. 监控真实对象</h5><p>你可以为真实对象创建一个监控(spy)对象。当你使用这个spy对象时真实的对象也会也调用，除非它的函数被stub了。尽量少使用spy对象，使用时也需要小心形式，例如spy对象可以用来处理遗留代码。</p><p>监控一个真实的对象可以与“局部mock对象”概念结合起来。在1.8之前，mockito的监控功能并不是真正的局部mock对象。原因是我们认为局部mock对象的实现方式并不好，在某些时候我发现一些使用局部mock对象的合法用例。（第三方接口、临时重构遗留代码，完整的文章在<a target="_blank" rel="noopener" href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring/">这里</a> ）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以为某些函数打桩</span></span><br><span class="line">when(spy.size()).thenReturn(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 通过spy对象调用真实对象的函数</span></span><br><span class="line">spy.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">spy.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出第一个元素</span></span><br><span class="line">System.out.println(spy.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 因为size()函数被打桩了,因此这里返回的是100</span></span><br><span class="line">System.out.println(spy.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交互验证</span></span><br><span class="line">verify(spy).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">verify(spy).add(<span class="string">&quot;two&quot;</span>);</span><br></pre></td></tr></table></figure><p>理解监控真实对象非常重要！</p><p>有时，在监控对象上使用<code>when(Object)</code>来进行打桩是不可能或者不切实际的。因此，当使用监控对象时请考虑<code>doReturn|Answer|Throw()</code>函数族来进行打桩。例如 :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可能 : 因为当调用spy.get(0)时会调用真实对象的get(0)函数,此时会发生IndexOutOfBoundsException异常，因为真实List对象是空的</span></span><br><span class="line">   when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你需要使用doReturn()来打桩</span></span><br><span class="line">doReturn(<span class="string">&quot;foo&quot;</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Mockito并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。</p><p>因此结论就是 : 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。</p><h5 id="14-修改没有测试桩的调用的默认返回值"><a href="#14-修改没有测试桩的调用的默认返回值" class="headerlink" title="14. 修改没有测试桩的调用的默认返回值"></a>14. 修改没有测试桩的调用的默认返回值</h5><p>你可以指定策略来创建mock对象的返回值。这是一个高级特性，通常来说，你不需要写这样的测试。然后，它对于遗留系统来说是很有用处的。当你不需要为函数调用打桩时你可以指定一个默认的answer。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);</span><br><span class="line">Foo mockTwo = mock(Foo.class, <span class="keyword">new</span> YourOwnAnswer());</span><br></pre></td></tr></table></figure><p>关于RETURNS_SMART_NULLS更多的信息请查看 : <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#RETURNS_SMART_NULLS">RETURNS_SMART_NULLS文档</a> 。</p><h5 id="15-为下一步的断言捕获参数"><a href="#15-为下一步的断言捕获参数" class="headerlink" title="15. 为下一步的断言捕获参数"></a>15. 为下一步的断言捕获参数</h5><p>Mockito以java代码风格的形式来验证参数值 : 即通过使用<code>equals()</code>函数。这也是我们推荐用于参数匹配的方式，因为这样会使得测试代码更简单、简洁。在某些情况下，当验证交互之后要检测真实的参数值时这将变得有用。例如 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);</span><br><span class="line"><span class="comment">// 参数捕获</span></span><br><span class="line">verify(mock).doSomething(argument.capture());</span><br><span class="line"><span class="comment">// 使用equal断言</span></span><br><span class="line">assertEquals(<span class="string">&quot;John&quot;</span>, argument.getValue().getName());</span><br></pre></td></tr></table></figure><p>警告 : 我们建议使用没有测试桩的ArgumentCaptor来验证，因为使用含有测试桩的ArgumentCaptor会降低测试代码的可读性，因为captor是在断言代码块之外创建的。另一个好处是它可以降低本地化的缺点，因为如果测试桩函数没有被调用，那么参数就不会被捕获。总之，ArgumentCaptor与自定义的参数匹配器相关(可以查看<a target="_blank" rel="noopener" href="https://github.com/hehonghui/mockito-doc-zh/blob/master/ArgumentMatcher">ArgumentMatcher类的文档</a> )。这两种技术都能用于检测外部传递到Mock对象的参数。然而，使用ArgumentCaptor在以下的情况下更合适 :</p><ul><li>自定义不能被重用的参数匹配器</li><li>你仅需要断言参数值</li></ul><p>自定义参数匹配器相关的资料你可以参考<a target="_blank" rel="noopener" href="https://github.com/hehonghui/mockito-doc-zh/blob/master/ArgumentMatcher">ArgumentMatcher</a>文档。</p><p>更多示例和API请看官方文档——Mockito<a target="_blank" rel="noopener" href="https://javadoc.io/static/org.mockito/mockito-core/3.2.4/org/mockito/Mockito.html">文档</a></p><h4 id="2-3-5-使用Mockito"><a href="#2-3-5-使用Mockito" class="headerlink" title="2.3.5-使用Mockito"></a>2.3.5-使用Mockito</h4><h5 id="1-模拟抛出异常"><a href="#1-模拟抛出异常" class="headerlink" title="1. 模拟抛出异常"></a>1. 模拟抛出异常</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IOException.class)</span><span class="comment">//期望报IO异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">when_thenThrow</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      OutputStream mock = Mockito.mock(OutputStream.class);</span><br><span class="line">      <span class="comment">//预设当流关闭时抛出异常</span></span><br><span class="line">      Mockito.doThrow(<span class="keyword">new</span> IOException()).when(mock).close();</span><br><span class="line">      mock.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="2-使用默认Answer模拟对象"><a href="#2-使用默认Answer模拟对象" class="headerlink" title="2. 使用默认Answer模拟对象"></a>2. 使用默认Answer模拟对象</h5><p>RETURNS_DEEP_STUBS 是创建mock对象时的备选参数之一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a=Mockito.mock(A.class,Mockito.RETURNS_DEEP_STUBS);</span><br><span class="line">    Mockito.when(a.getB().getName()).thenReturn(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Beijing&quot;</span>,a.getB().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a=Mockito.mock(A.class);</span><br><span class="line">    B b=Mockito.mock(B.class);</span><br><span class="line">    Mockito.when(a.getB()).thenReturn(b);</span><br><span class="line">    Mockito.when(b.getName()).thenReturn(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Beijing&quot;</span>,a.getB().getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">(Integer sex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sex==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;woman&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-参数匹配"><a href="#3-参数匹配" class="headerlink" title="3. 参数匹配"></a>3. 参数匹配</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">with_arguments</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b = Mockito.mock(B.class);</span><br><span class="line">    <span class="comment">//预设根据不同的参数返回不同的结果</span></span><br><span class="line">    Mockito.when(b.getSex(<span class="number">1</span>)).thenReturn(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    Mockito.when(b.getSex(<span class="number">2</span>)).thenReturn(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;男&quot;</span>, b.getSex(<span class="number">1</span>));</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;女&quot;</span>, b.getSex(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//对于没有预设的情况会返回默认值</span></span><br><span class="line">    Assert.assertEquals(<span class="keyword">null</span>, b.getSex(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">(Integer sex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sex==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;woman&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-匹配任意参数"><a href="#4-匹配任意参数" class="headerlink" title="4. 匹配任意参数"></a>4. 匹配任意参数</h5><p><code>Mockito.anyInt()</code> 任何 int 值 ；<br><code>Mockito.anyLong()</code> 任何 long 值 ；<br><code>Mockito.anyString()</code> 任何 String 值 ；</p><p><code>Mockito.any(XXX.class)</code> 任何 XXX 类型的值 等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">with_unspecified_arguments</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = Mockito.mock(List.class);</span><br><span class="line">    <span class="comment">//匹配任意参数</span></span><br><span class="line">    Mockito.when(list.get(Mockito.anyInt())).thenReturn(<span class="number">1</span>);</span><br><span class="line">    Mockito.when(list.contains(Mockito.argThat(<span class="keyword">new</span> IsValid()))).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,list.get(<span class="number">1</span>));</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,list.get(<span class="number">999</span>));</span><br><span class="line">    Assert.assertTrue(list.contains(<span class="number">1</span>));</span><br><span class="line">    Assert.assertTrue(!list.contains(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsValid</span> <span class="keyword">extends</span> <span class="title">ArgumentMatcher</span>&lt;<span class="title">List</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.equals(<span class="number">1</span>) || obj.equals(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：使用了参数匹配，那么所有的参数都必须通过matchers来匹配</em><br>Mockito继承Matchers，anyInt()等均为Matchers方法<br>当传入两个参数，其中一个参数采用任意参数时，指定参数需要matchers来对比</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator comparator = mock(Comparator.class);</span><br><span class="line">comparator.compare(<span class="string">&quot;nihao&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//如果你使用了参数匹配，那么所有的参数都必须通过matchers来匹配</span></span><br><span class="line">Mockito.verify(comparator).compare(Mockito.anyString(),Mockito.eq(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="comment">//下面的为无效的参数匹配使用</span></span><br><span class="line"><span class="comment">//verify(comparator).compare(anyString(),&quot;hello&quot;);</span></span><br></pre></td></tr></table></figure><h5 id="5-自定义参数匹配"><a href="#5-自定义参数匹配" class="headerlink" title="5. 自定义参数匹配"></a>5. 自定义参数匹配</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">argumentMatchersTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//创建mock对象</span></span><br><span class="line">   List&lt;String&gt; mock = mock(List.class);</span><br><span class="line">   <span class="comment">//argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。</span></span><br><span class="line">   Mockito.when(mock.addAll(Mockito.argThat(<span class="keyword">new</span> IsListofTwoElements()))).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">   Assert.assertTrue(mock.addAll(Arrays.asList(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsListofTwoElements</span> <span class="keyword">extends</span> <span class="title">ArgumentMatcher</span>&lt;<span class="title">List</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Object list)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>((List)list).size()==<span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-预期回调接口生成期望值"><a href="#6-预期回调接口生成期望值" class="headerlink" title="6. 预期回调接口生成期望值"></a>6. 预期回调接口生成期望值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List mockList = Mockito.mock(List.class);</span><br><span class="line">      <span class="comment">//使用方法预期回调接口生成期望值（Answer结构）</span></span><br><span class="line">      Mockito.when(mockList.get(Mockito.anyInt())).thenAnswer(<span class="keyword">new</span> CustomAnswer());</span><br><span class="line">      Assert.assertEquals(<span class="string">&quot;hello world:0&quot;</span>,mockList.get(<span class="number">0</span>));</span><br><span class="line">      Assert.assertEquals(<span class="string">&quot;hello world:999&quot;</span>,mockList.get(<span class="number">999</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAnswer</span> <span class="keyword">implements</span> <span class="title">Answer</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          Object[] args = invocation.getArguments();</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello world:&quot;</span>+args[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">等价于：(也可使用匿名内部类实现)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answer_with_callback</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//使用Answer来生成我们我们期望的返回</span></span><br><span class="line">      Mockito.when(mockList.get(Mockito.anyInt())).thenAnswer(<span class="keyword">new</span> Answer&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              Object[] args = invocation.getArguments();</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;hello world:&quot;</span>+args[<span class="number">0</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      Assert.assertEquals(<span class="string">&quot;hello world:0&quot;</span>,mockList.get(<span class="number">0</span>));</span><br><span class="line">     Assert. assertEquals(<span class="string">&quot;hello world:999&quot;</span>,mockList.get(<span class="number">999</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="7-预期回调接口生成期望值（直接执行）"><a href="#7-预期回调接口生成期望值（直接执行）" class="headerlink" title="7. 预期回调接口生成期望值（直接执行）"></a>7. 预期回调接口生成期望值（直接执行）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnswer1</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; mock = Mockito.mock(List.class);  </span><br><span class="line">      Mockito.doAnswer(<span class="keyword">new</span> CustomAnswer()).when(mock).get(Mockito.anyInt());  </span><br><span class="line">      Assert.assertEquals(<span class="string">&quot;大于三&quot;</span>, mock.get(<span class="number">4</span>));</span><br><span class="line">      Assert.assertEquals(<span class="string">&quot;小于三&quot;</span>, mock.get(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAnswer</span> <span class="keyword">implements</span> <span class="title">Answer</span>&lt;<span class="title">String</span>&gt; </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">      Object[] args = invocation.getArguments();  </span><br><span class="line">      Integer num = (Integer)args[<span class="number">0</span>];  </span><br><span class="line">      <span class="keyword">if</span>( num&gt;<span class="number">3</span> )&#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;大于三&quot;</span>;  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;小于三&quot;</span>;   </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-修改对未预设的调用返回默认期望（指定返回值）"><a href="#8-修改对未预设的调用返回默认期望（指定返回值）" class="headerlink" title="8. 修改对未预设的调用返回默认期望（指定返回值）"></a>8. 修改对未预设的调用返回默认期望（指定返回值）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mock对象使用Answer来对未预设的调用返回默认期望值</span></span><br><span class="line">List mock = Mockito.mock(List.class,<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">999</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//下面的get(1)没有预设，通常情况下会返回NULL，但是使用了Answer改变了默认期望值</span></span><br><span class="line"> Assert.assertEquals(<span class="number">999</span>, mock.get(<span class="number">1</span>));</span><br><span class="line"> <span class="comment">//下面的size()没有预设，通常情况下会返回0，但是使用了Answer改变了默认期望值</span></span><br><span class="line"> Assert.assertEquals(<span class="number">999</span>,mock.size());</span><br></pre></td></tr></table></figure><h5 id="9-用spy监控真实对象-设置真实对象行为"><a href="#9-用spy监控真实对象-设置真实对象行为" class="headerlink" title="9. 用spy监控真实对象,设置真实对象行为"></a>9. 用spy监控真实对象,设置真实对象行为</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = IndexOutOfBoundsException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spy_on_real_objects</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    List spy = Mockito.spy(list);</span><br><span class="line">    <span class="comment">//下面预设的spy.get(0)会报错，因为会调用真实对象的get(0)，所以会抛出越界异常</span></span><br><span class="line">    <span class="comment">//Mockito.when(spy.get(0)).thenReturn(3);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用doReturn-when可以避免when-thenReturn调用真实对象api</span></span><br><span class="line">    Mockito.doReturn(<span class="number">999</span>).when(spy).get(<span class="number">999</span>);</span><br><span class="line">    <span class="comment">//预设size()期望值</span></span><br><span class="line">    Mockito.when(spy.size()).thenReturn(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//调用真实对象的api</span></span><br><span class="line">    spy.add(<span class="number">1</span>);</span><br><span class="line">    spy.add(<span class="number">2</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">100</span>,spy.size());</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,spy.get(<span class="number">0</span>));</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>,spy.get(<span class="number">1</span>));</span><br><span class="line">    Assert.assertEquals(<span class="number">999</span>,spy.get(<span class="number">999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-不做任何返回"><a href="#10-不做任何返回" class="headerlink" title="10. 不做任何返回"></a>10. 不做任何返回</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = Mockito.mock(A.class);</span><br><span class="line">    <span class="comment">//void 方法才能调用doNothing()</span></span><br><span class="line">    Mockito.doNothing().when(a).setName(Mockito.anyString());</span><br><span class="line">    a.setName(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;bb&quot;</span>,a.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="11-调用真实的方法"><a href="#11-调用真实的方法" class="headerlink" title="11. 调用真实的方法"></a>11. 调用真实的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = Mockito.mock(A.class);</span><br><span class="line">    <span class="comment">//void 方法才能调用doNothing()</span></span><br><span class="line">    Mockito.when(a.getName()).thenReturn(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;bb&quot;</span>,a.getName());</span><br><span class="line">    <span class="comment">//等价于Mockito.when(a.getName()).thenCallRealMethod();</span></span><br><span class="line">    Mockito.doCallRealMethod().when(a).getName();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;zhangsan&quot;</span>,a.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12-重置-mock"><a href="#12-重置-mock" class="headerlink" title="12. 重置 mock"></a>12. 重置 mock</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset_mock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = mock(List.class);</span><br><span class="line">    Mockito. when(list.size()).thenReturn(<span class="number">10</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">10</span>,list.size());</span><br><span class="line">    <span class="comment">//重置mock，清除所有的互动和预设</span></span><br><span class="line">    Mockito.reset(list);</span><br><span class="line">    Assert.assertEquals(<span class="number">0</span>,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="13-Mock-注解"><a href="#13-Mock-注解" class="headerlink" title="13. @Mock 注解"></a>13. <code>@Mock</code> 注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> List mockList;</span><br><span class="line">    <span class="comment">//必须在基类中添加初始化mock的代码，否则报错mock的对象为NULL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockitoTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AnnoTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mockList.add(<span class="number">1</span>);</span><br><span class="line">        Mockito.verify(mockList).add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="14-指定测试类使用运行器：MockitoJUnitRunner"><a href="#14-指定测试类使用运行器：MockitoJUnitRunner" class="headerlink" title="14. 指定测试类使用运行器：MockitoJUnitRunner"></a>14. 指定测试类使用运行器：MockitoJUnitRunner</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> List mockList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shorthand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mockList.add(<span class="number">1</span>);</span><br><span class="line">        Mockito.verify(mockList).add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-6-MockBean"><a href="#2-3-6-MockBean" class="headerlink" title="2.3.6-@MockBean"></a>2.3.6-<code>@MockBean</code></h4><p>使用 <code>@MockBean</code> 可以解决单元测试中的一些依赖问题，示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceWithMockBeanTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    SampleDependencyA dependencyA;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SampleService sampleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        when(dependencyA.getExternalValue(anyString())).thenReturn(<span class="string">&quot;mock val: A&quot;</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;mock val: A&quot;</span>, sampleService.foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@MockBean</code> 只能 mock 本地的代码——或者说是自己写的代码，对于储存在库中而且又是以 Bean 的形式装配到代码中的类无能为力。</p><p><code>@SpyBean</code> 解决了 SpringBoot 的单元测试中 <code>@MockBean</code> 不能 mock 库中自动装配的 Bean 的局限</p><p>参考自：</p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ecbd7b5a2021">https://www.jianshu.com/p/ecbd7b5a2021</a></p><p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/292626">https://www.imooc.com/article/292626</a></p><h4 id="2-3-8-在-SpringBoot-单元测试中使用-Mockito"><a href="#2-3-8-在-SpringBoot-单元测试中使用-Mockito" class="headerlink" title="2.3.8-在 SpringBoot 单元测试中使用 Mockito"></a>2.3.8-<strong>在 SpringBoot 单元测试中使用 Mockito</strong></h4><p>首先在 pom.xml 下新增 spring-boot-starter-test 依赖，该依赖内就有包含了 JUnit、Mockito。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先写好一个 UserService，他里面有两个方法 getUserById() 和 insertUser()，而他们会分别去再去调用 UserDao 这个 bean的 getUserById() 和 insertUser() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;        </span><br><span class="line">	<span class="meta">@Autowired</span>    </span><br><span class="line">	<span class="keyword">private</span> UserDao userDao;   </span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">return</span> userDao.getUserById(id);    </span><br><span class="line">	&#125;    </span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;        </span><br><span class="line">		<span class="keyword">return</span> userDao.insertUser(user);    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User Model 的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> Integer id;   </span><br><span class="line">  <span class="keyword">private</span> String name;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这时候我们先不使用 Mockito 模拟一个假的 userDao Bean，而是真的去调用一个正常的 Spring Bean 的 userDao 的话，测试类写法如下。其实就是很普通的注入 userService Bean，然后去调用他的方法，而他会再去调用 userDao 取得数据库的数据，然后我们再对返回结果做 Assert 断言检查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;    </span><br><span class="line">  <span class="comment">//先普通的注入一个userService bean    </span></span><br><span class="line">  <span class="meta">@Autowired</span>    </span><br><span class="line">  <span class="keyword">private</span> UserService userService;    </span><br><span class="line">  <span class="meta">@Test</span>    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">    <span class="comment">//普通的使用userService，他里面会再去调用userDao取得数据库的数据       </span></span><br><span class="line">    User user = userService.getUserById(<span class="number">1</span>);                </span><br><span class="line">    <span class="comment">//检查结果        </span></span><br><span class="line">    Assert.assertNotNull(user);        </span><br><span class="line">    Assert.assertEquals(user.getId(), <span class="keyword">new</span> Integer(<span class="number">1</span>));      </span><br><span class="line">    Assert.assertEquals(user.getName(), <span class="string">&quot;John&quot;</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果 userDao 还没写好，又想先测 userService 的话，就需要使用 Mockito 去模拟一个假的 userDao 出来。</p><p>使用方法是在 userDao 上加上一个 @MockBean 注解，当 userDao 被加上这个注解之后，表示 Mockito 会帮我们创建一个假的 Mock 对象，替换掉 Spring 中已存在的那个真实的 userDao Bean，也就是说，注入进 userService 的 userDao Bean，已经被我们替换成假的 Mock 对象了，所以当我们再次调用 userService 的方法时，会去调用的实际上是 mock userDao Bean 的方法，而不是真实的 userDao Bean。</p><p>当我们创建了一个假的 userDao 后，我们需要为这个 mock userDao 自定义方法的返回值，这里有一个公式用法，下面这段代码的意思为，当调用了某个 Mock 对象的方法时，就回传我们想要的自定义结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when( 对象.方法名() ).thenReturn( 自定义结果 )</span><br></pre></td></tr></table></figure><p>使用 Mockito 模拟 Bean 的单元测试具体实例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line">publicclass UserServiceTest &#123;       </span><br><span class="line">  <span class="meta">@Autowired</span>    </span><br><span class="line">  <span class="keyword">private</span> UserService userService;        </span><br><span class="line">  <span class="meta">@MockBean</span>   </span><br><span class="line">  <span class="keyword">private</span> UserDao userDao;    </span><br><span class="line">  <span class="meta">@Test</span>    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">    <span class="comment">// 定义当调用mock userDao的getUserById()方法，并且参数为3时，就返回id为200、name为I&#x27;m mock3的user对象       </span></span><br><span class="line">    Mockito.when(userDao.getUserById(<span class="number">3</span>)).thenReturn(<span class="keyword">new</span> User(<span class="number">200</span>, <span class="string">&quot;I&#x27;m mock 3&quot;</span>));             		<span class="comment">// 返回的会是名字为I&#x27;m mock 3的user对象        </span></span><br><span class="line">    User user = userService.getUserById(<span class="number">1</span>);        </span><br><span class="line">    Assert.assertNotNull(user);        </span><br><span class="line">    Assert.assertEquals(user.getId(), <span class="keyword">new</span> Integer(<span class="number">200</span>));       </span><br><span class="line">    Assert.assertEquals(user.getName(), <span class="string">&quot;I&#x27;m mock 3&quot;</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mockito 除了最基本的 Mockito.when( 对象.方法名() ).thenReturn( 自定义结果 )，还提供了其他用法让我们使用。</p><h5 id="1-thenReturn-系列方法"><a href="#1-thenReturn-系列方法" class="headerlink" title="1. thenReturn 系列方法"></a>1. thenReturn 系列方法</h5><p>当使用任何整数值调用 userService 的 getUserById() 方法时，就回传一个名字为 I’m mock3 的 User 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(userService.getUserById(Mockito.anyInt())).thenReturn(<span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;I&#x27;m mock&quot;</span>));</span><br><span class="line">User user1 = userService.getUserById(<span class="number">3</span>); <span class="comment">// 回传的user的名字为I&#x27;m mock</span></span><br><span class="line">User user2 = userService.getUserById(<span class="number">200</span>); <span class="comment">// 回传的user的名字也为I&#x27;m mock</span></span><br></pre></td></tr></table></figure><p>限制只有当参数的数字是 3 时，才会回传名字为 I’m mock 3 的 user 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(userService.getUserById(<span class="number">3</span>)).thenReturn(<span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;I&#x27;m mock&quot;</span>));</span><br><span class="line">User user1 = userService.getUserById(<span class="number">3</span>); <span class="comment">// 回传的user的名字为I&#x27;m mock</span></span><br><span class="line">User user2 = userService.getUserById(<span class="number">200</span>); <span class="comment">// 回传的user为null</span></span><br></pre></td></tr></table></figure><p>当调用 userService 的 insertUser() 方法时，不管传进来的 user 是什么，都回传 100。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(userService.insertUser(Mockito.any(User.class))).thenReturn(<span class="number">100</span>);</span><br><span class="line">Integer i = userService.insertUser(<span class="keyword">new</span> User()); <span class="comment">//会返回100</span></span><br></pre></td></tr></table></figure><ol start="2"><li><h5 id="thenThrow-系列方法"><a href="#thenThrow-系列方法" class="headerlink" title="thenThrow 系列方法"></a>thenThrow 系列方法</h5></li></ol><p>当调用 userService 的 getUserById() 时的参数是 9 时，抛出一个 RuntimeException。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(userService.getUserById(<span class="number">9</span>)).thenThrow(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;mock throw exception&quot;</span>));</span><br><span class="line">User user = userService.getUserById(<span class="number">9</span>); <span class="comment">//会抛出一个RuntimeException</span></span><br></pre></td></tr></table></figure><p>如果方法没有返回值的话（即是方法定义为 public void myMethod() {…}），要改用 doThrow() 抛出 Exception。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.doThrow(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;mock throw exception&quot;</span>)).when(userService).print();</span><br><span class="line">userService.print(); <span class="comment">//会抛出一个RuntimeException</span></span><br></pre></td></tr></table></figure><h5 id="3-verify-系列方法"><a href="#3-verify-系列方法" class="headerlink" title="3. verify 系列方法"></a>3. verify 系列方法</h5><p>检查调用 userService 的 getUserById()、且参数为3的次数是否为1次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.verify(userService, Mockito.times(<span class="number">1</span>)).getUserById(Mockito.eq(<span class="number">3</span>)) ;</span><br></pre></td></tr></table></figure><p>验证调用顺序，验证 userService 是否先调用 getUserById() 两次，并且第一次的参数是 3、第二次的参数是 5，然后才调用insertUser() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InOrder inOrder = Mockito.inOrder(userService);</span><br><span class="line">inOrder.verify(userService).getUserById(<span class="number">3</span>);</span><br><span class="line">inOrder.verify(userService).getUserById(<span class="number">5</span>);</span><br><span class="line">inOrder.verify(userService).insertUser(Mockito.any(User.class));</span><br></pre></td></tr></table></figure><h4 id="2-3-8-在项目中使用Mockito"><a href="#2-3-8-在项目中使用Mockito" class="headerlink" title="2.3.8-在项目中使用Mockito"></a>2.3.8-在项目中使用Mockito</h4><ul><li><p><strong>创建一个service</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">web</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServiceImpl</span> <span class="keyword">implements</span> <span class="title">WebService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">web</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WebServiceImpl 运行成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebService webService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebResponse&lt;String&gt; <span class="title">ping</span><span class="params">(<span class="meta">@RequestBody</span> WebRequest webRequest)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用service</span></span><br><span class="line">        String str = webService.web(webRequest.getMobile());</span><br><span class="line"></span><br><span class="line">        WebResponse&lt;String&gt; response = <span class="keyword">new</span> WebResponse&lt;&gt;();</span><br><span class="line">        response.setBody(str);</span><br><span class="line">        response.setCode(<span class="string">&quot;00000&quot;</span>);</span><br><span class="line">        response.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建测试用例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebControllerIT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext mac;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> WebService webService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ping</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        doReturn(<span class="string">&quot;Mockito WebServiceImpl 运行完成&quot;</span>).when(webService).web(anyString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求的json</span></span><br><span class="line">        String json = <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;王五\&quot;,\&quot;mobile\&quot;:\&quot;12345678901\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//perform,执行一个RequestBuilders请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理</span></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders</span><br><span class="line">                <span class="comment">//构造一个post请求</span></span><br><span class="line">                .post(<span class="string">&quot;/web/create&quot;</span>)</span><br><span class="line">                <span class="comment">//json类型</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                <span class="comment">//使用writeValueAsString()方法来获取对象的JSON字符串表示</span></span><br><span class="line">                .content(json))</span><br><span class="line">                <span class="comment">//andExpect，添加ResultMathcers验证规则，验证控制器执行完成后结果是否正确，【这是一个断言】</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().is(<span class="number">200</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                <span class="comment">//使用jsonPaht验证返回的json中code字段的返回值</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.code&quot;</span>).value(<span class="string">&quot;00000&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.message&quot;</span>).value(<span class="string">&quot;成功&quot;</span>))</span><br><span class="line">                <span class="comment">//body属性不为空</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.body&quot;</span>).isNotEmpty())</span><br><span class="line">                <span class="comment">//添加ResultHandler结果处理器，比如调试时 打印结果(print方法)到控制台</span></span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                <span class="comment">//返回相应的MvcResult</span></span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，我们新增了一个<code>webService</code>，并增加了<code>@MockBean</code>注解，表示将<code>webService</code>给mock调，这样我们就可以增加自己想要得<code>webService</code>返回结果。<br>在测试用例中我们增加了<code>doReturn()</code>方法，这段代码的含义是当调用<code>WebService</code>中的<code>web()</code>方法时（<code>anyString()</code>表示传入<code>web()</code>方法中的参数是任意的String类型，当然还有个<code>anyInt()</code>等方法），返回<code>Mockito WebServiceImpl 运行完成</code>。当然你也可以不将<code>WebService</code>给mock掉，这样拿到的就是正常的返回值。</p></li></ul><h4 id="2-3-9-Mockito的限制"><a href="#2-3-9-Mockito的限制" class="headerlink" title="2.3.9-Mockito的限制"></a>2.3.9-Mockito的限制</h4><p>上述就是 Mockito 的 Mock 对象使用方法，不过当使用 Mockito 在 Mock 对象时，有一些限制需要遵守：</p><ul><li>不能 Mock 静态方法</li><li>不能 Mock private 方法</li><li>不能 Mock final class</li></ul><p>Mockito不能实现对对静态函数、构造函数、私有函数、Final 函数以及系统函数的模拟。</p><p>因此在写代码时，需要做良好的功能拆分，才能够使用 Mockito 的 Mock 技术，帮助我们降低测试时 Bean 的耦合度。</p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4-总结"></a>2.4-总结</h3><p>Mockito 是一个非常强大的框架，可以在执行单元测试时帮助我们模拟一个 Bean，提高单元测试的稳定性。</p><p>并且大家可以尝试在写代码时，从 Mock 测试的角度来写，更能够写出功能切分良好的代码架构，像是如果有把专门和外部服务沟通的代码抽出来成一个 Bean，在进行单元测试时，只要透过 Mockito 更换掉那个 Bean 就行了。</p><h2 id="3-EasyMock"><a href="#3-EasyMock" class="headerlink" title="3-EasyMock"></a>3-EasyMock</h2><h3 id="3-1-EasyMock简介"><a href="#3-1-EasyMock简介" class="headerlink" title="3.1-EasyMock简介"></a>3.1-EasyMock简介</h3><p>手动的构造 Mock 对象会给开发人员带来额外的编码量，而且这些为创建 Mock 对象而编写的代码很有可能引入错误。目前，有许多开源项目对动态构建 Mock 对象提供了支持，这些项目能够根据现有的接口或类动态生成，这样不仅能避免额外的编码工作，同时也降低了引入错误的可能。</p><p>EasyMock 是一套用于通过简单的方法对于给定的接口生成 Mock 对象的类库。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。通过 EasyMock，我们可以方便的构造 Mock 对象从而使单元测试顺利进行。</p><p><strong>EasyMock</strong>官方文档：<a target="_blank" rel="noopener" href="http://easymock.org/user-guide.html">http://easymock.org/user-guide.html</a></p><h3 id="3-2-EasyMock的使用"><a href="#3-2-EasyMock的使用" class="headerlink" title="3.2-EasyMock的使用"></a>3.2-EasyMock的使用</h3><h4 id="3-2-1-添加pom依赖"><a href="#3-2-1-添加pom依赖" class="headerlink" title="3.2.1-添加pom依赖"></a>3.2.1-添加pom依赖</h4><p>EasyMock在Maven中央存储库中可用。只需将以下依赖项添加到您的pom.xml中：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.easymock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easymock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-被测试的对象"><a href="#3-2-2-被测试的对象" class="headerlink" title="3.2.2-被测试的对象"></a>3.2.2-被测试的对象</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String getUserName(String userId)</span><br><span class="line">    &#123;</span><br><span class="line">        User user = userDao.select(userId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == user)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;offline_&quot;</span> + user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中UserService依赖UserDao接口的实现</p><h4 id="3-2-3-测试代码"><a href="#3-2-3-测试代码" class="headerlink" title="3.2.3-测试代码"></a>3.2.3-测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:CommonUtils.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaoMock = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> User userMock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建mock对象</span></span><br><span class="line">        userDaoMock = EasyMock.createMock(UserDao.class);</span><br><span class="line">        userMock = EasyMock.createMock(User.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mock对象注入被测对象</span></span><br><span class="line">        Field userDaoField = userService.getDeclaredField(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDaoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        userDaoField.set(userService,userDaoMock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置mock对象的期望值</span></span><br><span class="line">        EasyMock.expect(userMock.getName()).andReturn(<span class="string">&quot;testName&quot;</span>);</span><br><span class="line">        EasyMock.expect(userDaoMock.select(<span class="string">&quot;1&quot;</span>)).andReturn(userMock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mock对象的replay</span></span><br><span class="line">        EasyMock.replay(userMock);</span><br><span class="line">        EasyMock.replay(userDaoMock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        Assert.assertTrue(userService.getUserName(<span class="string">&quot;1&quot;</span>).equals(<span class="string">&quot;offline_testName&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证mock对象是否被调用</span></span><br><span class="line">        EasyMock.verify(userMock);</span><br><span class="line">        EasyMock.verify(userDaoMock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        userDaoMock = <span class="keyword">null</span>;</span><br><span class="line">        userMock = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据官方文档，mock的todolist有：</p><ol><li>创建模拟</li><li>将其设置为经过测试的课程</li><li>记录我们期望的模拟操作</li><li>告诉所有模拟我们正在进行实际测试</li><li>测试</li><li>确保应调用的所有内容均已调用</li></ol><p>我们范例中对应是：</p><p>1.使用EasyMock生成Mock对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userDaoMock = EasyMock.createMock(UserDao.class);</span><br><span class="line">userMock = EasyMock.createMock(User.class);</span><br></pre></td></tr></table></figure><p>2.Mock对象注入被测对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field userDaoField = userService.getDeclaredField(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">userDaoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">userDaoField.set(userService,userDaoMock);</span><br></pre></td></tr></table></figure><p>3.设定Mock对象的预期行为和输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EasyMock.expect(userMock.getName()).andReturn(<span class="string">&quot;testName&quot;</span>);</span><br><span class="line">EasyMock.expect(userDaoMock.select(<span class="string">&quot;1&quot;</span>)).andReturn(userMock);</span><br></pre></td></tr></table></figure><p>4.将Mock对象切换到Replay状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EasyMock.replay(userMock);</span><br><span class="line">EasyMock.replay(userDaoMock);</span><br></pre></td></tr></table></figure><p>5.调用Mock对象方法进行单元测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertTrue(userService.getUserName(<span class="string">&quot;1&quot;</span>).equals(<span class="string">&quot;offline_testName&quot;</span>));</span><br></pre></td></tr></table></figure><p>6.确定mock对象有被调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EasyMock.verify(userMock);</span><br><span class="line">EasyMock.verify(userDaoMock);</span><br></pre></td></tr></table></figure><h3 id="3-3-EasyMock进阶"><a href="#3-3-EasyMock进阶" class="headerlink" title="3.3-EasyMock进阶"></a>3.3-EasyMock进阶</h3><h4 id="1-使用注解"><a href="#1-使用注解" class="headerlink" title="1. 使用注解"></a>1. 使用注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:CommonUtils.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">private</span> EasyMockRule mocks = <span class="keyword">new</span> EasyMockRule(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMocksControl iMocksControl = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaoMock = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> User userMock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestSubject</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>1.mock对象会被注入到userService对象中，@Mock是需要创建的mock对象，@TestSubject是被测类</p><p>2.如果没有下面这段代码设置Junit的rule，需要将测试类的Runner设置为@RunWith(EasyMockRunner.class)，当你希望使用别的runner类，但是又需要EasyMock的注解时，使用Junit的rule进行扩展</p><p>``@Rule<code>private EasyMockRule mocks = new EasyMockRule(this);</code></p><h4 id="2-使用IMocksControl管理多个mock对象"><a href="#2-使用IMocksControl管理多个mock对象" class="headerlink" title="2. 使用IMocksControl管理多个mock对象"></a>2. 使用IMocksControl管理多个mock对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:CommonUtils.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMocksControl iMocksControl = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDaoMock = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> User userMock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建mock对象</span></span><br><span class="line">        iMocksControl = EasyMock.createControl();</span><br><span class="line">        userDaoMock = iMocksControl.createMock(UserDao.class);</span><br><span class="line">        userMock = iMocksControl.createMock(User.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mock对象注入被测对象</span></span><br><span class="line">        Field userDaoField = userService.getDeclaredField(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDaoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        userDaoField.set(userService,userDaoMock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置mock对象的期望值</span></span><br><span class="line">        EasyMock.expect(userMock.getName()).andReturn(<span class="string">&quot;testName&quot;</span>);</span><br><span class="line">        EasyMock.expect(userDaoMock.select(<span class="string">&quot;1&quot;</span>)).andReturn(userMock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mock对象的replay</span></span><br><span class="line">        iMocksControl.replay();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        Assert.assertTrue(userService.getUserName(<span class="string">&quot;1&quot;</span>).equals(<span class="string">&quot;offline_testName&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证mock对象是否被调用</span></span><br><span class="line">        iMocksControl.verify();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        userDaoMock = <span class="keyword">null</span>;</span><br><span class="line">        userMock = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-设定-Mock-对象的预期行为和输出"><a href="#3-设定-Mock-对象的预期行为和输出" class="headerlink" title="3. 设定 Mock 对象的预期行为和输出"></a>3. 设定 Mock 对象的预期行为和输出</h4><p>使用 EasyMock 动态构建 <code>ResultSet</code> 接口的 Mock 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet mockResultSet = createMock(ResultSet.class);</span><br></pre></td></tr></table></figure><p>其中 <code>createMock</code> 是 <code>org.easymock.EasyMock</code> 类所提供的静态方法，你可以通过 static import 将其引入。</p><p>如果需要在相对复杂的测试用例中使用多个 Mock 对象，EasyMock 提供了另外一种生成和管理 Mock 对象的机制：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IMocksControl control = EasyMock.createControl();</span><br><span class="line">java.sql.Connection mockConnection = control.createMock(Connection.class);</span><br><span class="line">java.sql.Statement mockStatement = control.createMock(Statement.class);</span><br><span class="line">java.sql.ResultSet mockResultSet = control.createMock(ResultSet.class);</span><br></pre></td></tr></table></figure><p><code>EasyMock</code> 类的 <code>createControl</code> 方法能创建一个接口 <code>IMocksControl</code> 的对象，该对象能创建并管理多个 Mock 对象。如果需要在测试中使用多个 Mock 对象，我们推荐您使用这一机制，因为它在多个 Mock 对象的管理上提供了相对便捷的方法。</p><p>在一个完整的测试过程中，一个 Mock 对象将会经历两个状态：Record 状态和 Replay 状态。Mock 对象一经创建，它的状态就被置为 Record。在 Record 状态，用户可以设定 Mock 对象的预期行为和输出，这些对象行为被录制下来，保存在 Mock 对象中。</p><p>添加 Mock 对象行为的过程通常可以分为以下3步：</p><ul><li>对 Mock 对象的特定方法作出调用；</li><li>通过 <code>org.easymock.EasyMock</code> 提供的静态方法 <code>expectLastCall</code> 获取上一次方法调用所对应的 IExpectationSetters 实例；</li><li>通过 <code>IExpectationSetters</code> 实例设定 Mock 对象的预期输出。</li></ul><p><strong>设定预期返回值</strong></p><p>Mock 对象的行为可以简单的理解为 Mock 对象方法的调用和方法调用所产生的输出。在 EasyMock 2.3 中，对 Mock 对象行为的添加和设置是通过接口 <code>IExpectationSetters</code> 来实现的。Mock 对象方法的调用可能产生两种类型的输出：</p><ul><li><p>产生返回值；</p></li><li><p>抛出异常。</p></li></ul><p>接口 <code>IExpectationSetters</code> 提供了多种设定预期输出的方法，其中和设定返回值相对应的是 andReturn 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">IExpectationSetters&lt;T&gt; <span class="title">andReturn</span><span class="params">(T value)</span></span>;</span><br></pre></td></tr></table></figure><p>我们仍然用 <code>ResultSet</code> 接口的 Mock 对象为例，如果希望方法 <code>mockResult.getString(1)</code> 的返回值为 “My return value”，那么你可以使用以下的语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mockResultSet.getString(<span class="number">1</span>);</span><br><span class="line">expectLastCall().andReturn(<span class="string">&quot;My return value&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上的语句表示 <code>mockResultSet</code> 的 <code>getString</code> 方法被调用一次，这次调用的返回值是 “My return value”。有时，我们希望某个方法的调用总是返回一个相同的值，为了避免每次调用都为 Mock 对象的行为进行一次设定，我们可以用设置默认返回值的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andStubReturn</span><span class="params">(Object value)</span></span>;</span><br></pre></td></tr></table></figure><p>假设我们创建了 <code>Statement</code> 和 <code>ResultSet</code> 接口的 Mock 对象 mockStatement 和 mockResultSet，在测试过程中，我们希望 mockStatement 对象的 <code>executeQuery</code> 方法总是返回 mockResultSet，我们可以使用如下的语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mockStatement.executeQuery(<span class="string">&quot;SELECT * FROM sales_order_table&quot;</span>);</span><br><span class="line">expectLastCall().andStubReturn(mockResultSet);</span><br></pre></td></tr></table></figure><p>EasyMock 在对参数值进行匹配时，默认采用 <code>Object.equals()</code> 方法。因此，如果我们以 <code>&quot;select * from sales_order_table&quot;</code> 作为参数，预期方法将不会被调用。如果您希望上例中的 SQL 语句能不区分大小写，可以用特殊的参数匹配器来解决这个问题，我们将在 “在 EasyMock 中使用参数匹配器” 一章对此进行说明。</p><p><strong>设定预期异常抛出</strong></p><p>对象行为的预期输出除了可能是返回值外，还有可能是抛出异常。<code>IExpectationSetters</code> 提供了设定预期抛出异常的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IExpectationSetters&lt;``T``&gt; andThrow(Throwable throwable);</span><br></pre></td></tr></table></figure><p>和设定默认返回值类似，<code>IExpectationSetters</code> 接口也提供了设定抛出默认异常的函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andStubThrow</span><span class="params">(Throwable throwable)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>设定预期方法调用次数</strong></p><p>通过以上的函数，您可以对 Mock 对象特定行为的预期输出进行设定。除了对预期输出进行设定，<code>IExpectationSetters</code> 接口还允许用户对方法的调用次数作出限制。在 <code>IExpectationSetters</code> 所提供的这一类方法中，常用的一种是 <code>times</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IExpectationSetters&lt;T&gt;times(<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure><p>该方法可以 Mock 对象方法的调用次数进行确切的设定。假设我们希望 mockResultSet 的 <code>getString</code> 方法在测试过程中被调用3次，期间的返回值都是 “My return value”，我们可以用如下语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mockResultSet.getString(<span class="number">1</span>);</span><br><span class="line">expectLastCall().andReturn(<span class="string">&quot;My return value&quot;</span>).times(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意到 <code>andReturn</code> 和 <code>andThrow</code> 方法的返回值依然是一个 <code>IExpectationSetters</code> 实例，因此我们可以在此基础上继续调用 <code>times</code> 方法。</p><p>除了设定确定的调用次数，<code>IExpectationSetters</code> 还提供了另外几种设定非准确调用次数的方法：<br><code>times(int minTimes, int maxTimes)</code>：该方法最少被调用 minTimes 次，最多被调用 maxTimes 次。<br><code>atLeastOnce()</code>：该方法至少被调用一次。<br><code>anyTimes()</code>：该方法可以被调用任意次。</p><p>某些方法的返回值类型是 void，对于这一类方法，我们无需设定返回值，只要设置调用次数就可以了。以 <code>ResultSet</code> 接口的 <code>close</code> 方法为例，假设在测试过程中，该方法被调用3至5次：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mockResultSet.close();``expectLastCall().times(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>为了简化书写，EasyMock 还提供了另一种设定 Mock 对象行为的语句模式。对于上例，您还可以将它写成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expect(mockResult.close()).times(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这个语句和上例中的语句功能是完全相同的。</p><h4 id="4-将-Mock-对象切换到-Replay-状态"><a href="#4-将-Mock-对象切换到-Replay-状态" class="headerlink" title="4. 将 Mock 对象切换到 Replay 状态"></a>4. 将 Mock 对象切换到 Replay 状态</h4><p>在生成 Mock 对象和设定 Mock 对象行为两个阶段，Mock 对象的状态都是 Record 。在这个阶段，Mock 对象会记录用户对预期行为和输出的设定。</p><p>在使用 Mock 对象进行实际的测试前，我们需要将 Mock 对象的状态切换为 Replay。在 Replay 状态，Mock 对象能够根据设定对特定的方法调用作出预期的响应。将 Mock 对象切换成 Replay 状态有两种方式，您需要根据 Mock 对象的生成方式进行选择。如果 Mock 对象是通过 <code>org.easymock.EasyMock</code> 类提供的静态方法 createMock 生成的（第1节中介绍的第一种 Mock 对象生成方法），那么 <code>EasyMock</code> 类提供了相应的 replay 方法用于将 Mock 对象切换为 Replay 状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">replay(mockResultSet);</span><br></pre></td></tr></table></figure><p>如果 Mock 对象是通过 <code>IMocksControl</code> 接口提供的 <code>createMock</code> 方法生成的（第1节中介绍的第二种Mock对象生成方法），那么您依旧可以通过 <code>IMocksControl</code> 接口对它所创建的所有 Mock 对象进行切换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">control.replay();</span><br></pre></td></tr></table></figure><p>以上的语句能将在第3节中生成的 mockConnection、mockStatement 和 mockResultSet 等3个 Mock 对象都切换成 Replay 状态。</p><h4 id="5-对-Mock-对象的行为进行验证"><a href="#5-对-Mock-对象的行为进行验证" class="headerlink" title="5. 对 Mock 对象的行为进行验证"></a>5. 对 Mock 对象的行为进行验证</h4><p>在利用 Mock 对象进行实际的测试过程之后，我们还有一件事情没有做：对 Mock 对象的方法调用的次数进行验证。</p><p>为了验证指定的方法调用真的完成了，我们需要调用 <code>verify</code> 方法进行验证。和 <code>replay</code> 方法类似，您需要根据 Mock 对象的生成方式来选用不同的验证方式。如果 Mock 对象是由 <code>org.easymock.EasyMock</code> 类提供的 <code>createMock</code> 静态方法生成的，那么我们同样采用 <code>EasyMock</code> 类的静态方法 <code>verify</code> 进行验证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">verify(mockResultSet);</span><br></pre></td></tr></table></figure><p>如果Mock对象是有 <code>IMocksControl</code> 接口所提供的 <code>createMock</code> 方法生成的，那么采用该接口提供的 <code>verify</code> 方法，例如第3节中的 <code>IMocksControl</code> 实例 control：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">control.verify();</span><br></pre></td></tr></table></figure><h4 id="6-Mock-对象的重用"><a href="#6-Mock-对象的重用" class="headerlink" title="6. Mock 对象的重用"></a>6. Mock 对象的重用</h4><p>为了避免生成过多的 Mock 对象，EasyMock 允许对原有 Mock 对象进行重用。要对 Mock 对象重新初始化，我们可以采用 reset 方法。和 replay 和 verify 方法类似，EasyMock 提供了两种 reset 方式：</p><ul><li><p>如果 Mock 对象是由 <code>org.easymock.EasyMock</code> 类中的静态方法 <code>createMock</code> 生成的，那么该 Mock 对象的可以用 <code>EasyMock</code> 类的静态方法 <code>reset</code> 重新初始化；</p></li><li><p>如果 Mock 方法是由 <code>IMocksControl</code> 实例的 <code>createMock</code> 方法生成的，那么该 <code>IMocksControl</code> 实例方法 <code>reset</code> 的调用将会把所有该实例创建的 Mock 对象重新初始化。</p></li></ul><p>在重新初始化之后，Mock 对象的状态将被置为 Record 状态。</p><h4 id="7-EasyMock-预定义的参数匹配器"><a href="#7-EasyMock-预定义的参数匹配器" class="headerlink" title="7. EasyMock 预定义的参数匹配器"></a>7. EasyMock 预定义的参数匹配器</h4><p>在使用 Mock 对象进行实际的测试过程中，EasyMock 会根据方法名和参数来匹配一个预期方法的调用。EasyMock 对参数的匹配默认使用 <code>equals()</code> 方法进行比较。这可能会引起一些问题。例如在上一章节中创建的mockStatement对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mockStatement.executeQuery(<span class="string">&quot;SELECT * FROM sales_order_table&quot;</span>);</span><br><span class="line">expectLastCall().andStubReturn(mockResultSet);</span><br></pre></td></tr></table></figure><p>在实际的调用中，我们可能会遇到 SQL 语句中某些关键字大小写的问题，例如将 SELECT 写成 Select，这时在实际的测试中，EasyMock 所采用的默认匹配器将认为这两个参数不匹配，从而造成 Mock 对象的预期方法不被调用。EasyMock 提供了灵活的参数匹配方式来解决这个问题。如果您对 mockStatement 具体执行的语句并不关注，并希望所有输入的字符串都能匹配这一方法调用，您可以用 <code>org.easymock.EasyMock</code> 类所提供的 <code>anyObject</code> 方法来代替参数中的 SQL 语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mockStatement.executeQuery( anyObject() );</span><br><span class="line">expectLastCall().andStubReturn(mockResultSet);</span><br></pre></td></tr></table></figure><p><code>anyObject</code> 方法表示任意输入值都与预期值相匹配。除了 <code>anyObject</code> 以外，EasyMock还提供了多个预先定义的参数匹配器，其中比较常用的一些有：</p><ul><li><code>aryEq(X value)</code>：通过<code>Arrays.equals()</code>进行匹配，适用于数组对象；</li><li><code>isNull()</code>：当输入值为Null时匹配；</li><li><code>notNull()</code>：当输入值不为Null时匹配；</li><li><code>same(X value)</code>：当输入值和预期值是同一个对象时匹配；</li><li><code>lt(X value), leq(X value), geq(X value), gt(X value)</code>：当输入值小于、小等于、大等于、大于预期值时匹配，适用于数值类型；</li><li><code>startsWith(String prefix), contains(String substring), endsWith(String suffix)</code>：当输入值以预期值开头、包含预期值、以预期值结尾时匹配，适用于String类型；</li><li><code>matches(String regex)</code>：当输入值与正则表达式匹配时匹配，适用于String类型。</li></ul><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4-总结"></a>3.4-总结</h3><p>如果需要在单元测试中构建 Mock 对象来模拟协同模块或一些复杂对象，EasyMock 是一个可以选用的优秀框架。EasyMock 提供了简便的方法创建 Mock 对象：通过定义 Mock 对象的预期行为和输出，你可以设定该 Mock 对象在实际测试中被调用方法的返回值、异常抛出和被调用次数。通过创建一个可以替代现有对象的 Mock 对象，EasyMock 使得开发人员在测试时无需编写自定义的 Mock 对象，从而避免了额外的编码工作和因此引入错误的机会。</p><h2 id="4-JMockit"><a href="#4-JMockit" class="headerlink" title="4-JMockit"></a>4-JMockit</h2><h3 id="4-1-JMockit简介"><a href="#4-1-JMockit简介" class="headerlink" title="4.1-JMockit简介"></a>4.1-JMockit简介</h3><p>JMockit 是用以帮助开发人员编写测试程序的一组工具和API，该项目完全基于 Java 5 SE 的 java.lang.instrument 包开发，内部使用 ASM 库来修改Java的Bytecode。所以他能解决当测试的代码包含了一些静态方法，未实现方法，未实现接口的问题。</p><h3 id="4-2-JMockit的使用"><a href="#4-2-JMockit的使用" class="headerlink" title="4.2-JMockit的使用"></a>4.2-JMockit的使用</h3><h4 id="4-2-1-在Maven-pom-xml配置"><a href="#4-2-1-在Maven-pom-xml配置" class="headerlink" title="4.2.1-在Maven pom.xml配置"></a>4.2.1-在Maven pom.xml配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jmockit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmockit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JUnit4.x及以下用户特别注意事项</strong></p><p>如果你是通过mvn test来运行你的测试程序 , 请确保JMockit的依赖定义出现在JUnit的依赖之前。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先声明jmockit的依赖 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jmockit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmockit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 再声明junit的依赖 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-JMockit的使用"><a href="#4-2-2-JMockit的使用" class="headerlink" title="4.2.2-JMockit的使用"></a>4.2.2-JMockit的使用</h4><h5 id="1-Mock类"><a href="#1-Mock类" class="headerlink" title="1. Mock类"></a>1. Mock类</h5><p>再讲述如何Mock类之前，我们先给出一个普通的类，这个类有static,final,native,private方法。以及一个非static/final/native/private的普通public 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个普通类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnOrdinaryClass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ordinaryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// native方法,返回4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">navtiveMethod</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// private方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用private方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">callPrivateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，讲述2种Mock类的方法</p><ul><li>用Expectations来Mock。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//用Expectations来mock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMockingByExpectationsTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassMockingByExpectation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnOrdinaryClass instanceToRecord = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        <span class="keyword">new</span> Expectations(AnOrdinaryClass.class) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mock静态方法</span></span><br><span class="line">                AnOrdinaryClass.staticMethod();</span><br><span class="line">                result = <span class="number">10</span>;</span><br><span class="line">                <span class="comment">// mock普通方法</span></span><br><span class="line">                instanceToRecord.ordinaryMethod();</span><br><span class="line">                result = <span class="number">20</span>;</span><br><span class="line">                <span class="comment">// mock final方法</span></span><br><span class="line">                instanceToRecord.finalMethod();</span><br><span class="line">                result = <span class="number">30</span>;</span><br><span class="line">                <span class="comment">// native, private方法无法用Expectations来Mock</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        AnOrdinaryClass instance = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        Assert.assertTrue(AnOrdinaryClass.staticMethod() == <span class="number">10</span>);</span><br><span class="line">        Assert.assertTrue(instance.ordinaryMethod() == <span class="number">20</span>);</span><br><span class="line">        Assert.assertTrue(instance.finalMethod() == <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 用Expectations无法mock native方法</span></span><br><span class="line">        Assert.assertTrue(instance.navtiveMethod() == <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 用Expectations无法mock private方法</span></span><br><span class="line">        Assert.assertTrue(instance.callPrivateMethod() == <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@BeforeClass</span>    </span><br><span class="line">    <span class="comment">// 加载AnOrdinaryClass类的native方法的native实现    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadNative</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;    </span><br><span class="line">        JNITools.loadNative();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用MockUp来Mock类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用MockUp来mock类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMockingByMockUpTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AnOrdinaryClass的MockUp类，继承MockUp即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnOrdinaryClassMockUp</span> <span class="keyword">extends</span> <span class="title">MockUp</span>&lt;<span class="title">AnOrdinaryClass</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// Mock静态方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Mock普通方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ordinaryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="comment">// Mock final方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Mock native方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">navtiveMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Mock private方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassMockingByMockUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AnOrdinaryClassMockUp();</span><br><span class="line">        AnOrdinaryClass instance = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        <span class="comment">// 静态方法被mock了</span></span><br><span class="line">        Assert.assertTrue(AnOrdinaryClass.staticMethod() == <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 普通方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.ordinaryMethod() == <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// final方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.finalMethod() == <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// native方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.navtiveMethod() == <span class="number">40</span>);</span><br><span class="line">        <span class="comment">// private方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.callPrivateMethod() == <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@BeforeClass</span>    </span><br><span class="line">    <span class="comment">// 加载AnOrdinaryClass类的native方法的native实现    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadNative</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;    </span><br><span class="line">        JNITools.loadNative();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Mock实例"><a href="#2-Mock实例" class="headerlink" title="2. Mock实例"></a>2. Mock实例</h5><p>在Mock类的章节中，我们知道了如何用Expectations来Mock类。Mock实例的用法基本一样。只需要把Expectations的构造函数参数换成实例即可。</p><p>用Expectations来Mock类与用Expectations来Mock实例的唯一不同就在于，前者影响类的所有实例，而后者只影响某一个实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mock实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceMockingByExpectationsTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInstanceMockingByExpectation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnOrdinaryClass instance = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        <span class="comment">// 直接把实例传给Expectations的构造函数即可Mock这个实例</span></span><br><span class="line">        <span class="keyword">new</span> Expectations(instance) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 尽管这里也可以Mock静态方法，但不推荐在这里写。静态方法的Mock应该是针对类的</span></span><br><span class="line">                <span class="comment">// mock普通方法</span></span><br><span class="line">                instance.ordinaryMethod();</span><br><span class="line">                result = <span class="number">20</span>;</span><br><span class="line">                <span class="comment">// mock final方法</span></span><br><span class="line">                instance.finalMethod();</span><br><span class="line">                result = <span class="number">30</span>;</span><br><span class="line">                <span class="comment">// native, private方法无法用Expectations来Mock</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Assert.assertTrue(AnOrdinaryClass.staticMethod() == <span class="number">1</span>);</span><br><span class="line">        Assert.assertTrue(instance.ordinaryMethod() == <span class="number">20</span>);</span><br><span class="line">        Assert.assertTrue(instance.finalMethod() == <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 用Expectations无法mock native方法</span></span><br><span class="line">        Assert.assertTrue(instance.navtiveMethod() == <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 用Expectations无法mock private方法</span></span><br><span class="line">        Assert.assertTrue(instance.callPrivateMethod() == <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@BeforeClass</span>    </span><br><span class="line">    <span class="comment">// 加载AnOrdinaryClass类的native方法的native实现    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadNative</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;    </span><br><span class="line">        JNITools.loadNative();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-Mock接口"><a href="#3-Mock接口" class="headerlink" title="3. Mock接口"></a>3. Mock接口</h5><p>在讲述如何Mock接口前，我们给出一个普通接口的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个普通的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnOrdinaryInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依然给出2种Mock接口的2种方法。</p><ol><li>用Expectations来Mock</li><li>```java<br>//用Expectations来mock接口<br>public class InterfaceMockingByExpectationsTest {<pre><code>// 通过@Injectable，让JMockit帮我们生成这个接口的实例，
// 一般来说，接口是给类来依赖的，我们给待测试的类加上@Tested，就可以让JMockit做依赖注入。详细见JMockit基础的章节
@Injectable
AnOrdinaryInterface anOrdinaryInterface;

@Test
public void testInterfaceMockingByExpectation() &#123;
    // 录制
    new Expectations() &#123;
        &#123;
            anOrdinaryInterface.method1();
            result = 10;
            anOrdinaryInterface.method2();
            result = 20;
        &#125;
    &#125;;
    Assert.assertTrue(anOrdinaryInterface.method1() == 10);
    Assert.assertTrue(anOrdinaryInterface.method2() == 20);
&#125;
</code></pre>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 用MockUp来Mock</span><br><span class="line">4. ```java</span><br><span class="line">   //用MockUp来mock接口</span><br><span class="line">   public class InterfaceMockingByMockUpTest &#123;</span><br><span class="line">    </span><br><span class="line">       @Test</span><br><span class="line">       public void testInterfaceMockingByMockUp() &#123;</span><br><span class="line">           // 手工通过MockUp创建这个接口的实例</span><br><span class="line">           AnOrdinaryInterface anOrdinaryInterface = new MockUp&lt;AnOrdinaryInterface&gt;(AnOrdinaryInterface.class) &#123;</span><br><span class="line">               // 对方法Mock</span><br><span class="line">               @Mock</span><br><span class="line">               public int method1() &#123;</span><br><span class="line">                   return 10;</span><br><span class="line">               &#125;</span><br><span class="line">    </span><br><span class="line">               @Mock</span><br><span class="line">               public int method2() &#123;</span><br><span class="line">                   return 20;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;.getMockInstance();</span><br><span class="line">    </span><br><span class="line">           Assert.assertTrue(anOrdinaryInterface.method1() == 10);</span><br><span class="line">           Assert.assertTrue(anOrdinaryInterface.method2() == 20);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>显然， 在Mock接口时，使用@Injectable注解API，比使用MockUp更方便。单纯通过MockUp生成接口的某个Mock实例，在实际的测试场景中并没有多大用途，接口就是用来给类依赖的，我们要充分利用JMockit的依赖注入功能。</p><h5 id="4-Mocked模拟方式和"><a href="#4-Mocked模拟方式和" class="headerlink" title="4. @Mocked模拟方式和"></a>4. @Mocked模拟方式和</h5><p>@Mocked模拟，由录制、回放、验证三步骤完成，是对某个类的所有实例的所有方法进行完整的模拟方式。</p><p>@Mocked不仅能修饰一个类，也能修饰接口。@Mocked修饰的类/接口，是告诉JMockit，帮我生成一个Mocked对象，这个对象方法（包含静态方法)返回默认值。</p><ul><li><p>Demo类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJMockit</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span> (locale.equals(Locale.CHINA)) &#123;</span><br><span class="line">            <span class="comment">// 在中国，就说中文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你好世界&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在其它国家，就说英文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JMockit测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJMockitTest</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Mocked</span></span><br><span class="line">    HelloJMockit helloJMockit;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 录制(Record)</span></span><br><span class="line">        <span class="keyword">new</span> Expectations() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                helloJMockit.sayHello();</span><br><span class="line">                <span class="comment">// 期待上述调用的返回是&quot;hello,david&quot;，而不是返回实际返回值</span></span><br><span class="line">                result = <span class="string">&quot;hello david&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 重放(Replay)</span></span><br><span class="line">        String msg = helloJMockit.sayHello();</span><br><span class="line">        Assert.assertTrue(msg.equals(<span class="string">&quot;hello david&quot;</span>));</span><br><span class="line">        <span class="comment">// 验证(Verification)</span></span><br><span class="line">        <span class="keyword">new</span> Verifications() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                helloJMockit.sayHello();</span><br><span class="line">                <span class="comment">// 验证helloJMockit.sayHello()这个方法调用了1次</span></span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法也可以按需写成如下格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello1</span><span class="params">(<span class="meta">@Mocked</span> HelloJMockit helloJMockit)</span> </span>&#123;…&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-Injectable模拟方式和-Tested"><a href="#5-Injectable模拟方式和-Tested" class="headerlink" title="5. @Injectable模拟方式和@Tested"></a>5. @Injectable模拟方式和@Tested</h5><p>@Injectable 也是告诉 JMockit生成一个Mocked对象，但@Injectable只是针对其修饰的实例，而@Mocked是针对其修饰类的所有实例。此外，@Injectable对类的静态方法，构造函数没有影响。因为它只影响某一个实例。</p><p>@Injectable和@Mocked的方式很像，区别是@Injectable仅仅对当前实例进行模拟。</p><p>Mocked与Injectable区别：</p><ul><li>Mocked 注入的依赖，类的所有实例都被mock，record的方法，在replay时，按照record的结果返回；没有record的方法返回默认值。</li><li>Injectable 注入的依赖，只mock指定的实例，record的方法，在replay时，按照record的结果返回；没有record的方法返回默认值。没有mock的实例，调用其原始方法。</li></ul><p>@Tested和@Injectable通常搭配使用。若@Tested的构造函数有参数，则JMockit通过在测试属性、测试参数中查找@Injectable修饰的Mocked对象注入@Tested对象的构造函数来实例化，不然，则用无参构造函数来实例化。</p><p>除了构造函数的注入，JMockit还会通过属性查找的方式，把@Injectable对象注入到@Tested对象中。注入的匹配规则：先类型，再名称(构造函数参数名，类的属性名)。若找到多个可以注入的@Injectable，则选择最优先定义的@Injectable对象。当然，我们的测试程序要尽量避免这种情况出现。因为给哪个测试属性/测试参数加@Injectable，是人为控制的。</p><ul><li><p>订单类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 短信服务类，用于向某用户发短信。</span></span><br><span class="line">    <span class="meta">@Autowired</span> MessageService messageService;</span><br><span class="line">    <span class="comment">// 用户服务类，用于校验某个用户是不是合法用户</span></span><br><span class="line">    <span class="meta">@Autowired</span> UserService userService;</span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">submitOrder</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先校验用户身份</span></span><br><span class="line">        <span class="keyword">if</span> (!userService.check(userId)) &#123;</span><br><span class="line">            <span class="comment">// 用户身份不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下单</span></span><br><span class="line">        <span class="keyword">this</span>.saveOrder(order);<span class="comment">// TODO 逻辑略…</span></span><br><span class="line">        <span class="comment">// 下单完成，给买家发短信</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.messageService.sendMessage(userId, <span class="string">&quot;下单成功&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 短信发送成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestedAndInjectable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Tested修饰的类，表示是我们要测试对象。JMockit会帮我们实例化这个测试对象</span></span><br><span class="line">    <span class="meta">@Tested</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试注入方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubmitOrder</span><span class="params">(<span class="meta">@Injectable</span> MessageService messageService,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@Injectable</span> UserCheckService userCheckService,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="meta">@Injectable</span> Order testOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> testUserId = <span class="number">123l</span>;</span><br><span class="line"><span class="comment">//实例化MessageService,userCheckService，通过OrderService属性，注入对象中;</span></span><br><span class="line">        <span class="keyword">new</span> Expectations() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当向testUserId发短信时，假设都发成功了</span></span><br><span class="line">                messageService.sendMessage(testUserId, anyString);</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 当检验testUserId的身份时，假设该用户都是合法的</span></span><br><span class="line">                userCheckService.check(testUserId);</span><br><span class="line">                result = <span class="keyword">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Order testOrder = <span class="keyword">new</span> Order(<span class="string">&quot;嘟嘟机器人&quot;</span>, <span class="number">996</span>)</span><br><span class="line">        Assert.assertTrue(orderService.submitOrder(testUserId, testOrder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="6-Capturing"><a href="#6-Capturing" class="headerlink" title="6. @Capturing"></a>6. @Capturing</h5><p><code>@Capturing</code>主要用于子类/实现类的Mock, 我们只知道父类或接口时，但我们需要控制它所有子类的行为时，子类可能有多个实现（可能有人工写的，也可能是AOP代理自动生成时），就用<code>@Capturing</code>。</p><h5 id="7-MockUp和-Mock"><a href="#7-MockUp和-Mock" class="headerlink" title="7. MockUp和@Mock"></a>7. MockUp和@Mock</h5><p>这种方式非常简单，直接，很多程序员们都喜欢用，掌握了MockUp和@Mock能帮我们解决大部分的Mock场景。</p><p>案例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockUpTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对Java自带类Calendar的get方法进行定制</span></span><br><span class="line">        <span class="comment">// 只需要把Calendar类传入MockUp类的构造函数即可</span></span><br><span class="line">        <span class="keyword">new</span> MockUp&lt;Calendar&gt;(Calendar.class) &#123;</span><br><span class="line">            <span class="comment">// 想Mock哪个方法，就给哪个方法加上@Mock， 没有@Mock的方法，不受影响</span></span><br><span class="line">            <span class="meta">@Mock</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> unit)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (unit == Calendar.YEAR) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2017</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (unit == Calendar.MONDAY) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 从此Calendar的get方法，就沿用你定制过的逻辑，而不是它原先的逻辑。</span></span><br><span class="line">        Calendar cal = Calendar.getInstance(Locale.FRANCE);</span><br><span class="line">        Assert.assertTrue(cal.get(Calendar.YEAR) == <span class="number">2017</span>);</span><br><span class="line">        Assert.assertTrue(cal.get(Calendar.MONDAY) == <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Calendar的其它方法，不受影响</span></span><br><span class="line">        Assert.assertTrue((cal.getFirstDayOfWeek() == Calendar.MONDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MockUp和@Mock比较适合于一个项目中，用于对一些通用类的Mock，以减少大量重复的new Exceptations代码。</p><p>在实际Mock场景中，我们需要灵活运用JMockit其它的Mock API。让我们的Mock程序简单，高效。</p><p>一个类有多个实例，但只对其中某1个实例进行mock的场景是MockUp和@Mock做不到的，这种时候就需要上述的@Capturing注解了。模拟接口，MockUp不支持，采用@Capturing。</p><h5 id="8-Expectations"><a href="#8-Expectations" class="headerlink" title="8. Expectations"></a>8. <strong>Expectations</strong></h5><p>Expectations的作用主要是用于录制。即录制类/对象的调用，返回值是什么。主要有两种使用方式：</p><ul><li><p>通过引用外部类的Mock对象(@Injectabe,@Mocked,@Capturing)来录制;</p></li><li><p>通过构建函数注入类/对象来录制。</p></li></ul><h5 id="9-Verifications"><a href="#9-Verifications" class="headerlink" title="9. Verifications"></a>9. <strong>Verifications</strong></h5><p>Verifications是用于做验证。验证Mock对象（即@Moked/@Injectable@Capturing修饰的或传入Expectation构造函数的对象)有没有调用过某方法，调用了多少次。</p><p>通常在实际测试程序中，我们更倾向于通过JUnit/TestNG/SpringTest的Assert类对测试结果的验证， 对类的某个方法有没调用，调用多少次的测试场景并不是太多。因此在验证阶段，我们完全可以用JUnit/TestNG/SpringTest的Assert类取代new Verifications()验证代码块。除非，你的测试程序关心类的某个方法有没有调用，调用多少次，你可以使用new Verifications()验证代码块。</p><p><strong>常见用法</strong></p><p>案例类(这个类有public,static,final,private方法)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnOrdinaryClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ordinaryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用private方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">callPrivateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>测试类1（用Expectations来Mock）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMockingByExpectationsTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassMockingByExpectation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AnOrdinaryClass instanceToRecord = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        <span class="keyword">new</span> Expectations(AnOrdinaryClass.class) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mock普通方法</span></span><br><span class="line">                instanceToRecord.ordinaryMethod();</span><br><span class="line">                result = <span class="number">11</span>;</span><br><span class="line">                <span class="comment">// mock静态方法</span></span><br><span class="line">                AnOrdinaryClass.staticMethod();</span><br><span class="line">                result = <span class="number">22</span>;</span><br><span class="line">                <span class="comment">// mock final方法</span></span><br><span class="line">                instanceToRecord.finalMethod();</span><br><span class="line">                result = <span class="number">33</span>;</span><br><span class="line">                <span class="comment">// private方法无法用Expectations来Mock</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        AnOrdinaryClass instance = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        Assert.assertTrue(instance.ordinaryMethod() == <span class="number">11</span>);</span><br><span class="line">        Assert.assertTrue(AnOrdinaryClass.staticMethod() == <span class="number">22</span>);</span><br><span class="line">        Assert.assertTrue(instance.finalMethod() == <span class="number">22</span>);</span><br><span class="line">        <span class="comment">// 用Expectations无法mock private方法</span></span><br><span class="line">        Assert.assertTrue(instance.callPrivateMethod() == <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类2（用MockUp来Mock）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMockingByMockUpTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AnOrdinaryClass的MockUp类，继承MockUp即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnOrdinaryClassMockUp</span> <span class="keyword">extends</span> <span class="title">MockUp</span>&lt;<span class="title">AnOrdinaryClass</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// Mock普通方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ordinaryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Mock静态方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="comment">// Mock final方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">finalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">33</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mock private方法</span></span><br><span class="line">        <span class="meta">@Mock</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassMockingByMockUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AnOrdinaryClassMockUp();</span><br><span class="line">        AnOrdinaryClass instance = <span class="keyword">new</span> AnOrdinaryClass();</span><br><span class="line">        <span class="comment">// 普通方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.ordinaryMethod() == <span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 静态方法被mock了</span></span><br><span class="line">        Assert.assertTrue(AnOrdinaryClass.staticMethod() == <span class="number">22</span>);</span><br><span class="line">        <span class="comment">// final方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.finalMethod() == <span class="number">33</span>);</span><br><span class="line">        <span class="comment">// private方法被mock了</span></span><br><span class="line">        Assert.assertTrue(instance.callPrivateMethod() == <span class="number">44</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3-总结"></a>4.3-总结</h3><p>建议使用MockUp &amp; @Mock方法来写单元测试，JUnit的Assert类对测试结果的验证，并且灵活运用JMockit其它的Mock API。</p><h2 id="5-PowerMock"><a href="#5-PowerMock" class="headerlink" title="5-PowerMock"></a>5-PowerMock</h2><h3 id="5-1-PowerMock简介"><a href="#5-1-PowerMock简介" class="headerlink" title="5.1-PowerMock简介"></a>5.1-PowerMock简介</h3><p>PowerMock是一个框架，它以更强大的功能扩展了其他模拟库，例如EasyMock。PowerMock使用自定义的类加载器和字节码操作来模拟静态方法，构造函数，最终类和方法，私有方法，删除静态初始化程序等。通过使用自定义类加载器，无需对IDE或持续集成服务器进行任何更改，从而简化了采用过程。熟悉受支持的模拟框架的开发人员会发现PowerMock易于使用，因为整个期望API都是相同的，无论是静态方法还是构造函数。PowerMock旨在通过少量方法和注释扩展现有的API，以启用额外的功能。当前，PowerMock支持EasyMock和Mockito。</p><p>在编写单元测试时，绕过封装通常很有用，因此PowerMock包括一些简化了反射的功能，这些反射对于测试特别有用。这样可以轻松访问内部状态，还可以简化部分和私有模拟。</p><p>PowerMock支持JUnit和TestNG，扩展了EasyMock和Mockito框架，增加了mock static、final方法的功能。</p><h3 id="5-2-Mock底层原理"><a href="#5-2-Mock底层原理" class="headerlink" title="5.2-Mock底层原理"></a>5.2-Mock底层原理</h3><ul><li><p>Mockito原理</p><p>Mockito底层使用了动态代理，用到了CGLIB。因此需要被mock的对象，Mockito都会生成一个子类继承该类，这也就是为什么final类、private方法、static方法不可以被Mock的原因</p></li><li><p>PowerMock原理</p><p>PowerMock有两个重要的依赖：javassist和objenesis。</p><p>javassist是一个修改java字节码的工具包，objenesis是一个绕过构造方法来实例化一个对象的工具包。由此看来，PowerMock的本质是通过修改字节码来实现对静态和final等方法的mock的</p><p>下面是PowerMock的简单实现原理：</p><ul><li>当某个测试方法被注解@PrepareForTest标注以后，在运行测试用例时，会创建一个新的org.powermock.core.classloader.MockClassLoader实例，然后加载该测试用例使用到的类（系统类除外）。</li><li>PowerMock会根据你的mock要求，去修改写在注解@PrepareForTest里的class文件（当前测试类会自动加入注解中），以满足特殊的mock需求。例如：去除final方法的final标识，在静态方法的最前面加入自己的虚拟实现等。</li><li>如果需要mock的是系统类的final方法和静态方法，PowerMock不会直接修改系统类的class文件，而是修改调用系统类的class文件，以满足mock需求。</li></ul></li></ul><h3 id="5-3-PowerMock的使用"><a href="#5-3-PowerMock的使用" class="headerlink" title="5.3-PowerMock的使用"></a>5.3-PowerMock的使用</h3><h4 id="5-3-1-添加Maven依赖"><a href="#5-3-1-添加Maven依赖" class="headerlink" title="5.3.1-添加Maven依赖"></a>5.3.1-添加Maven依赖</h4><p>Junit4.4版本及以上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;powermock.version&gt;<span class="number">2.0</span><span class="number">.2</span>&lt;/powermock.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;powermock-<span class="keyword">module</span>-junit4&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;powermock.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.powermock&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;powermock-api-mockito2&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;powermock.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h4 id="5-3-2-PowerMock的API用法"><a href="#5-3-2-PowerMock的API用法" class="headerlink" title="5.3.2-PowerMock的API用法"></a>5.3.2-PowerMock的API用法</h4><h5 id="1-PowerMock注解-RunWith与-PrepareForTest"><a href="#1-PowerMock注解-RunWith与-PrepareForTest" class="headerlink" title="1. PowerMock注解@RunWith与@PrepareForTest"></a>1. PowerMock注解<code>@RunWith</code>与<code>@PrepareForTest</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(RequestUtils.class)</span></span><br></pre></td></tr></table></figure><blockquote><p><code>@RunWith(PowerMockRunner.class)</code>语句告诉JUnit用PowerMockRunner来执行测试。<br><code>@PrepareForTest(RequestUtils.class)</code>语句告诉PowerMock准备RequestUtils类进行测试。适用于模拟final类或有final, private, static, native方法的类<br><code>@PrepareForTest</code>是当使用PowerMock强大的Mock静态、final、private方法时，需要添加的注解。<br>如果测试用例里没有使用注解<code>@PrepareForTest</code>，可以不加注解<code>@RunWith(PowerMockRunner.class)</code>,反之亦然。</p></blockquote><h5 id="2-模拟静态方法"><a href="#2-模拟静态方法" class="headerlink" title="2. 模拟静态方法"></a>2. 模拟静态方法</h5><ul><li><p>如何mock和stub</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PrepareForTest(Static.class)</span> <span class="comment">// Static.class包含静态方法</span></span><br></pre></td></tr></table></figure></li><li><p>调用<code>PowerMockito.mockStatic()</code>以模拟静态类（用于<code>PowerMockito.spy(class)</code>模拟特定方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.mockStatic(Static.class);</span><br></pre></td></tr></table></figure></li><li><p>只需使用Mockito.when()来设置您的期望：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(Static.firstStaticMethod(param)).thenReturn(value);</span><br></pre></td></tr></table></figure></li></ul><p>注意：如果需要模拟java系统/ bootstrap类加载器（在java.lang或java.net等中定义的类）加载的类，则需要使用<a target="_blank" rel="noopener" href="https://github.com/powermock/powermock/wiki/Mock-System">此</a>方法。</p><h6 id="2-1-如何验证行为"><a href="#2-1-如何验证行为" class="headerlink" title="2.1 如何验证行为"></a>2.1 如何验证行为</h6><p>静态方法的验证分两个步骤进行。</p><ol><li>首先调用<code>PowerMockito.verifyStatic(Static.class)</code>以开始验证行为，然后</li><li>调用的静态方法<code>Static.class</code>进行验证。例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.verifyStatic(Static.class); <span class="comment">// 1</span></span><br><span class="line">Static.firstStaticMethod(param); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>重要提示：您需要<code>verifyStatic(Static.class)</code>按方法调用。</p><h6 id="2-2-如何使用参数匹配器"><a href="#2-2-如何使用参数匹配器" class="headerlink" title="2.2 如何使用参数匹配器"></a>2.2 如何使用参数匹配器</h6><p>Mockito匹配器可能仍适用于PowerMock模拟。例如，对每个模拟的静态方法使用自定义参数匹配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.verifyStatic(Static.class);</span><br><span class="line">Static.thirdStaticMethod(Mockito.anyInt());</span><br></pre></td></tr></table></figure><h6 id="2-3-如何验证确切的电话号码"><a href="#2-3-如何验证确切的电话号码" class="headerlink" title="2.3 如何验证确切的电话号码"></a>2.3 如何验证确切的电话号码</h6><p>您仍然可以将Mockito.VerificationMode（例如Mockito.times（x））与结合使用<code>PowerMockito.verifyStatic(Static.class, Mockito.times(2))</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.verifyStatic(Static.class, Mockito.times(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h6 id="2-4-如何将void静态方法存根以引发异常"><a href="#2-4-如何将void静态方法存根以引发异常" class="headerlink" title="2.4 如何将void静态方法存根以引发异常"></a>2.4 如何将void静态方法存根以引发异常</h6><p>如果不是私人的，请执行以下操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.doThrow(<span class="keyword">new</span> ArrayStoreException(<span class="string">&quot;Mock error&quot;</span>)).when(StaticService.class);</span><br><span class="line">StaticService.executeMethod();</span><br></pre></td></tr></table></figure><p>请注意，您可以对最终课程/方法执行相同的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PowerMockito.doThrow(<span class="keyword">new</span> ArrayStoreException(<span class="string">&quot;Mock error&quot;</span>)).when(myFinalMock).myFinalMethod();</span><br></pre></td></tr></table></figure><p>对于私有方法，请使用PowerMockito.when，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">when(tested, <span class="string">&quot;methodToExpect&quot;</span>, argument).thenReturn(myReturnValue);</span><br></pre></td></tr></table></figure><h6 id="2-5-模拟，存根和验证静态方法的完整示例"><a href="#2-5-模拟，存根和验证静态方法的完整示例" class="headerlink" title="2.5 模拟，存根和验证静态方法的完整示例"></a>2.5 模拟，存根和验证静态方法的完整示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(Static.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourTestCase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodThatCallsStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟Static类中的所有静态方法</span></span><br><span class="line">        PowerMockito.mockStatic(Static.class);</span><br><span class="line">        <span class="comment">//使用Mockito设置期望</span></span><br><span class="line">        Mockito.when(Static.firstStaticMethod(param)).thenReturn(value);</span><br><span class="line">        Mockito.when(Static.secondStaticMethod()).thenReturn(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行测试类 </span></span><br><span class="line">        classCallStaticMethodObj.execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//与Mockito不同，始终首先使用PowerMockito.verifyStatic（Class）</span></span><br><span class="line">        <span class="comment">//开始验证行为</span></span><br><span class="line">        PowerMockito.verifyStatic(Static.class, Mockito.times(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//重要提示：调用要验证Static 的static方法</span></span><br><span class="line">        Static.firstStaticMethod(param);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要信息：您需要在每个方法验证中调用verifyStatic（Class）</span></span><br><span class="line">        <span class="comment">//因此再次调用verifyStatic（Class）</span></span><br><span class="line">        PowerMockito.verifyStatic(Static.class); <span class="comment">// default times is once</span></span><br><span class="line">        <span class="comment">//再次调用被验证为</span></span><br><span class="line">        Static.secondStaticMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样，请记住调用verifyStatic（Class）</span></span><br><span class="line">        PowerMockito.verifyStatic(Static.class, Mockito.never());</span><br><span class="line">        <span class="comment">//然后再次调用static方法</span></span><br><span class="line">        Static.thirdStaticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-部分模拟"><a href="#3-部分模拟" class="headerlink" title="3. 部分模拟"></a>3. 部分模拟</h5><p>您可以使用PowerMockito使用PowerMockito.spy来部分模拟方法。请小心（以下内容摘自Mockito文档，同样适用于PowerMockito）：</p><p>有时，无法使用标准<code>when(..)</code>方法对间谍进行打桩。例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> L/您必须使用doReturn（）对进行stubinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"><span class="comment">//不可能的：真正的方法调用，所以spy.get（0）抛出IndexOutOfBoundsException异常（名单又是空的）</span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">/您必须使用doReturn（）对进行<span class="function">stub</span></span><br><span class="line"><span class="function"><span class="title">doReturn</span><span class="params">(<span class="string">&quot;foo&quot;</span>)</span>.<span class="title">when</span><span class="params">(spy)</span>.<span class="title">get</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="4-如何验证行为"><a href="#4-如何验证行为" class="headerlink" title="4. 如何验证行为"></a>4. 如何验证行为</h5><p>只需使用Mockito.vertify（）进行标准验证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.verify(mockObj, times(<span class="number">2</span>)).methodToMock();</span><br></pre></td></tr></table></figure><h5 id="5-如何验证私人行为"><a href="#5-如何验证私人行为" class="headerlink" title="5. 如何验证私人行为"></a>5. 如何验证私人行为</h5><p>使用PowerMockito.verifyPrivate（），例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">verifyPrivate(tested).invoke(<span class="string">&quot;privateMethodName&quot;</span>, argument1);</span><br></pre></td></tr></table></figure><p>这也适用于私有静态方法。</p><h5 id="6-如何模拟新对象的构造"><a href="#6-如何模拟新对象的构造" class="headerlink" title="6. 如何模拟新对象的构造"></a>6. 如何模拟新对象的构造</h5><p>使用PowerMockito.whenNew，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">whenNew(MyClass.class).withNoArguments().thenThrow(<span class="keyword">new</span> IOException(<span class="string">&quot;error message&quot;</span>));</span><br></pre></td></tr></table></figure><p>请注意，您必须准备<em>创建</em><code>MyClass</code>用于测试的新实例的类，而不是其<code>MyClass</code>本身。例如，如果正在执行的类<code>new MyClass()</code>称为X，则必须先进行操作<code>@PrepareForTest(X.class)</code>才能<code>whenNew</code>工作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(X.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XTest</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                whenNew(MyClass.class).withNoArguments().thenThrow(<span class="keyword">new</span> IOException(<span class="string">&quot;error message&quot;</span>));</span><br><span class="line"></span><br><span class="line">                X x = <span class="keyword">new</span> X();</span><br><span class="line">                x.y(); <span class="comment">// y is the method doing &quot;new MyClass()&quot;</span></span><br><span class="line"></span><br><span class="line">                ..</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-如何验证新对象的构造"><a href="#7-如何验证新对象的构造" class="headerlink" title="7. 如何验证新对象的构造"></a>7. 如何验证新对象的构造</h5><p>使用PowerMockito.verifyNew，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">verifyNew(MyClass.class).withNoArguments();</span><br></pre></td></tr></table></figure><h5 id="8-如何使用参数匹配器"><a href="#8-如何使用参数匹配器" class="headerlink" title="8. 如何使用参数匹配器"></a>8. 如何使用参数匹配器</h5><p>Mockito匹配器可能仍适用于PowerMock模拟：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.verify(mockObj).methodToMock(Mockito.anyInt());  </span><br></pre></td></tr></table></figure><h5 id="9-完整的spying实例"><a href="#9-完整的spying实例" class="headerlink" title="9. 完整的spying实例"></a>9. 完整的spying实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="comment">//我们制备用于测试PartialMockClass因为它最终还是我们需要模拟私有或静态方法</span></span><br><span class="line"><span class="meta">@PrepareForTest(PartialMockClass.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourTestCase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spyingWithPowerMock</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        PartialMockClass classUnderTest = PowerMockito.spy(<span class="keyword">new</span> PartialMockClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Mockito设置期望</span></span><br><span class="line">        Mockito.when(classUnderTest.methodToMock()).thenReturn(value);</span><br><span class="line">        <span class="comment">//执行测试</span></span><br><span class="line">        classUnderTest.execute();</span><br><span class="line">        <span class="comment">//使用Mockito.verify（）验证结果</span></span><br><span class="line">        Mockito.verify(mockObj, times(<span class="number">2</span>)).methodToMock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-私有方法的部分模拟的完整示例"><a href="#10-私有方法的部分模拟的完整示例" class="headerlink" title="10. 私有方法的部分模拟的完整示例"></a>10. 私有方法的部分模拟的完整示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="comment">//我们制备用于测试PartialMockClass因为它最终还是我们需要模拟私有或静态方法</span></span><br><span class="line"><span class="meta">@PrepareForTest(PartialMockClass.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourTestCase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">privatePartialMockingWithPowerMock</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        PartialMockClass classUnderTest = PowerMockito.spy(<span class="keyword">new</span> PartialMockClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用PowerMockito设置期望</span></span><br><span class="line">        PowerMockito.doReturn(value).when(classUnderTest, <span class="string">&quot;methodToMock&quot;</span>, <span class="string">&quot;parameter1&quot;</span>);</span><br><span class="line">        <span class="comment">//执行测试</span></span><br><span class="line">        classUnderTest.execute();</span><br><span class="line">        <span class="comment">//使用PowerMockito.verify()验证结果</span></span><br><span class="line">        PowerMockito.verifyPrivate(classUnderTest, times(<span class="number">2</span>)).invoke(<span class="string">&quot;methodToMock&quot;</span>, <span class="string">&quot;parameter1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-3-PowerMock的使用"><a href="#5-3-3-PowerMock的使用" class="headerlink" title="5.3.3-PowerMock的使用"></a>5.3.3-PowerMock的使用</h4><h5 id="1-测试static方法"><a href="#1-测试static方法" class="headerlink" title="1. 测试static方法"></a>1. 测试static方法</h5><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEmployeeCount</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> Employee.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(Employee.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnTheCountOfEmployeesUsingTheDomainClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.when(Employee.count()).thenReturn(<span class="number">900</span>);</span><br><span class="line"> </span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        assertEquals(<span class="number">900</span>, employeeService.getEmployeeCount());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里使用的是mockStatic而不是的mock。</p></li></ul><h5 id="2-测试返回void的静态方法"><a href="#2-测试返回void的静态方法" class="headerlink" title="2. 测试返回void的静态方法"></a>2. 测试返回void的静态方法</h5><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveIncrementOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">giveIncrementToAllEmployeesOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Employee.giveIncrementOf(percentage);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(Employee.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnTrueWhenIncrementOf10PercentageIsGivenSuccessfully</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.doNothing().when(Employee.class);</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">10</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        assertTrue(employeeService.giveIncrementToAllEmployeesOf(<span class="number">10</span>));    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnFalseWhenIncrementOf10PercentageIsNotGivenSuccessfully</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.doThrow(<span class="keyword">new</span> IllegalStateException()).when(Employee.class);</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">10</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        assertFalse(employeeService.giveIncrementToAllEmployeesOf(<span class="number">10</span>));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-PowerMockito-doNothing-与PowerMockito-doThrow"><a href="#3-PowerMockito-doNothing-与PowerMockito-doThrow" class="headerlink" title="3. PowerMockito.doNothing 与PowerMockito.doThrow"></a>3. PowerMockito.doNothing 与PowerMockito.doThrow</h5><blockquote><p><code>PowerMockito.doNothing</code>方法告诉PowerMock下一个方法调用时什么也不做。</p><p><code>PowerMockito.doThrow</code>方法告诉PowerMock下一个方法调用时产生异常。</p></blockquote><p>PowerMock使用自定义类加载器和字节码操作来模拟静态方法。对于实例中没有mock的方法，也有默认返回值，比如返回int类型的方法，默认返回0<br>PowerMockito.doNothing和PowerMockito.doThrow的语法可用于实例方法。</p><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Test()</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldNotDoAnythingIfEmployeeWasSaved</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employee employee = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.doNothing().when(employee).save();</span><br><span class="line">      	<span class="keyword">try</span> &#123;</span><br><span class="line">            employee.save();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            fail(<span class="string">&quot;Should not have thrown an exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Test(expected = IllegalStateException.class)</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldThrowAnExceptionIfEmployeeWasNotSaved</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        Employee employee = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.doThrow(<span class="keyword">new</span> IllegalStateException()).when(employee).save();</span><br><span class="line">        employee.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意这里doThrow和doNothing方法不会对下一行产生影响。</p><h5 id="4-验证方法调用"><a href="#4-验证方法调用" class="headerlink" title="4. 验证方法调用"></a>4. 验证方法调用</h5><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveIncrementOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">      employee.create();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    employee.update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldCreateNewEmployeeIfEmployeeIsNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Employee mock = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.when(mock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        employeeService.saveEmployee(mock);</span><br><span class="line">        Mockito.verify(mock).create();</span><br><span class="line">        Mockito.verify(mock, Mockito.never()).update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Mockito.verify(mock).create()验证调用了create方法。<br>Mockito.verify(mock, Mockito.never()).update();验证没有调用update方法。</p></blockquote><ul><li><p>验证静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvoke_giveIncrementOfMethodOnEmployeeWhileGivingIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.doNothing().when(Employee.class);</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">9</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        employeeService.giveIncrementToAllEmployeesOf(<span class="number">9</span>);</span><br><span class="line">        PowerMockito.verifyStatic();</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-验证调用次数的方法："><a href="#5-验证调用次数的方法：" class="headerlink" title="5. 验证调用次数的方法："></a>5. 验证调用次数的方法：</h5><blockquote><p><code>Mockito.times(int n)</code> : 准确的验证方法调用的次数:n<br><code>Mockito.atLeastOnce()</code> : 验证方法至少调用1次<br><code>Mockito.atLeast(int n)</code> : 验证方法最少调用n次<br><code>Mockito.atMost(int n)</code>: 验证方法最多调用n次<br><code>Mockito.inOrder</code>:验证方法调用的顺序</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvokeIsNewBeforeInvokingCreate</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">      Employee mock = PowerMockito.mock(Employee.class);</span><br><span class="line">      PowerMockito.when(mock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">      EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">      employeeService.saveEmployee(mock);</span><br><span class="line">      InOrder inOrder = Mockito.inOrder(mock);</span><br><span class="line">      inOrder.verify(mock).isNew();</span><br><span class="line">      Mockito.verify(mock).create();</span><br><span class="line">      Mockito.verify(mock, Mockito.never()).update();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>测试final类或方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeIdGenerator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmployeeId</span><span class="params">(<span class="keyword">int</span> nextId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">      employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">      employee.create();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    employee.update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(EmployeeIdGenerator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldGenerateEmployeeIdIfEmployeeIsNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Employee mock = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.when(mock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        PowerMockito.mockStatic(EmployeeIdGenerator.class);</span><br><span class="line">        PowerMockito.when(EmployeeIdGenerator.getNextId()).thenReturn(<span class="number">90</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span></span><br><span class="line">        EmployeeService();</span><br><span class="line">        employeeService.saveEmployee(mock);</span><br><span class="line">        PowerMockito.verifyStatic();</span><br><span class="line">        EmployeeIdGenerator.getNextId();</span><br><span class="line">        Mockito.verify(mock).setEmployeeId(<span class="number">90</span>);</span><br><span class="line">        Mockito.verify(mock).create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="6-测试构造方法"><a href="#6-测试构造方法" class="headerlink" title="6. 测试构造方法"></a>6. 测试构造方法</h5><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeEmail</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WelcomeEmail</span><span class="params">(<span class="keyword">final</span> Employee employee, <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">      employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">      employee.create();</span><br><span class="line">      WelcomeEmail emailSender = <span class="keyword">new</span> WelcomeEmail(employee,</span><br><span class="line"><span class="string">&quot;Welcome to Mocking with PowerMock How-to!&quot;</span>);</span><br><span class="line">      emailSender.send();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    employee.update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">WelcomeEmailTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line">  <span class="meta">@PrepareForTest(&#123;EmployeeIdGenerator.class, EmployeeService.class&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Test</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldSendWelcomeEmailToNewEmployees</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Employee employeeMock =PowerMockito.mock(Employee.class);</span><br><span class="line">            PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">            PowerMockito.mockStatic(EmployeeIdGenerator.class);</span><br><span class="line">            WelcomeEmail welcomeEmailMock = PowerMockito.mock(WelcomeEmail.class);</span><br><span class="line">            PowerMockito.whenNew(WelcomeEmail.class).withArguments(employeeMock, <span class="string">&quot;Welcome&quot;</span>).thenReturn(welcomeEmailMock);</span><br><span class="line">            EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">            employeeService.saveEmployee(employeeMock);</span><br><span class="line"> </span><br><span class="line">            PowerMockito.verifyNew(WelcomeEmail.class).withArguments(employeeMock, <span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">            Mockito.verify(welcomeEmailMock).send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意PowerMockito.verifyNew的第2个参数支持前面提到的验证模式。&gt;<code>PowerMockito.whenNew().withArguments(...).thenReturn()</code>是对构造方法的mock模式<br><code>PowerMockito.verifyNew().withArguments()</code>是验证模式。</p></blockquote><h5 id="7-参数匹配"><a href="#7-参数匹配" class="headerlink" title="7. 参数匹配"></a>7. 参数匹配</h5><blockquote><p>PowerMock使用equals方法验证参数。matcher可更加灵活的处理参数。<br><code>Mockito.eq</code>;<br><code>Mockito.matches</code>;<br><code>Mockito.any</code>(anyBoolean , anyByte , anyShort , anyChar , anyInt ,anyLong , anyFloat , anyDouble , anyList , anyCollection , anyMap , anySet~);<br><code>Mockito.isNull</code>;<br><code>Mockito.isNotNull</code>;<br><code>Mockito.endsWith</code>;<br><code>Mockito.isA</code>;</p></blockquote><h5 id="8-回答"><a href="#8-回答" class="headerlink" title="8. 回答"></a>8. 回答</h5><blockquote><p>在某些边缘的情况下不可能通过简单地通过PowerMockito.when().thenReturn()模拟，这时可以使用Answer接口。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnCountOfEmployeesFromTheServiceWithDefaultAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmployeeService mock = PowerMockito.mock(EmployeeService.class, <span class="keyword">new</span> Answer() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Answer接口指定执行的action和返回值执。<br>Answer的参数是InvocationOnMock的实例，支持：</p><p><code>callRealMethod()</code>：调用真正的方法<br><code>getArguments()</code>：获取所有参数<br><code>getMethod()</code>：返回mock实例调用的方法<br><code>getMock()</code>：获取mock实例</p></blockquote><h5 id="9-spy进行部分模拟"><a href="#9-spy进行部分模拟" class="headerlink" title="9. spy进行部分模拟"></a>9. spy进行部分模拟</h5><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">      createEmployee(employee);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    employee.update();</span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">    employee.create();</span><br><span class="line">    WelcomeEmail emailSender = <span class="keyword">new</span> WelcomeEmail(employee,</span><br><span class="line"><span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">    emailSender.send();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> EmployeeService spy = PowerMockito.spy(<span class="keyword">new</span> EmployeeService());</span><br><span class="line">    <span class="keyword">final</span> Employee employeeMock = PowerMockito.mock(Employee.class);</span><br><span class="line">    PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">    PowerMockito.doNothing().when(spy).createEmployee(employeeMock);</span><br><span class="line">    spy.saveEmployee(employeeMock);</span><br><span class="line">    Mockito.verify(spy).createEmployee(employeeMock);      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>spy只能使用PowerMockito.doNothing()/doReturn()/doThrow()。</p></blockquote></li></ul><h5 id="10-模拟私有方法"><a href="#10-模拟私有方法" class="headerlink" title="10. 模拟私有方法"></a>10. 模拟私有方法</h5><ul><li><p>被测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">    employee.create();</span><br><span class="line">    WelcomeEmail emailSender = <span class="keyword">new</span> WelcomeEmail(employee,</span><br><span class="line"><span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">    emailSender.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>   <span class="title">EmployeeServiceTest</span></span>&#123;</span><br><span class="line">  <span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line">  <span class="meta">@PrepareForTest(&#123;EmployeeIdGenerator.class, EmployeeService.class&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">final</span> EmployeeService spy = PowerMockito.spy(<span class="keyword">new</span> EmployeeService());</span><br><span class="line">      <span class="keyword">final</span> Employee employeeMock = PowerMockito.mock(Employee.class);</span><br><span class="line">      PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">      PowerMockito.doNothing().when(spy, <span class="string">&quot;createEmployee&quot;</span>, employeeMock);</span><br><span class="line">      spy.saveEmployee(employeeMock);</span><br><span class="line">      PowerMockito.verifyPrivate(spy).invoke(<span class="string">&quot;createEmployee&quot;</span>, employeeMock);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>PowerMockito.suppress(PowerMockito.constructor(BaseEntity.class))</code>:表示禁用BaseEntity的构造函数。</p><p><code>PowerMockito.suppress(PowerMockito.constructor(BaseEntity.class, String.class, Integer.class))</code>:后面表示带字符串和整数参数。</p><p><code>PowerMockito.suppress(PowerMockito.method(BaseEntity.class, &quot;performAudit&quot;, String.class))</code>:表示禁用BaseEntity的performAudit方法。</p><p><code>@SuppressStaticInitializationFor(&quot;BaseEntity&quot;)</code>:表示禁用BaseEntity的静态初始化。注意引号部分通常需要全名，如”com.gitshah.powermock.BaseEntity”。</p><p><code>PowerMockito.suppress(PowerMockito.field(BaseEntity.class</code>:identifier”))`：禁用域。</p></blockquote><h2 id="6-SpringBoot整合Junit-Mockito-PowerMock"><a href="#6-SpringBoot整合Junit-Mockito-PowerMock" class="headerlink" title="6-SpringBoot整合Junit+Mockito+PowerMock"></a>6-SpringBoot整合Junit+Mockito+PowerMock</h2><h3 id="6-1-添加依赖"><a href="#6-1-添加依赖" class="headerlink" title="6.1-添加依赖"></a>6.1-添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>powermock-module-junit4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>powermock-api-mockito2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.23.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-UUID加密算法类"><a href="#6-2-UUID加密算法类" class="headerlink" title="6.2-UUID加密算法类"></a>6.2-UUID加密算法类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Encrypt</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 待加密的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> md5 是否先用 md5 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">passwordGenerator</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        password = DigestUtils.md5Hex(password);</span><br><span class="line">        String salt = DigestUtils.sha1Hex(UUID.randomUUID().toString()).substring(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        String saltString = DigestUtils.sha1Hex(password + salt) + salt;</span><br><span class="line">        String encryPassword = Base64.encodeBase64String(saltString.getBytes());</span><br><span class="line">        <span class="keyword">return</span> encryPassword;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，UUID.randomUUID()、DigestUtils.md5Hex()、DigestUtils.sha1Hex()、Base64.encodeBase64String() 均为静态方法，而 uuid.toString() 则为 UUID 实例对象的方法。</p><p>对于 UUID 的 mock，需要两步：</p><p>第一步，是使用 mockito mock 一个 UUID 对象，并 mock 其在代码中使用的方法，这里要 mock 的是 toString() 方法。</p><p>第二步，是使用 powormockito，mock UUID 的 randomUUID() 方法，使其返回上一步 mock 的 uuid 对象，这样我们就能得到预期的 uuid 的方法（这里是 toString）的执行结果。</p><p>DigestUtils 和 Base64 的静态方法直接使用 powermockito 来 mock 就可以。</p><h3 id="6-3-测试类"><a href="#6-3-测试类" class="headerlink" title="6.3-测试类"></a>6.3-测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;UUID.class, DigestUtils.class, Encrypt.class, Base64.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passwordGeneratorWithMd5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String randomString = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">        String salt = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        String rePassword = <span class="string">&quot;654321&quot;</span>;</span><br><span class="line">        String twiceSaltMd5 = <span class="string">&quot;hellomd5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock uuid 对象，使其 toString() 方法返回预定义的 randomString 字符串</span></span><br><span class="line">        UUID uuid = PowerMockito.mock(UUID.class);</span><br><span class="line">        Mockito.when(uuid.toString()).thenReturn(randomString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock UUID 类，使其 randomUUID() 方法返回刚刚 mock 的 uuid 对象</span></span><br><span class="line">        PowerMockito.mockStatic(UUID.class);</span><br><span class="line">        PowerMockito.when(UUID.randomUUID()).thenReturn(uuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock DigestUtils 类，使其 sha1Hex() 方法在接收预定义的 randomString 参数时，返回预定义的 salt 字符串</span></span><br><span class="line">        PowerMockito.mockStatic(DigestUtils.class);</span><br><span class="line">        PowerMockito.when(DigestUtils.sha1Hex(randomString)).thenReturn(salt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使 mock 的 DigestUtils 类的 md5Hex 方法，在接受预定义的 password 时，生成预定义的 rePassword 字符串</span></span><br><span class="line">        PowerMockito.when(DigestUtils.md5Hex(password)).thenReturn(rePassword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使 mock 的 DigestUtils 类的 sha1Hex() 方法在接收预定义的 rePassword 和 salt 时，返回 预定义的 twiceSaltMd5 字符串</span></span><br><span class="line">        PowerMockito.when(DigestUtils.sha1Hex(rePassword + salt)).thenReturn(twiceSaltMd5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock Base64 类，使其encodeBase64String() 方法在接收 预定义的串时，返回预定义的加密后密码</span></span><br><span class="line">        PowerMockito.mockStatic(Base64.class);</span><br><span class="line">        String imencryptpassword = <span class="string">&quot;imencryptpasswordwithmd5&quot;</span>;</span><br><span class="line">        PowerMockito.when(Base64.encodeBase64String((twiceSaltMd5 + salt).getBytes())).thenReturn(imencryptpassword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用加密方法，并验证结果</span></span><br><span class="line">        String encryptPassword = Encrypt.passwordGenerator(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        assertEquals(imencryptpassword, encryptPassword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Mock测试工具对比"><a href="#7-Mock测试工具对比" class="headerlink" title="7-Mock测试工具对比"></a>7-Mock测试工具对比</h2><p>目前，这个级别的mock工具有easymock、jMock、Mockito、Unitils Mock、PowerMock、JMockit等等.<br>关于它们的优劣势在JMockit<a target="_blank" rel="noopener" href="http://rawgit.com/jmockit/jmockit.github.io/e5f649df0276ef561b1b98004914a0cfd0c290bb/MockingToolkitComparisonMatrix.html">官网</a>上给出一个简单的比较，结果如下图所示。这个结果可能会偏向JMockit，我们可以作为参考。</p><table><thead><tr><th><strong>Feature</strong></th><th><a target="_blank" rel="noopener" href="http://easymock.org/"><strong>EasyMock</strong></a></th><th><a target="_blank" rel="noopener" href="http://jmock.org/">jMock</a></th><th><a target="_blank" rel="noopener" href="http://code.google.com/p/mockito">Mockito</a></th><th><a target="_blank" rel="noopener" href="http://www.unitils.org/summary.html">Unitils Mock</a></th><th><a target="_blank" rel="noopener" href="http://code.google.com/p/powermock">PowerMock</a>: <code>EasyMock</code> API</th><th><a target="_blank" rel="noopener" href="http://code.google.com/p/powermock">PowerMock</a>: Mockito API</th><th><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit"><strong>JMock it</strong></a></th></tr></thead><tbody><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#constraints">Invocation count constraints</a>(调用数限制)</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/wiki/MockingToolkitComparisonMatrix#Recording_strict_expectations">Recording strict expectations</a>(记录严格的预期结果）</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/wiki/MockingToolkitComparisonMatrix#Explicit_verification">Explicit verification</a>（显式验证）</td><td></td><td></td><td>√</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#partial">Partial mocking</a>（部分mock）</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/wiki/MockingToolkitComparisonMatrix#No_method_call_to_switch_from_record_to_replay">No method call to switch from record to replay</a>（切换记录回放时无方法调用）</td><td></td><td></td><td>√</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/wiki/MockingToolkitComparisonMatrix#No_extra_code_for_implicit_verification">No extra code for implicit verification</a>（隐式验证没有额外代码）</td><td></td><td></td><td><em>N/A</em></td><td><em>N/A</em></td><td></td><td><em>N/A</em></td><td>√</td></tr><tr><td>No extra “prepare for test” code（没有额外的”prepare for test”代码）</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td></tr><tr><td>No need to use <code>@RunWith</code> annotation or base test class（不需要用@runwith注解和测试基类）</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td>√</td></tr><tr><td>Consistent syntax between <code>void</code> and non-<code>void</code> methods（空和非空方法的语法一致）</td><td></td><td>√</td><td></td><td>√</td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#hamcrest">Argument matchers</a> for some parameters only, not all</td><td></td><td></td><td></td><td>√</td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/wiki/MockingToolkitComparisonMatrix#Easier_argument_matching_based_on_properties_of_value_objects">Easier argument matching based on properties of value objects</a>（基于值对象属性的简化参数匹配）</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/mockit/Cascading.html">Cascading mocks</a>（级联mock）</td><td></td><td></td><td>√</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#multipleInterfaces">Support for mocking multiple interfaces</a>（多接口mock）</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/source/browse/trunk/main/test/mockit/MockedAnnotationsTest.java">Support for mocking annotation types</a>（注释类型mock）</td><td></td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#partiallyOrdered">Partially ordered expectations</a></td><td></td><td>√</td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td>Mocking of constructors and <em>final</em>/<em>static</em>/<em>native</em>/<em>private</em> methods（构造函数、final、static和private方法的mock）</td><td></td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/UsingMocksAndStubs.html">Declarative application of mocks/stubs to whole test classes</a></td><td></td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/mockit/Tested.html">Auto-injection of mocks</a>（mock的自动注入）</td><td></td><td></td><td>√</td><td>√</td><td></td><td>√</td><td>√</td></tr><tr><td>Mocking of “new-ed” objects（“new-ed”对象的mock）</td><td></td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/source/browse/trunk/main/test/mockit/MockedEnumsTest.java">Support for mocking enum types</a></td><td></td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>Declarative mocks for the test class (mock fields)</td><td></td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#declaration">Declarative mocks for test methods (parameters, local fields)</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#matcherFields">Special fields for “any” argument matching</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/mockit/Expectations.html#result">Use of an special field to specify invocation results</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/mockit/Expectations.html#times">Use of special fields to specify invocation count constraints</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/javadoc/mockit/Expectations.html#$">Expectations with custom error messages</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/CapturingImplementations.html">On-demand mocking of unspecified implementation classes</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#capturing">Capture of instances created by code under test</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/BehaviorBasedTesting.html#iterations">Recording &amp; verification of expectations in loops</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://code.google.com/p/jmockit/source/browse/trunk/main/test/mockit/CovariantReturnTypesTest.java">Support for covariant return types</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><a target="_blank" rel="noopener" href="http://jmockit.googlecode.com/svn/trunk/www/tutorial/StateBasedTesting.html">“Duck typing” mocks for state-based tests</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td>Single jar file in the classpath is sufficient to use mocking API（在classpath中的单个jar文件就能够使用mockAPI）</td><td></td><td></td><td>√</td><td></td><td><em>N/A</em></td><td><em>N/A</em></td><td>√</td></tr><tr><td><strong>Total</strong></td><td>6/32</td><td>7/32</td><td>13/31</td><td>11/31</td><td>9/31</td><td>14/30</td><td>32/32</td></tr><tr><td><strong>Total when ignoring JMockit-only features</strong></td><td>6/22</td><td>7/22</td><td>13/21</td><td>11/21</td><td>9/21</td><td>14/20</td><td>22/22</td></tr></tbody></table><p>就目前来讲，是mockit+powermock、JMockit这两种工具使用人数较多。JMockit的功能最为完善，mockit+powermock的用户体验相对较好一点。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/02/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock/">https://lemon-cs.github.io/2020/02/21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a><a class="post-meta__tags" href="/tags/Mock/">Mock</a></div><div class="post_share"><div class="social-share" data-image="https://static01.imgkr.com/temp/7e2ff0bcacb94fe1a60c065dd5773565.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://s4.ax1x.com/2022/02/15/HRSnhQ.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker入门学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/15/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2021/12/7f02b700ddd8d712.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">阿里巴巴Java开发手册详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/01/10/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BJunit/" title="单元测试之Junit"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRptqP.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-10</div><div class="title">单元测试之Junit</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8BMock"><span class="toc-text">单元测试之Mock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Mock%E8%AF%A6%E8%A7%A3"><span class="toc-text">1-Mock详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFMock%EF%BC%9F"><span class="toc-text">1.1-什么是Mock？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Mock%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">1.2-为什么使用Mock对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Mock%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">1.3-Mock测试框架的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Spring-Boot%E7%9A%84%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%BA%93"><span class="toc-text">1.4-Spring Boot的测试类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-MockMvc"><span class="toc-text">1.5-MockMvc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-MockMvc%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-text">1.6-MockMvc测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96"><span class="toc-text">1.6.1. 引入pom依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-MockMVC%E5%9F%BA%E4%BA%8ERESTful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-text">1.6.2. MockMVC基于RESTful风格的测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3-%E5%B8%B8%E7%94%A8API"><span class="toc-text">1.6.3-常用API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Mockito"><span class="toc-text">2-Mockito</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFMockito%EF%BC%9F"><span class="toc-text">2.1-什么是Mockito？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-text">2.2-使用模拟对象进行测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E6%8C%91%E6%88%98"><span class="toc-text">2.2.1-单元测试的目标和挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90"><span class="toc-text">2.2.2-模拟对象生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E4%BD%BF%E7%94%A8Mockito%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.2.3-使用Mockito模拟对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-mock%E5%92%8Cstub"><span class="toc-text">2.2.4-mock和stub</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Mockito%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.3-Mockito的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%BC%95%E5%85%A5pom%E4%BE%9D%E8%B5%96"><span class="toc-text">2.3.1-引入pom依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%B5%8B%E8%AF%95%E7%B1%BB%E4%B8%AD%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-text">2.3.2-测试类中引入静态资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%B8%B8%E7%94%A8%E7%9A%84Mockito%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.3-常用的Mockito方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.3.4-示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E6%9F%90%E4%BA%9B%E8%A1%8C%E4%B8%BA%E7%A1%AE%E5%AE%9E%E5%8F%91%E7%94%9F%E8%BF%87%EF%BC%88%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E8%B0%83%E7%94%A8%E8%BF%87%EF%BC%89"><span class="toc-text">1. 验证某些行为确实发生过（有没有被调用过）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%BA%9B%E6%B5%8B%E8%AF%95%E6%A1%A9%EF%BC%88Stub%EF%BC%89"><span class="toc-text">2. 如何做一些测试桩（Stub）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E5%99%A8%EF%BC%88matchers%EF%BC%89"><span class="toc-text">3. 参数匹配器（matchers）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%AA%8C%E8%AF%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%A1%AE%E5%88%87%E3%80%81%E6%9C%80%E5%B0%91%E3%80%81%E4%BB%8E%E6%9C%AA%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0"><span class="toc-text">4. 验证函数的确切、最少、从未调用次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BAvoid%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%9A%E8%BF%87Stub%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">5. 为返回值为void的函数通过Stub抛出异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%AA%8C%E8%AF%81%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">6. 验证调用执行顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E7%A1%AE%E4%BF%9D%E4%BA%A4%E4%BA%92-interaction-%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%9C%A8mock%E5%AF%B9%E8%B1%A1%E4%B8%8A"><span class="toc-text">7. 确保交互(interaction)操作不会执行在mock对象上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%9F%A5%E6%89%BE%E5%86%97%E4%BD%99%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">8. 查找冗余的调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E7%AE%80%E5%8C%96mock%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">9. 简化mock对象的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E4%B8%BA%E8%BF%9E%E7%BB%AD%E7%9A%84%E8%B0%83%E7%94%A8%E5%81%9A%E6%B5%8B%E8%AF%95%E6%A1%A9-stub"><span class="toc-text">10. 为连续的调用做测试桩 (stub)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%81%9A%E6%B5%8B%E8%AF%95%E6%A1%A9"><span class="toc-text">11. 为回调做测试桩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-doReturn-%E3%80%81doThrow-%E3%80%81doAnswer-%E3%80%81doNothing-%E3%80%81doCallRealMethod-%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">12. doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E7%9B%91%E6%8E%A7%E7%9C%9F%E5%AE%9E%E5%AF%B9%E8%B1%A1"><span class="toc-text">13. 监控真实对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-%E4%BF%AE%E6%94%B9%E6%B2%A1%E6%9C%89%E6%B5%8B%E8%AF%95%E6%A1%A9%E7%9A%84%E8%B0%83%E7%94%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">14. 修改没有测试桩的调用的默认返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-%E4%B8%BA%E4%B8%8B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%96%AD%E8%A8%80%E6%8D%95%E8%8E%B7%E5%8F%82%E6%95%B0"><span class="toc-text">15. 为下一步的断言捕获参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E4%BD%BF%E7%94%A8Mockito"><span class="toc-text">2.3.5-使用Mockito</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9F%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">1. 模拟抛出异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4Answer%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 使用默认Answer模拟对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-text">3. 参数匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8C%B9%E9%85%8D%E4%BB%BB%E6%84%8F%E5%8F%82%E6%95%B0"><span class="toc-text">4. 匹配任意参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-text">5. 自定义参数匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%A2%84%E6%9C%9F%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3%E7%94%9F%E6%88%90%E6%9C%9F%E6%9C%9B%E5%80%BC"><span class="toc-text">6. 预期回调接口生成期望值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E9%A2%84%E6%9C%9F%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3%E7%94%9F%E6%88%90%E6%9C%9F%E6%9C%9B%E5%80%BC%EF%BC%88%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-text">7. 预期回调接口生成期望值（直接执行）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BF%AE%E6%94%B9%E5%AF%B9%E6%9C%AA%E9%A2%84%E8%AE%BE%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E6%9C%9F%E6%9C%9B%EF%BC%88%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%89"><span class="toc-text">8. 修改对未预设的调用返回默认期望（指定返回值）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E7%94%A8spy%E7%9B%91%E6%8E%A7%E7%9C%9F%E5%AE%9E%E5%AF%B9%E8%B1%A1-%E8%AE%BE%E7%BD%AE%E7%9C%9F%E5%AE%9E%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA"><span class="toc-text">9. 用spy监控真实对象,设置真实对象行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E8%BF%94%E5%9B%9E"><span class="toc-text">10. 不做任何返回</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E8%B0%83%E7%94%A8%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">11. 调用真实的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E9%87%8D%E7%BD%AE-mock"><span class="toc-text">12. 重置 mock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-Mock-%E6%B3%A8%E8%A7%A3"><span class="toc-text">13. @Mock 注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-%E6%8C%87%E5%AE%9A%E6%B5%8B%E8%AF%95%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E5%99%A8%EF%BC%9AMockitoJUnitRunner"><span class="toc-text">14. 指定测试类使用运行器：MockitoJUnitRunner</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-6-MockBean"><span class="toc-text">2.3.6-@MockBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-8-%E5%9C%A8-SpringBoot-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E4%BD%BF%E7%94%A8-Mockito"><span class="toc-text">2.3.8-在 SpringBoot 单元测试中使用 Mockito</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-thenReturn-%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95"><span class="toc-text">1. thenReturn 系列方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#thenThrow-%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95"><span class="toc-text">thenThrow 系列方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-verify-%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95"><span class="toc-text">3. verify 系列方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-8-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Mockito"><span class="toc-text">2.3.8-在项目中使用Mockito</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-9-Mockito%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">2.3.9-Mockito的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="toc-text">2.4-总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EasyMock"><span class="toc-text">3-EasyMock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-EasyMock%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1-EasyMock简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-EasyMock%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2-EasyMock的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%B7%BB%E5%8A%A0pom%E4%BE%9D%E8%B5%96"><span class="toc-text">3.2.1-添加pom依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%A2%AB%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2.2-被测试的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">3.2.3-测试代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-EasyMock%E8%BF%9B%E9%98%B6"><span class="toc-text">3.3-EasyMock进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">1. 使用注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8IMocksControl%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAmock%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 使用IMocksControl管理多个mock对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%BE%E5%AE%9A-Mock-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%84%E6%9C%9F%E8%A1%8C%E4%B8%BA%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-text">3. 设定 Mock 对象的预期行为和输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%86-Mock-%E5%AF%B9%E8%B1%A1%E5%88%87%E6%8D%A2%E5%88%B0-Replay-%E7%8A%B6%E6%80%81"><span class="toc-text">4. 将 Mock 对象切换到 Replay 状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AF%B9-Mock-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81"><span class="toc-text">5. 对 Mock 对象的行为进行验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Mock-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%87%8D%E7%94%A8"><span class="toc-text">6. Mock 对象的重用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-EasyMock-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="toc-text">7. EasyMock 预定义的参数匹配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%80%BB%E7%BB%93"><span class="toc-text">3.4-总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JMockit"><span class="toc-text">4-JMockit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-JMockit%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1-JMockit简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-JMockit%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2-JMockit的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%9C%A8Maven-pom-xml%E9%85%8D%E7%BD%AE"><span class="toc-text">4.2.1-在Maven pom.xml配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-JMockit%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2.2-JMockit的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Mock%E7%B1%BB"><span class="toc-text">1. Mock类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Mock%E5%AE%9E%E4%BE%8B"><span class="toc-text">2. Mock实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Mock%E6%8E%A5%E5%8F%A3"><span class="toc-text">3. Mock接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Mocked%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F%E5%92%8C"><span class="toc-text">4. @Mocked模拟方式和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Injectable%E6%A8%A1%E6%8B%9F%E6%96%B9%E5%BC%8F%E5%92%8C-Tested"><span class="toc-text">5. @Injectable模拟方式和@Tested</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Capturing"><span class="toc-text">6. @Capturing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-MockUp%E5%92%8C-Mock"><span class="toc-text">7. MockUp和@Mock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-Expectations"><span class="toc-text">8. Expectations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-Verifications"><span class="toc-text">9. Verifications</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%80%BB%E7%BB%93"><span class="toc-text">4.3-总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-PowerMock"><span class="toc-text">5-PowerMock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-PowerMock%E7%AE%80%E4%BB%8B"><span class="toc-text">5.1-PowerMock简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Mock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">5.2-Mock底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-PowerMock%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5.3-PowerMock的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E6%B7%BB%E5%8A%A0Maven%E4%BE%9D%E8%B5%96"><span class="toc-text">5.3.1-添加Maven依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-PowerMock%E7%9A%84API%E7%94%A8%E6%B3%95"><span class="toc-text">5.3.2-PowerMock的API用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-PowerMock%E6%B3%A8%E8%A7%A3-RunWith%E4%B8%8E-PrepareForTest"><span class="toc-text">1. PowerMock注解@RunWith与@PrepareForTest</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A8%A1%E6%8B%9F%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2. 模拟静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%A1%8C%E4%B8%BA"><span class="toc-text">2.1 如何验证行为</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="toc-text">2.2 如何使用参数匹配器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%A1%AE%E5%88%87%E7%9A%84%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="toc-text">2.3 如何验证确切的电话号码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-%E5%A6%82%E4%BD%95%E5%B0%86void%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AD%98%E6%A0%B9%E4%BB%A5%E5%BC%95%E5%8F%91%E5%BC%82%E5%B8%B8"><span class="toc-text">2.4 如何将void静态方法存根以引发异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-%E6%A8%A1%E6%8B%9F%EF%BC%8C%E5%AD%98%E6%A0%B9%E5%92%8C%E9%AA%8C%E8%AF%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.5 模拟，存根和验证静态方法的完整示例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%83%A8%E5%88%86%E6%A8%A1%E6%8B%9F"><span class="toc-text">3. 部分模拟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%A1%8C%E4%B8%BA"><span class="toc-text">4. 如何验证行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%A7%81%E4%BA%BA%E8%A1%8C%E4%B8%BA"><span class="toc-text">5. 如何验证私人行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E6%96%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-text">6. 如何模拟新对象的构造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E6%96%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-text">7. 如何验证新对象的构造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="toc-text">8. 如何使用参数匹配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%AE%8C%E6%95%B4%E7%9A%84spying%E5%AE%9E%E4%BE%8B"><span class="toc-text">9. 完整的spying实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E9%83%A8%E5%88%86%E6%A8%A1%E6%8B%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-text">10. 私有方法的部分模拟的完整示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-PowerMock%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5.3.3-PowerMock的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B5%8B%E8%AF%95static%E6%96%B9%E6%B3%95"><span class="toc-text">1. 测试static方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E8%BF%94%E5%9B%9Evoid%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2. 测试返回void的静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-PowerMockito-doNothing-%E4%B8%8EPowerMockito-doThrow"><span class="toc-text">3. PowerMockito.doNothing 与PowerMockito.doThrow</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">4. 验证方法调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">5. 验证调用次数的方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%B5%8B%E8%AF%95%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">6. 测试构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-text">7. 参数匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%9B%9E%E7%AD%94"><span class="toc-text">8. 回答</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-spy%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E6%A8%A1%E6%8B%9F"><span class="toc-text">9. spy进行部分模拟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E6%A8%A1%E6%8B%9F%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">10. 模拟私有方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SpringBoot%E6%95%B4%E5%90%88Junit-Mockito-PowerMock"><span class="toc-text">6-SpringBoot整合Junit+Mockito+PowerMock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-text">6.1-添加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-UUID%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%B1%BB"><span class="toc-text">6.2-UUID加密算法类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-text">6.3-测试类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Mock%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94"><span class="toc-text">7-Mock测试工具对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跳表原理及实现"></a><div class="content"><a class="title" href="/2022/02/07/%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现">跳表原理及实现</a><time datetime="2022-02-07T13:19:43.000Z" title="发表于 2022-02-07 21:19:43">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s4.ax1x.com/2022/02/15/HRplPe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2022/01/17/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2022-01-17T14:09:50.000Z" title="发表于 2022-01-17 22:09:50">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/" title="Go语言基础之反射"><img src="https://s4.ax1x.com/2022/02/15/HRSa9J.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之反射"></a><div class="content"><a class="title" href="/2022/01/04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/" title="Go语言基础之反射">Go语言基础之反射</a><time datetime="2022-01-04T03:37:35.000Z" title="发表于 2022-01-04 11:37:35">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/" title="Go语言基础之包管理"><img src="https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之包管理"></a><div class="content"><a class="title" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/" title="Go语言基础之包管理">Go语言基础之包管理</a><time datetime="2022-01-03T03:37:35.000Z" title="发表于 2022-01-03 11:37:35">2022-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/" title="Go语言基础之接口"><img src="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之接口"></a><div class="content"><a class="title" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/" title="Go语言基础之接口">Go语言基础之接口</a><time datetime="2022-01-03T03:37:35.000Z" title="发表于 2022-01-03 11:37:35">2022-01-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>