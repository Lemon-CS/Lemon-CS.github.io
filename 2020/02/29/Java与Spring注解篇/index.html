<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java与Spring注解篇 | Lemon-CS</title><meta name="keywords" content="注解"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java与Spring注解篇"><meta property="og:type" content="article"><meta property="og:title" content="Java与Spring注解篇"><meta property="og:url" content="https://lemon-cs.github.io/2020/02/29/Java%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3%E7%AF%87/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="Java与Spring注解篇"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s4.ax1x.com/2022/02/15/H2zyWj.jpg"><meta property="article:published_time" content="2020-02-29T15:45:55.000Z"><meta property="article:modified_time" content="2021-12-29T07:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="Java"><meta property="article:tag" content="Spring"><meta property="article:tag" content="注解"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s4.ax1x.com/2022/02/15/H2zyWj.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/02/29/Java%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:600},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java与Spring注解篇",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-29 15:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s4.ax1x.com/2022/02/15/H2zyWj.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java与Spring注解篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-29T15:45:55.000Z" title="发表于 2020-02-29 23:45:55">2020-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-29T07:37:35.000Z" title="更新于 2021-12-29 15:37:35">2021-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Java与Spring注解篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java与Spring注解篇"><a href="#Java与Spring注解篇" class="headerlink" title="Java与Spring注解篇"></a>Java与Spring注解篇</h1><h2 id="1-Java注解介绍和原理"><a href="#1-Java注解介绍和原理" class="headerlink" title="1-Java注解介绍和原理"></a>1-Java注解介绍和原理</h2><p>从J2SE 5.0时代开始，注解一直是Java的重要组成部分。 在我们的应用程序代码中的某些地方，我们经常看到过类似@Override 和的注释 @Deprecated。</p><h3 id="1-1-什么是注解？"><a href="#1-1-什么是注解？" class="headerlink" title="1.1-什么是注解？"></a>1.1-什么是注解？</h3><p>用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据。</p><p><em><strong>Annontation</strong></em>是Java5开始引入的新特征，中文名称叫<strong>注解</strong>。它提供了一种安全的类似注释的机制，用来将任何的信息或<strong>元数据（metadata）</strong>与<strong>程序元素（类、方法、成员变量等）</strong>进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p><blockquote><p>比如@Override注解是告诉编译器此方法是重写的方法，如果父类中不存在任何这样的方法，则编译器会抛出异常。现在，如果我犯了一个书写错误，我重写的方法名写错了，如果我没有加上注解，那么我的代码将成功编译并执行，但是却不是我想要的结果。如果我加上了注解，那么编译器就会提示我父类不存在复写的方法。</p></blockquote><p>注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。</p><p><strong>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。</strong></p><p>而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p><p>典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。</p><h3 id="1-2-为什么要引入注解？"><a href="#1-2-为什么要引入注解？" class="headerlink" title="1.2-为什么要引入注解？"></a>1.2-为什么要引入注解？</h3><p>使用<code>Annotation</code>之前(甚至在使用之后)，<code>XML</code>被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p><p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p><p>另一个很重要的因素是Annotation定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记interfaces，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像Annotation这种标准的方式。</p><p>目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p><h3 id="1-3-注解的实现原理"><a href="#1-3-注解的实现原理" class="headerlink" title="1.3-注解的实现原理"></a>1.3-注解的实现原理</h3><ul><li>从java源码到class字节码是由编译器完成的，编译器会对java源码进行解析并生成class文件，而注解也是在编译时由编译器进行处理，编译器会对注解符号处理并附加到class结构中，根据jvm规范，class文件结构是严格有序的格式，唯一可以附加信息到class结构中的方式就是保存到class结构的attributes属性中。我们知道对于类、字段、方法，在class结构中都有自己特定的表结构，而且各自都有自己的属性，而对于注解，作用的范围也可以不同，可以作用在类上，也可以作用在字段或方法上，这时编译器会对应将注解信息存放到类、字段、方法自己的属性上。</li></ul><blockquote><p>注解的本质就是一个继承Annotation接口的接口，当我们通过AnnotationTest.class.getAnnotation(Test.class)调用时，JDK会通过动态代理生成一个实现了Test接口的对象，并把将RuntimeVisibleAnnotations属性值设置进此对象中，此对象即为Test注解对象，通过它的value()方法就可以获取到注解值。</p><p>Java注解实现机制的整个过程如上面所示，它的实现需要编译器和JVM一起配合</p></blockquote><ul><li>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的<code>invoke</code> 方法。该方法会从<code>memberValues</code> 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</li></ul><h3 id="1-4-注解的用处"><a href="#1-4-注解的用处" class="headerlink" title="1.4-注解的用处"></a>1.4-注解的用处</h3><ul><li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等；</li><li>跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；</li><li>在编译时进行格式检查。如@Override放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</li></ul><h3 id="1-5-元注解"><a href="#1-5-元注解" class="headerlink" title="1.5-元注解"></a>1.5-元注解</h3><p>元注解是用于修饰注解的注解，通常用在注解的定义上，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们 <code>@Override</code> 注解的定义，你可以看到其中的 <code>@Target</code>，<code>@Retention</code> 两个注解就是我们所谓的元注解，元注解一般用于指定某个注解生命周期以及作用目标等信息。</p><p><code>java.lang.annotation</code> 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><ul><li><code>@Documented</code> – 注解是否将包含在JavaDoc中</li><li><code>@Retention</code> – 注解的生命周期（什么时候使用该注解）</li><li><code>@Target</code> – 注解的作用目标（注解用于什么地方）</li><li><code>@Inherited</code> – 是否允许子类继承该注解</li></ul><h4 id="1-Target"><a href="#1-Target" class="headerlink" title="1. @Target"></a>1. @Target</h4><p>用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的，表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过以下的方式来为这个 value 传值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(value = &#123;ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><p>其中，ElementType 是一个枚举类型，有以下一些值：</p><ul><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ul><h4 id="2-Retention"><a href="#2-Retention" class="headerlink" title="2. @Retention"></a>2. @Retention</h4><p>用于指明当前注解的生命周期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，它也有一个 value 属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(value = RetentionPolicy.RUNTIME</span><br></pre></td></tr></table></figure><p>这里的 RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：</p><ul><li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li></ul><p>@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。</p><h4 id="3-Documented"><a href="#3-Documented" class="headerlink" title="3. @Documented"></a>3. @Documented</h4><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4. @Inherited"></a>4. @Inherited</h4><p>定义该注释和子类的关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。</p><h3 id="1-6-Java中常见的注解"><a href="#1-6-Java中常见的注解" class="headerlink" title="1.6-Java中常见的注解"></a>1.6-Java中常见的注解</h3><h4 id="1-Override"><a href="#1-Override" class="headerlink" title="1. @Override"></a>1. @Override</h4><p>java.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有任何的属性，所以并不能存储任何其他信息。它只能作用于方法之上，编译结束后将被丢弃。</p><p>所以你看，它就是一种典型的<strong>标记式注解</strong>，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。</p><h4 id="2-Deprecated"><a href="#2-Deprecated" class="headerlink" title="2. @Deprecated"></a>2. @Deprecated</h4><p>@Deprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然是一种<strong>标记式注解</strong>，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。</p><p>当然，编译器并不会强制要求你做什么，只是告诉你 JDK 已经不再推荐使用当前的方法或者类了，建议你使用某个替代者。</p><h4 id="3-SuppressWarnings"><a href="#3-SuppressWarnings" class="headerlink" title="3. @SuppressWarnings"></a>3. @SuppressWarnings</h4><p>SuppressWarning 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对@SuppressWarings 有效，同时编译器忽略掉无法识别的警告名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class="line"><span class="comment">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class="line"><span class="comment">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class="line"><span class="comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class="line"><span class="comment">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class="line"><span class="comment">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class="line"><span class="comment">     * warning name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The string &#123;<span class="doctag">@code</span> &quot;unchecked&quot;&#125; is used to suppress</span></span><br><span class="line"><span class="comment">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class="line"><span class="comment">     * additional warning names they support in conjunction with this</span></span><br><span class="line"><span class="comment">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class="line"><span class="comment">     * that the same names work across multiple compilers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set of warnings to be suppressed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个 value 属性需要你主动的传值，这个 value 代表一个什么意思呢，这个 value 代表的就是需要被压制的警告类型。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一段代码，程序启动时编译器会报一个警告。</p><blockquote><p>Warning:(8, 21) java: java.util.Date 中的 Date(int,int,int) 已过时</p></blockquote><p>而如果我们不希望程序启动时，编译器检查代码中过时的方法，就可以使用 @SuppressWarnings 注解并给它的 value 属性传入一个参数值来压制编译器的检查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning(value = &quot;deprecated&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2020</span>, <span class="number">3</span>, <span class="number">01</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你就会发现，编译器不再检查 main 方法下是否有过时的方法调用，也就压制了编译器对于这种警告的检查。</p><p>当然，JAVA 中还有很多的警告类型，他们都会对应一个字符串，通过设置 value 属性的值即可压制对于这一类警告类型的检查。</p><h3 id="1-7-自定义注解"><a href="#1-7-自定义注解" class="headerlink" title="1.7-自定义注解"></a>1.7-自定义注解</h3><p>自定义注解类编写的一些规则:</p><ol><li><p>Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</p></li><li><p>参数成员只能用public 或默认(default) 这两个访问权修饰</p></li><li><p>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</p></li><li><p>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</p></li><li><p>注解也可以没有定义成员,，不过这样注解就没啥用了</p></li></ol><p><strong>PS:自定义注解需要使用到元注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该注解用于方法声明</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="comment">//VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//将此注解包含在javadoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//允许子类继承父类中的注解</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;no description&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被注释的三个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test(id = 1, description = &quot;hello method1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Test(id = 2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析注释，将Test_1类所有被注解方法的信息打印出来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="meta">@Test(id = 3, description = &quot;last method3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method[] methods = TestAnnotation.class.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//判断方法中是否有指定注解类型的注解</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAnnotation = method.isAnnotationPresent(Test.class);</span><br><span class="line">            <span class="keyword">if</span> (hasAnnotation) &#123;</span><br><span class="line">                <span class="comment">//根据注解类型返回方法的指定类型注解</span></span><br><span class="line">                Test annotation = method.getAnnotation(Test.class);</span><br><span class="line">                System.out.println(<span class="string">&quot;Test(method=&quot;</span> + method.getName() + <span class="string">&quot;,id=&quot;</span> + annotation.id()</span><br><span class="line">                                   + <span class="string">&quot;,description=&quot;</span> + annotation.description() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-注解与反射"><a href="#1-8-注解与反射" class="headerlink" title="1.8-注解与反射"></a>1.8-注解与反射</h3><p>上述内容我们介绍了注解使用上的细节，也简单提到，「注解的本质就是一个继承了 Annotation 接口的接口」，现在我们就来从虚拟机的层面看看，注解的本质到底是什么。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;ElementType.FIELD,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hello &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。</p><p>之前我们说过，虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。属性表有以下几种：</p><ul><li>RuntimeVisibleAnnotations：运行时可见的注解</li><li>RuntimeInVisibleAnnotations：运行时不可见的注解</li><li>RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解</li><li>RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解</li><li>AnnotationDefault：注解类元素的默认值</li></ul><p>给大家看虚拟机的这几个注解相关的属性表的目的在于，让大家从整体上构建一个基本的印象，注解在字节码文件中是如何存储的。</p><p>所以，对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解。</p><ul><li>getAnnotation：返回指定的注解</li><li>isAnnotationPresent：判定当前元素是否被指定注解修饰</li><li>getAnnotations：返回所有的注解</li><li>getDeclaredAnnotation：返回本元素的指定注解</li><li>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</li></ul><p>方法、字段中相关反射注解的方法基本是类似的，这里不再赘述，我们下面看一个完整的例子。</p><p>首先，设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><blockquote><p>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</p></blockquote><p>然后写一个测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  	<span class="meta">@Hello(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class cls = Test.class;</span><br><span class="line">      	Method method = cls.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">      	Hello hello = method.getAnnotation(Hello.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。</p><p>我们运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error_ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。</p><p>而这个关键的 InvocationHandler 实例是谁？</p><p>AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6182022883658399397L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = var1;</span><br><span class="line">            <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span> var7 = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">switch</span>(var4.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">                <span class="keyword">if</span> (var4.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                    var7 = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">                <span class="keyword">if</span> (var4.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">                    var7 = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1444986633</span>:</span><br><span class="line">                <span class="keyword">if</span> (var4.equals(<span class="string">&quot;annotationType&quot;</span>)) &#123;</span><br><span class="line">                    var7 = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Object var6 = <span class="keyword">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(<span class="keyword">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="keyword">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。</p><p>var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。</p><p>如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。</p><p>那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。<strong>这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。</strong></p><p>其实，JAVA 中的注解设计个人觉得有点反人类，明明是属性的操作，非要用方法来实现。当然，如果你有不同的见解，欢迎留言探讨。</p><p>最后我们再总结一下整个反射注解的工作原理：</p><p>首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = “hello”）。</p><p>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</p><p>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</p><p>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。</p><p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，<strong>通过方法名返回注解属性值</strong>。</p><h2 id="2-Spring注解篇"><a href="#2-Spring注解篇" class="headerlink" title="2-Spring注解篇"></a>2-Spring注解篇</h2><h3 id="2-1-XML和注解"><a href="#2-1-XML和注解" class="headerlink" title="2.1-XML和注解"></a>2.1-XML和注解</h3><h4 id="2-1-1-XML"><a href="#2-1-1-XML" class="headerlink" title="2.1.1-XML"></a>2.1.1-XML</h4><ul><li><p>XML优点</p><ol><li><p>xml是集中式的元数据，不需要和代码绑定的；</p><p>在我们开发中，xml配置文件和代码类是区分开的，不需要绑定到代码中。</p></li><li><p>使用xml配置可以让软件更具有扩展性；</p><p>比如，我们在spring中，我们不想使用接口而是想用接口的实现类，这个时候只需要修改xml配置中bean的class值就可以了。</p></li><li><p>对象之间的关系一目了然；</p></li><li><p>类与类间的松藕合，容易扩展、更换；</p></li><li><p>xml定义：可扩展标记语言，标准通用标记语言的子集，简称XML。从这个定义中我们可以发现，xml最大的优势就在于，开发者(程序员)能够为软件量身定做使用的标记，使得xml更通俗易懂；</p></li><li><p>成熟的校验机制，来保证正确。可以使用Schema或者是DTD来对xml的正确性进行校验；</p></li><li><p>基于xml配置的时候，只需要修改xml即可，不需要对现有的程序进行修改；</p></li><li><p>容易与其他系统进行数据交互。数据共享方便。</p></li></ol></li><li><p>XML缺点</p><ol><li><p>应用程序中如果使用了xml配置，需要解析xml的工具或者是是第三方类库的支持；</p></li><li><p>解析xml的时候必然会占用资源，势必会影响到应用程序的性能；</p><p>以java为例，无论是将xml一次性装置到内存中，还是一行一行读取解析的，都会占用资源的。</p></li><li><p>xml配置文件过多，会导致维护变得困难；</p></li><li><p>在程序编译期间无法对其配置项的正确性进行验证，只能在运行期发现；</p></li><li><p>出错后，排错变得困难。往往在配置的时候，一个手误就会出现莫名其妙的错误(虽然事出必有妖，但是排查真难)；</p><p>比如，xml配置bean信息的时候，如果class的值带有空格，这种不好检查的，是比较麻烦的。排查起来很费事。</p></li><li><p>开发的时候，既要维护代码又要维护配置文件，使得开发的效率降低；</p></li><li><p>代码与配置项之间有时候会存在很多“潜规则”.改变了任意一方，都有可能影响到另一方的使用。这是个大坑</p><p>比如：自定义的标记，如果其他开发不清楚这些的话，修改了无论是代码还是xml的配置，都会导致程序不能正常运行。</p></li><li><p>开发工具对xml的验证支持的不是很好。</p><p>比如idea，对xml正确性，如果是自定义的，验证就不是很好。</p></li></ol></li></ul><h4 id="2-1-2-注解"><a href="#2-1-2-注解" class="headerlink" title="2.1.2-注解"></a>2.1.2-注解</h4><ul><li>注解优点<ol><li>简化配置；</li><li>注解的解析可以不依赖于第三方库，可以之间使用Java自带的反射；</li><li>注解和代码在一起的，之间在类上，降低了维护两个地方的成本；</li><li>注解如果有问题，在编译期间，就可以验证正确性，如果出错更容易找；</li><li>使用注解开发能够提高开发效率。不用多个地方维护，不用考虑是否存在“潜规则”；</li><li>类型安全。</li></ol></li><li>注解缺点<ol><li>修改的话比较麻烦。如果需要对注解进行修改的话，就需要对整个项目重新编译；</li><li>处理业务类之间的复杂关系，不然xml那样容易修改，也不及xml那样明了；</li><li>在程序中注解太多的话，会影响代码质量，代码简洁会有影响；</li><li>如果后来的人对注解不了解，会给维护带来成本；</li><li>注解功能没有xml配置齐全</li></ol></li></ul><h3 id="2-2-Spring常用注解大全"><a href="#2-2-Spring常用注解大全" class="headerlink" title="2.2-Spring常用注解大全"></a>2.2-Spring常用注解大全</h3><h4 id="2-2-1-Spring部分"><a href="#2-2-1-Spring部分" class="headerlink" title="2.2.1-Spring部分"></a>2.2.1-Spring部分</h4><h5 id="1-声明bean的注解"><a href="#1-声明bean的注解" class="headerlink" title="1. 声明bean的注解"></a>1. 声明bean的注解</h5><ul><li><code>@Component</code>：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解；</li><li><code>@Service</code>：组合注解（组合了@Component注解），应用在service层（业务逻辑层）；</li><li><code>@Controller</code>：组合注解（组合了@Component注解），应用在MVC层（控制层）,DispatcherServlet会自动扫描注解了此注解的类，然后将web请求映射到注解了@RequestMapping的方法上；</li><li><code>@Reponsitory</code>：组合注解（组合了@Component注解），应用在dao层（数据访问层）；</li><li><code>@RestController</code>：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。</li></ul><h5 id="2-注入bean的注解"><a href="#2-注入bean的注解" class="headerlink" title="2. 注入bean的注解"></a>2. 注入bean的注解</h5><ul><li><p><code>@Autowired</code>：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）；</p></li><li><p><code>@Resource</code>：JSR-250提供的注解；</p></li><li><p><code>@Inject</code>：JSR-330提供的注解;</p></li><li><p><code>@Qualifier</code>:此注解是和@Autowired一起使用的。使用此注解可以让你对注入的过程有更多的控制。</p><p>@Qualifier可以被用在单个构造器或者方法的参数上。当上下文有几个相同类型的bean, 使用@Autowired则无法区分要绑定的bean，此时可以使用@Qualifier来指定名称；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">publicclass User &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;address1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Required</code>:此注解用于bean的setter方法上。表示此属性是必须的，必须在配置阶段注入，否则会抛出BeanInitializationExcepion；</p></li><li><p><code>@Lazy</code>：此注解使用在Spring的组件类上。默认的，Spring中Bean的依赖一开始就被创建和配置。如果想要延迟初始化一个bean，那么可以在此类上使用Lazy注解，表示此bean只有在第一次被使用的时候才会被创建和初始化。此注解也可以使用在被@Configuration注解的类上，表示其中所有被@Bean注解的方法都会延迟初始化。</p></li></ul><h6 id="2-1-Autowired，-Resource和-Inject区别与实现原理"><a href="#2-1-Autowired，-Resource和-Inject区别与实现原理" class="headerlink" title="2.1. @Autowired，@Resource和@Inject区别与实现原理"></a>2.1. @Autowired，@Resource和@Inject区别与实现原理</h6><ul><li><p><strong>@Autowired</strong></p><ul><li>@Autowired是spring框架提供的实现依赖注入的注解，主要支持在set方法，field，构造函数中完成bean注入，注入方式为通过类型查找bean，即byType的，如果存在多个同一类型的bean，则使用@Qualifier来指定注入哪个beanName的bean。</li><li>Spring提供的注解，功能与@Inject相似，也是通过AutowiredAnnotationBeanPostProcessor处理，处理的顺序同样是：<ul><li>基于类型</li><li>基于@Qualifier</li><li>基于名称</li></ul></li></ul></li><li><p><strong>@Resource</strong></p><ul><li>与JDK的@Resource的区别：@Resource是基于bean的名字，即beanName，来从spring的IOC容器查找bean注入的，而@Autowried是基于类型byType来查找bean注入的。</li><li>JDK默认提供的注解，属于JSR-250规范的一部分（其他的还有@PostConstruce/@PreDestroy等），可以标记在属性或者Setter上，Spring通过CommonAnnotationBeanPostProcessor来处理该注解，在实现依赖注入的时候的匹配顺序是：<ul><li>基于名称</li><li>基于类型</li><li>基于@Qualifier</li></ul></li></ul></li><li><p><strong>@Inject</strong></p><ul><li><p>与JDK的@Inject的区别：@Inject也是基于类型来查找bean注入的，如果需要指定名称beanName，则可以结合使用@Named注解，而@Autowired是结合@Qualifier注解来指定名称beanName。</p></li><li><p>属于JSR-330提供的注解，该规范主要提供Java注入相关的注解，需要手动引入：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring通过AutowiredAnnotationBeanPostProcessor来处理该注解，处理顺序是：</p><ul><li>基于类型</li><li>基于@Qualifier</li><li>基于名称和@Named</li></ul></li></ul></li></ul><h6 id="2-2-spring依赖注入注解的实现原理"><a href="#2-2-spring依赖注入注解的实现原理" class="headerlink" title="2.2. spring依赖注入注解的实现原理"></a>2.2. spring依赖注入注解的实现原理</h6><ul><li><p><strong>注解处理器</strong></p><ul><li>在spring框架内部实现当中，注解实现注入主要是通过bean后置处理器BeanPostProcessor接口的实现类来生效的。BeanPostProcessor后置处理器是在spring容器启动时，创建bean对象实例后，马上执行的，对bean对象实例进行加工处理。</li><li>@Autowired是通过BeanPostProcessor接口的实现类AutowiredAnnotationBeanPostProcessor来实现对bean对象对其他bean对象的依赖注入的；</li><li>@Resource和@Inject是通过BeanPostProcessor接口的实现类CommonAnnotationBeanPostProcessor来实现的，其中如名字所述，即公共注解CommonAnotation，CommonAnnotationBeanPostProcessor是spring中统一处理JDK中定义的注解的一个BeanPostProcessor。该类会处理的注解还包括@PostConstruct，@PreDestroy等。</li></ul></li><li><p><strong>注解处理器的激活条件</strong></p><ul><li>AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor添加到spring容器的BeanPostProcessor的条件，即激活这些处理器的条件如下：</li></ul><ol><li>基于xml的spring配置</li></ol><ul><li>在对应的spring容器的配置xml文件中，如applicationContext.xml，添加&lt;context:annotation-config /&gt;和&lt;context:component-scan /&gt;，或者只使用&lt;context:component-scan /&gt;。</li><li>两者的区别是&lt;context:annotation-config /&gt;只查找并激活已经存在的bean，如通过xml文件的bean标签生成加载到spring容器的，而不会去扫描如@Controller等注解的bean，查找到之后进行注入；而&lt;context:component-scan /&gt;除了具有&lt;context:annotation-config /&gt;的功能之外，还会去加载通过basePackages属性指定的包下面的，默认为扫描@Controller，@Service，@Component，@Repository注解的类。不指定basePackages则是类路径下面，或者如果使用注解@ComponentScan方式，则是当前类所在包及其子包下面。</li></ul><p>2.基于配置类的spring配置</p><ul><li>如果是基于配置类而不是基于applicationContext.xml来对spring进行配置，如SpringBoot，则在内部使用的IOC容器实现为AnnotationConfigApplicationContext或者其派生类，在AnnotationConfigApplicationContext内部会自动创建和激活以上的BeanPostProcessor。</li><li>如果同时存在基于xml的配置和配置类的配置，而在注入时间方面，基于注解的注入先于基于XML的注入，所以基于XML的注入会覆盖基于注解的注入。</li></ul></li></ul><h6 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3. 总结"></a>2.3. 总结</h6><ul><li>@Autowired是Spring自带的，@Inject和@Resource都是JDK提供的，其中@Inject是JSR330规范实现的，@Resource是JSR250规范实现的，而Spring通过BeanPostProcessor来提供对JDK规范的支持。</li><li>@Autowired、@Inject用法基本一样，不同之处为@Autowired有一个required属性，表示该注入是否是必须的，即如果为必须的，则如果找不到对应的bean，就无法注入，无法创建当前bean。</li><li>@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的。如在spring-boot-data项目中自动生成的redisTemplate的bean，是需要通过byName来注入的。如果需要注入该默认的，则需要使用@Resource来注入，而不是@Autowired。</li><li>对于@Autowire和@Inject，如果同一类型存在多个bean实例，则需要指定注入的beanName。@Autowired和@Qualifier一起使用，@Inject和@Name一起使用。</li></ul><h5 id="3-java配置类相关注解"><a href="#3-java配置类相关注解" class="headerlink" title="3. java配置类相关注解"></a>3. java配置类相关注解</h5><ul><li><code>@Configuration</code> ：声明当前类是一个配置类（相当于一个Spring配置的xml文件），其中内部组合了@Component注解，表明这个类是一个bean（类上）；</li><li><code>@Bean</code>：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy；</li><li><code>@ComponentScan</code>：自动扫描指定包下所有使用@Service,@Component,@Controller,@Repository的类并注册，相当于xml中的ComponentScan；</li><li><code>@WishlyConfiguration</code> ：@Configuration与@ComponentScan的组合注解，可以替代这两个注解。</li></ul><h5 id="4-切面（AOP）相关注解"><a href="#4-切面（AOP）相关注解" class="headerlink" title="4. 切面（AOP）相关注解"></a>4. 切面（AOP）相关注解</h5><ul><li><p><code>@Aspect</code>：声明一个切面（类上）；</p><p>使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p></li><li><p><code>@After</code>：后置建言（advice），在方法执行之后执行（方法上）；</p></li><li><p><code>@Before</code> ：前置建言（advice），在方法执行之前执行（方法上）；</p></li><li><p><code>@Around</code>：环绕建言（advice），在方法执行之前与之后执行（方法上）；</p></li><li><p><code>@PointCut</code> ：声明切点，即定义拦截规则，确定有哪些方法会被切入，在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）；</p></li><li><p><code>@EnableAspectJAutoProxy</code>：开启Spring对AspectJ的支持。</p></li></ul><h5 id="5-Bean的属性支持"><a href="#5-Bean的属性支持" class="headerlink" title="5. @Bean的属性支持"></a>5. @Bean的属性支持</h5><ul><li><p><code>@Scope</code>：设置Spring容器如何新建Bean实例（方法上，得有@Bean）；</p><p>其设置类型包括：</p><ul><li>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,</li><li>Protetype （每次调用新建一个bean）,</li><li>Request （web项目中，给每个http request新建一个bean）,</li><li>Session （web项目中，给每个http session新建一个bean）,</li><li>GlobalSession（给每一个 global http session新建一个Bean实例）。</li></ul></li><li><p><code>@StepScope</code>：在Spring Batch中还有涉及；</p></li><li><p><code>@PostConstruct</code> ：由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod；</p></li><li><p><code>@PreDestory</code>：由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod。</p></li></ul><h5 id="6-Value和-ConfigurationProperties"><a href="#6-Value和-ConfigurationProperties" class="headerlink" title="6. @Value和@ConfigurationProperties"></a>6. @Value和@ConfigurationProperties</h5><h6 id="6-1-Value"><a href="#6-1-Value" class="headerlink" title="6.1. @Value"></a>6.1. @Value</h6><p>@Value 为属性注入值（属性上），此注解使用在字段、构造器参数和方法参数上。@Value可以指定属性取值的表达式，支持通过#{}使用SpringEL来取值，也支持使用${}来将属性来源中(Properties文件、本地环境变量、系统属性等)的值注入到bean的属性中。此注解值的注入发生在AutowiredAnnotationBeanPostProcessor类中。</p><ul><li><p>注入普通字符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;Kobe&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure></li><li><p>注入操作系统属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;os.name&#x27;]&#125;&quot;)</span></span><br><span class="line">String osName;</span><br></pre></td></tr></table></figure></li><li><p>注入表达式结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123; T(java.lang.Math).random() * 100 &#125;&quot;)</span></span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure></li><li><p>注入其它bean属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;User.name&#125;&quot;)</span></span><br><span class="line">String userName;</span><br></pre></td></tr></table></figure></li><li><p>注入文件资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;classpath:com/fangpeng/hello/test.txt&quot;)</span></span><br><span class="line">Resource file;</span><br></pre></td></tr></table></figure></li><li><p>注入网站资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;http://www.google.com&quot;)</span></span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure></li><li><p>注入配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line">String bookName;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注入配置使用方法：</strong></p><p>通过@Value将外部配置文件的值动态注入到Bean中。配置文件主要有两类：</p><ul><li>application.properties。application.properties在spring boot启动时默认加载此文件</li><li>自定义属性文件。自定义属性文件通过@PropertySource加载。@PropertySource可以同时加载多个文件，也可以加载单个文件。如果相同第一个属性文件和第二属性文件存在相同key，则最后一个属性文件里的key启作用。</li></ul><ol><li><p>编写配置文件（test.properties）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">book.name</span>=<span class="string">Java编程思想</span></span><br></pre></td></tr></table></figure></li><li><p><code>@PropertySource</code> 加载配置文件(类上)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:com/fangpeng/hello/test.properties&quot;)</span></span><br></pre></td></tr></table></figure></li></ol><h6 id="6-2-ConfigurationProperties"><a href="#6-2-ConfigurationProperties" class="headerlink" title="6.2. @ConfigurationProperties"></a>6.2. @ConfigurationProperties</h6><p>将属性文件与一个Java类绑定，属性文件中的变量与Java类中的成员变量一一对应，无需完全一致。</p><p>如需将 @ConfigurationProperties 注解的目标类添加到Spring IOC容器中，可以</p><ul><li>使用 @Component 注解目标类，这样项目启动时会自动将该类添加到容器中。</li><li>使用 @EnableConfigurationProperties 间接的将 @ConfigurationProperties 注解的目标类添加到容器中。讲的详细点就是，使用 @ConfigurationProperties 注解 类A，使用 @EnableConfigurationProperties(value = 类A.class) 注解类B，那么容器在加载类B的时候，会先加载类A到容器中，实现了间接的加载。</li></ul><p><strong>具体使用：</strong></p><p>首先在配置文件里面添加配置信息：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">connection.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">connection.password</span>=<span class="string">kyjufskifas2jsfs</span></span><br><span class="line"><span class="meta">connection.remoteAddress</span>=<span class="string">192.168.1.1</span></span><br></pre></td></tr></table></figure><p>定义一个实体类在装载配置文件信息:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;connection&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionSettings</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String remoteAddress;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remoteAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteAddress</span><span class="params">(String remoteAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以把@ConfigurationProperties还可以直接定义在@bean的注解上，这是bean实体类就不用@Component和@ConfigurationProperties了:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;connection&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionSettings <span class="title">connectionSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConnectionSettings();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用的时候就直接这样子注入:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/task&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConnectionSettings conn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/&quot;, &quot;&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hellTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String userName = conn.getUsername();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello task !!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="6-3-区别"><a href="#6-3-区别" class="headerlink" title="6.3-区别"></a>6.3-区别</h6><table><thead><tr><th align="left">header 1</th><th align="left">@ConfigurationProperties</th><th align="left">@Value</th></tr></thead><tbody><tr><td align="left">功能</td><td align="left">批量注入配置文件中的属性</td><td align="left">一个个制定</td></tr><tr><td align="left">松散绑定（松散语法）</td><td align="left">支持</td><td align="left">不支持</td></tr><tr><td align="left">SpEL</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">JSR303数据校验</td><td align="left">支持</td><td align="left">不支持</td></tr><tr><td align="left">复杂类型封装</td><td align="left">支持</td><td align="left">不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><ul><li>松散语法<ol><li>person.firstName: 使用标准模式</li><li>person.first-name: 大写用-</li><li>person.first_name: 大写用_</li><li>PERSON_FIRST_NAME: 推荐属性使用这种写法</li></ol></li></ul><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h5 id="7-环境切换"><a href="#7-环境切换" class="headerlink" title="7. 环境切换"></a>7. 环境切换</h5><ul><li><p><code>@Profile</code>：表示当一个或多个指定的文件是活动的时，一个组件是有资格注册的。使用@Profile注解类或者方法，达到在不同情况下选择实例化不同的Bean。@Profile(“dev”)表示为dev时实例化，过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</p></li><li><p><code>@Conditional</code>：Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th align="left">@Conditional派生注解</th><th align="left">作用（判断是否满足当前条件）</th></tr></thead><tbody><tr><td align="left">@@Conditional派生注解</td><td align="left">系统的java版本是否符合要求</td></tr><tr><td align="left">@ConditionalOnBean</td><td align="left">容器中存在指定Bean</td></tr><tr><td align="left">@ConditionalOnMissingBean</td><td align="left">容器中不存在指定Bean</td></tr><tr><td align="left">@ConditionalOnExpression</td><td align="left">满足SpEL表达式指定</td></tr><tr><td align="left">@ConditionalOnClass</td><td align="left">系统中有指定的类</td></tr><tr><td align="left">@ConditionalOnMissingClass</td><td align="left">系统中没有指定的类</td></tr><tr><td align="left">@ConditionalOnSingleCandidate</td><td align="left">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td align="left">@ConditionalOnProperty</td><td align="left">系统中指定的属性是否有指定的值</td></tr><tr><td align="left">@ConditionalOnResource</td><td align="left">类路径下是否存在指定资源文件</td></tr><tr><td align="left">@ConditionalOnWebApplication</td><td align="left">当前是web环境</td></tr><tr><td align="left">@ConditionalOnNotWebApplication</td><td align="left">当前不是web环境</td></tr><tr><td align="left">@ConditionalOnJndi</td><td align="left">NDI存在指定项</td></tr></tbody></table></li></ul><h5 id="8-异步相关"><a href="#8-异步相关" class="headerlink" title="8. 异步相关"></a>8. 异步相关</h5><ul><li><code>@EnableAsync</code>：配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）；</li><li><code>@Async</code>：注解在方法上标示这是一个异步方法，在类上标示这个类所有的方法都是异步方法；</li></ul><h5 id="9-定时任务相关"><a href="#9-定时任务相关" class="headerlink" title="9. 定时任务相关"></a>9. 定时任务相关</h5><ul><li><code>@EnableScheduling</code>：注解在配置类上，开启对计划任务的支持；</li><li><code>@Scheduled</code>：注解在方法上，声明该方法是计划任务。支持多种类型的计划任务：cron,fixDelay,fixRate，（需先开启计划任务的支持）；</li></ul><h5 id="10-Enable-注解"><a href="#10-Enable-注解" class="headerlink" title="10. @Enable*注解"></a>10. @Enable*注解</h5><p>通过简单的@Enable<em>来开启一项功能的支持。所有@Enable</em>注解都有一个@Import注解，@Import是用来导入配置类的，这也就意味着这些自动开启的实现其实是导入了一些自动配置的Bean：</p><ol><li><p>直接导入配置类</p></li><li><p>依据条件选择配置类</p></li><li><p>动态注册配置类</p></li></ol><ul><li><code>@EnableAspectJAutoProxy</code> 开启对AspectJ自动代理的支持</li><li><code>@EnableAsync</code> 开启异步方法的支持</li><li><code>@EnableScheduling</code> 开启计划任务的支持</li><li><code>@EnableWebMvc</code> 开启Web MVC的配置支持</li><li><code>@EnableConfigurationProperties</code> 开启对@ConfigurationProperties注解配置Bean的支持</li><li><code>@EnableJpaRepositories</code> 开启对SpringData JPA Repository的支持</li><li><code>@EnableTransactionManagement</code> 开启注解式事务的支持</li><li><code>@EnableTransactionManagement</code> 开启注解式事务的支持</li><li><code>@EnableCaching</code> 开启注解式的缓存支持</li></ul><h5 id="11-测试相关注解"><a href="#11-测试相关注解" class="headerlink" title="11. 测试相关注解"></a>11. 测试相关注解</h5><ul><li><code>@RunWith</code>：运行器，Spring中通常用于对JUnit的支持，是Junit的注解，一般在测试类里使用:@RunWith(SpringJUnit4ClassRunner.class) — SpringJUnit4ClassRunner在JUnit环境下提供Sprng TestContext Framework的功能；</li><li><code>@ContextConfiguration</code>：用来加载配置ApplicationContext，其中classes属性用来加载配置类:@ContextConfiguration(classes = {TestConfig.class(自定义的一个配置类)})；</li></ul><h5 id="12-事务相关注解"><a href="#12-事务相关注解" class="headerlink" title="12. 事务相关注解"></a>12. 事务相关注解</h5><p>事务管理一般有编程式和声明式两种，编程式是直接在代码中进行编写事物处理过程，而声名式则是通过注解方式或者是在xml文件中进行配置，相对编程式很方便。</p><p>而注解方式通过@Transactional 是常见的。我们可以使用@EnableTransactionManagement 注解来启用事务管理功能，该注解可以加在启动类上或者单独加个配置类来处理。</p><ul><li><p><code>@Transactional</code></p><p>当标于类前时, 标示类中所有方法都进行事物处理；标记在方法上，则表示当前方法是一个事务方法；当类级别配置了@Transactional，方法级别也配置了@Transactional，应用程序会以方法级别的事务属性信息来管理事务，即方法级别的事务属性信息会覆盖类级别的相关配置信息。</p><p><strong>Transactional 注解的属性</strong></p><ul><li>name 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</li><li>propagation 事务的传播行为，默认值为 REQUIRED。</li><li>isolation 事务的隔离度，默认值采用 DEFAULT。</li><li>timeout 事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</li><li>rollback-for 用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</li><li>no-rollback- for 抛出 no-rollback-for 指定的异常类型，不回滚事务。</li></ul><p><strong>propagation 属性（事务传播性）</strong></p><ul><li>REQUIRED 支持当前已经存在的事务，如果还没有事务，就创建一个新事务。</li><li>MANDATORY 支持当前已经存在的事务，如果还没有事务，就抛出一个异常。</li><li>NESTED 在当前事务中创建一个嵌套事务，如果还没有事务，那么就简单地创建一个新事务。</li><li>REQUIRES_NEW 挂起当前事务，创建一个新事务，如果还没有事务，就简单地创建一个新事务。</li><li>NEVER 强制要求不在事务中运行，如果当前存在一个事务，则抛出异常。</li><li>NOT_SUPPORTED 强制不在事务中运行，如果当前存在一个事务，则挂起该事务。</li><li>SUPPORTS 支持当前事务，如果没有事务那么就不在事务中运行。</li></ul></li><li><p><strong>@Transactional工作原理</strong></p><p>声明式事务管理包含三个组成部分：</p><ul><li>事务的切面</li><li>事务管理器</li><li>EntityManager Proxy本身</li></ul><p><strong>事务的切面</strong></p><p>事务的切面是一个“around（环绕）”切面，在注解的业务方法前后都可以被调用。实现切面的具体类是TransactionInterceptor。事务的切面有两个主要职责：</p><ul><li>在’before’时，切面提供一个调用点，来决定被调用业务方法应该在正在进行事务的范围内运行，还是开始一个新的独立事务。</li><li>在’after’时，切面需要确定事务被提交，回滚或者继续运行。</li></ul><p>在’before’时，事务切面自身不包含任何决策逻辑，是否开始新事务的决策委派给事务管理器完成。</p><p><strong>事务管理器</strong></p><p>事务管理器需要解决下面两个问题：</p><ul><li>新的Entity Manager是否应该被创建？</li><li>是否应该开始新的事务？</li></ul><p>这些需要事务切面’before’逻辑被调用时决定。事务管理器的决策基于以下两点：</p><ul><li>事务是否正在进行</li><li>事务方法的propagation属性（比如REQUIRES_NEW总要开始新事务）</li></ul><p>如果事务管理器确定要创建新事务，那么将：</p><ul><li>创建一个新的entity manager</li><li>entity manager绑定到当前线程</li><li>从数据库连接池中获取连接</li><li>将连接绑定到当前线程</li></ul><p>使用<strong>ThreadLocal</strong>变量将entity manager和数据库连接都绑定到当前线程。事务运行时他们存储在线程中，当它们不再被使用时，事务管理器决定是否将他们清除。程序的任何部分如果需要当前的entity manager和数据库连接都可以从线程中获取。</p><p><strong>EntityManager proxy</strong></p><p>当业务方法调用类似**entityManager.persist()**方法时，这不是由entity manager直接调用的，而是业务方法调用代理，因为事物管理器将entity manage绑定到了线程上，代理从线程获取当前的entity manager。</p></li></ul><h4 id="2-2-2-Spring-MVC部分"><a href="#2-2-2-Spring-MVC部分" class="headerlink" title="2.2.2-Spring MVC部分"></a>2.2.2-Spring MVC部分</h4><ul><li><p><code>@EnableWebMvc</code></p><p>在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）；</p></li><li><p><code>@Controller</code></p><p>声明该类为SpringMVC中的Controller；</p></li><li><p><code>@RequestMapping</code></p><p>用于映射Web请求，包括访问路径和参数（类或方法上）；</p><p>@RequestMapping注解的主要用途是将Web请求与请求处理类中的方法进行映射。Spring MVC和Spring WebFlux都通过RquestMappingHandlerMapping和RequestMappingHndlerAdapter两个类来提供对@RequestMapping注解的支持。</p><p>@RequestMapping注解对请求处理类中的请求处理方法进行标注；@RequestMapping注解拥有以下的六个配置属性：</p><ul><li>value:映射的请求URL或者其别名</li><li>method:兼容HTTP的方法名</li><li>params:根据HTTP参数的存在、缺省或值对请求进行过滤</li><li>header:根据HTTP Header的存在、缺省或值对请求进行过滤</li><li>consume:设定在HTTP请求正文中允许使用的媒体类型</li><li>product:在HTTP响应体中允许使用的媒体类型</li></ul><blockquote><p>提示：在使用@RequestMapping之前，请求处理类还需要使用@Controller或@RestController进行标记</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line">publicclass UserController &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;users&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Spring4.3之后引入了一系列@RequestMapping的变种。如下：</p><ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@PatchMapping</li><li>@DeleteMapping</li></ul><p>分别对应了相应method的RequestMapping配置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;)</span>     <span class="comment">// 通过这里配置使下面的映射都在/users下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程安全的Map，模拟users信息的存储</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Long, User&gt; users = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Long, User&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&quot;的GET请求，用来获取用户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递</span></span><br><span class="line">        List&lt;User&gt; r = <span class="keyword">new</span> ArrayList&lt;User&gt;(users.values());</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&quot;的POST请求，用来创建User</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// @RequestBody注解用来绑定通过http请求中application/json类型上传的数据</span></span><br><span class="line">        users.put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// url中的id可通过@PathVariable绑定到函数的参数中</span></span><br><span class="line">        <span class="keyword">return</span> users.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&#123;id&#125;&quot;的PUT请求，用来更新User信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        User u = users.get(id);</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        users.put(id, u);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&quot;/users/&#123;id&#125;&quot;的DELETE请求，用来删除User</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        users.remove(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@RequestBody</code></p><p>允许request的参数在request体中，而不是在直接链接在地址的后面。此注解放置在参数前，@RequestBody在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过HttpMessageConverter传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值；</p></li><li><p><code>@ResponseBody</code></p><p>支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）；</p></li><li><p><code>@CookieValue</code></p><p>此注解用在@RequestMapping声明的方法的参数上，可以把HTTP cookie中相应名称的cookie绑定上去;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReuestMapping(&quot;/cookieValue&quot;)</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCookieValue</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cookie即http请求中name为JSESSIONID的cookie值。</p></li><li><p><code>@CrossOrigin</code></p><p>此注解用在class和method上用来支持跨域请求，是Spring 4.2后引入的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line">publicclass AccountController &#123;</span><br><span class="line">    <span class="meta">@CrossOrigin(origins = &quot;http://xx.com&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">userLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@PathVariable</code></p><p>放置在参数前，用来接受路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p><p>@PathVariable注解是将方法中的参数绑定到请求URI中的模板变量上。可以通过@RequestMapping注解来指定URI的模板变量，然后使用@PathVariable注解将方法中的参数绑定到模板变量上。特别地，@PathVariable注解允许我们使用value或name属性来给参数取一个别名。下面是使用此注解的一个示例：</p><p><img src="PathVariable.png" alt="PathVariable"></p></li><li><p><code>@RestController</code></p><p>该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody；</p></li><li><p><code>@ControllerAdvice</code></p><p>@ControllerAdvice是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。@ControllerAdvice需要和@ExceptionHandler、@InitBinder以及@ModelAttribute注解搭配使用，主要是用来处理控制器所抛出的异常信息。首先，我们需要定义一个被@ControllerAdvice所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。</p><p>此外，在有必要的时候，可以使用@InitBinder在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用@ControllerAdvice注解，就可以快速的创建统一的，自定义的异常处理类。下面是一个使用@ControllerAdvice的示例代码：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/ControllerAdvice.png"></p></li><li><p><code>@ExceptionHandler</code></p><p>@ExceptionHander注解用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被@ExceptionHandler标注的方法。下面是使用该注解的一个示例：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/ExceptionHandler.jpeg"></p></li><li><p><code>@ResponseStatus</code></p><p>@ResponseStatus注解可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。下面是使用@ResponseStatus注解的一个示例：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/ResponseStatus.jpeg"></p></li><li><p><code>@InitBinder</code></p><p>此注解使用在方法上，声明对WebDataBinder的初始化(绑定请求参数到JavaBean上的DataBinder)。在controller上使用此注解可以自定义请求参数的绑定。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/InitBinder.jpeg"></p></li><li><p><code>@MatrixVariable</code></p><p>此注解使用在请求handler方法的参数上，Spring可以注入matrix url中相关的值。这里的矩阵变量可以出现在url中的任何地方，变量之间用;分隔。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42;q=11;r=22</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId, <span class="meta">@MatrixVariable</span> <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// petId == 42</span></span><br><span class="line">    <span class="comment">// q == 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是默认Spring mvc是不支持矩阵变量的，需要开启。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">enable-matrix-variables</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注解配置则需要如下开启：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">publicclass WebConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@RequestHeader</code></p><p>此注解用在请求handler方法的参数上，用于将http请求头部的值绑定到参数上。</p></li><li><p><code>@RequestParam</code></p><p>@RequestParam注解用于将方法的参数与Web请求的传递的参数进行绑定。使用@RequestParam可以轻松的访问HTTP请求参数的值。下面是使用该注解的代码示例：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/RequestParam.jpeg"></p></li><li><p><code>@SessionAttribute</code></p><p>此注解用于方法的参数上，用于将session中的属性绑定到参数。</p></li><li><p><code>@SessionAttributes</code></p><p>此注解用于type级别，用于将JavaBean对象存储到session中。一般和@ModelAttribute注解一起使用。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute(&quot;user&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PUser <span class="title">getUser</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// controller和上面的代码在同一controller中</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SeesionAttributes(value = &quot;user&quot;, types = &#123;</span></span><br><span class="line"><span class="meta">    User.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line">publicclass UserController &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@RestControllerAdvice</code></p><p>此注解用于class上，同时引入了@ControllerAdvice和@ResponseBody两个注解。</p></li></ul><h4 id="2-2-3-Spring-Boot注解"><a href="#2-2-3-Spring-Boot注解" class="headerlink" title="2.2.3-Spring Boot注解"></a>2.2.3-Spring Boot注解</h4><ul><li><p><code>@SpringBootApplication</code></p><p>@SpringBootApplication注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于@Configuration、@EnableAutoConfiguration和@ComponentScan的组合。在Spring Boot应用程序的主类中，就使用了此注解。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@EnableAutoConfiguration</code></p><p>@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。</p></li><li><p><code>@ConditionalOnClass与@ConditionalOnMissingClass</code></p><p>这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalOnBean与@ConditionalOnMissingBean</code></p><p>这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name=&quot;dataSource&quot;)</span></span><br><span class="line"><span class="function">LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalOnProperty</code></p><p>@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;alipay&quot;,havingValue=&quot;on&quot;)</span></span><br><span class="line"><span class="function">Alipay <span class="title">alipay</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Alipay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalOnResource</code></p><p>此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnResource(resources = &quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="function">Properties <span class="title">addWebsiteProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalOnWebApplication与@ConditionalOnNotWebApplication</code></p><p>这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="function">HealthCheckController <span class="title">healthCheckController</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ConditionalExpression</code></p><p>此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalException(&quot;$&#123;localstore&#125; &amp;&amp; $&#123;local == &#x27;true&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="function">LocalFileStore <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@ImportResource</code>：导入Spring的配置文件，让配置文件里面的内容生效（xml）；</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/02/29/Java%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3%E7%AF%87/">https://lemon-cs.github.io/2020/02/29/Java%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/%E6%B3%A8%E8%A7%A3/">注解</a></div><div class="post_share"><div class="social-share" data-image="https://s4.ax1x.com/2022/02/15/H2zyWj.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/03/01/Lombok%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2022/02/87365d0f071b194f.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lombok学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/29/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://s4.ax1x.com/2022/02/15/HRpyMn.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker入门学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/08/04/Spring%E4%B9%8BAOP%E5%BA%94%E7%94%A8/" title="Spring之AOP应用-6"><img class="cover" src="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-04</div><div class="title">Spring之AOP应用-6</div></div></a></div><div><a href="/2020/08/03/Spring%E4%B9%8BIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Spring之IOC源码分析-5"><img class="cover" src="https://static01.imgkr.com/temp/fa403895570e4cafb459adbcdca97dbe.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="title">Spring之IOC源码分析-5</div></div></a></div><div><a href="/2020/08/03/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1/" title="Spring之事务-7"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/a560e450dd631e8f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="title">Spring之事务-7</div></div></a></div><div><a href="/2020/07/31/Spring%E4%B9%8BIOC%E7%9A%84%E5%BA%94%E7%94%A8/" title="Spring之IOC的应用-4"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/2de6481e0a4697bf.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-31</div><div class="title">Spring之IOC的应用-4</div></div></a></div><div><a href="/2020/07/31/Spring%E4%B9%8B%E5%AE%9E%E7%8E%B0IOC%E5%92%8CAOP/" title="Spring之实现IOC和AOP-3"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRSa9J.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-31</div><div class="title">Spring之实现IOC和AOP-3</div></div></a></div><div><a href="/2020/07/31/Spring%E4%B9%8B%E6%A6%82%E8%BF%B0/" title="Spring概述-1"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRpyMn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-31</div><div class="title">Spring概述-1</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%B8%8ESpring%E6%B3%A8%E8%A7%A3%E7%AF%87"><span class="toc-text">Java与Spring注解篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E6%B3%A8%E8%A7%A3%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">1-Java注解介绍和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-text">1.1-什么是注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-text">1.2-为什么要引入注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1.3-注解的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-text">1.4-注解的用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.5-元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Target"><span class="toc-text">1. @Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Retention"><span class="toc-text">2. @Retention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Documented"><span class="toc-text">3. @Documented</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Inherited"><span class="toc-text">4. @Inherited</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.6-Java中常见的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Override"><span class="toc-text">1. @Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Deprecated"><span class="toc-text">2. @Deprecated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SuppressWarnings"><span class="toc-text">3. @SuppressWarnings</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.7-自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-text">1.8-注解与反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spring%E6%B3%A8%E8%A7%A3%E7%AF%87"><span class="toc-text">2-Spring注解篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-XML%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">2.1-XML和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-XML"><span class="toc-text">2.1.1-XML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%B3%A8%E8%A7%A3"><span class="toc-text">2.1.2-注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8"><span class="toc-text">2.2-Spring常用注解大全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Spring%E9%83%A8%E5%88%86"><span class="toc-text">2.2.1-Spring部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8Ebean%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">1. 声明bean的注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B3%A8%E5%85%A5bean%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">2. 注入bean的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-Autowired%EF%BC%8C-Resource%E5%92%8C-Inject%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.1. @Autowired，@Resource和@Inject区别与实现原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.2. spring依赖注入注解的实现原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-%E6%80%BB%E7%BB%93"><span class="toc-text">2.3. 总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-java%E9%85%8D%E7%BD%AE%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">3. java配置类相关注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%87%E9%9D%A2%EF%BC%88AOP%EF%BC%89%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">4. 切面（AOP）相关注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Bean%E7%9A%84%E5%B1%9E%E6%80%A7%E6%94%AF%E6%8C%81"><span class="toc-text">5. @Bean的属性支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Value%E5%92%8C-ConfigurationProperties"><span class="toc-text">6. @Value和@ConfigurationProperties</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#6-1-Value"><span class="toc-text">6.1. @Value</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-2-ConfigurationProperties"><span class="toc-text">6.2. @ConfigurationProperties</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-3-%E5%8C%BA%E5%88%AB"><span class="toc-text">6.3-区别</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2"><span class="toc-text">7. 环境切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%BC%82%E6%AD%A5%E7%9B%B8%E5%85%B3"><span class="toc-text">8. 异步相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-text">9. 定时任务相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-Enable-%E6%B3%A8%E8%A7%A3"><span class="toc-text">10. @Enable*注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">11. 测试相关注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">12. 事务相关注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Spring-MVC%E9%83%A8%E5%88%86"><span class="toc-text">2.2.2-Spring MVC部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-Spring-Boot%E6%B3%A8%E8%A7%A3"><span class="toc-text">2.2.3-Spring Boot注解</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/07/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2022/01/07/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2022-01-07T14:09:50.000Z" title="发表于 2022-01-07 22:09:50">2022-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/" title="Go语言基础之包管理"><img src="https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之包管理"></a><div class="content"><a class="title" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/" title="Go语言基础之包管理">Go语言基础之包管理</a><time datetime="2022-01-03T03:37:35.000Z" title="发表于 2022-01-03 11:37:35">2022-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/" title="Go语言基础之接口"><img src="https://static01.imgkr.com/temp/7e2ff0bcacb94fe1a60c065dd5773565.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之接口"></a><div class="content"><a class="title" href="/2022/01/03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/" title="Go语言基础之接口">Go语言基础之接口</a><time datetime="2022-01-03T03:37:35.000Z" title="发表于 2022-01-03 11:37:35">2022-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/" title="Go语言基础之结构体"><img src="https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之结构体"></a><div class="content"><a class="title" href="/2022/01/02/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/" title="Go语言基础之结构体">Go语言基础之结构体</a><time datetime="2022-01-02T14:09:50.000Z" title="发表于 2022-01-02 22:09:50">2022-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/31/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB"><img src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go操作MongoDB"></a><div class="content"><a class="title" href="/2021/12/31/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB">Go操作MongoDB</a><time datetime="2021-12-31T14:09:50.000Z" title="发表于 2021-12-31 22:09:50">2021-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>