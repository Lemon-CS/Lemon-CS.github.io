<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HTTP和HTTPS详解 | Lemon-CS</title><meta name="keywords" content="HTTP"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP和HTTPS介绍和原理详解"><meta property="og:type" content="article"><meta property="og:title" content="HTTP和HTTPS详解"><meta property="og:url" content="https://lemon-cs.github.io/2020/05/11/HTTP%E5%92%8CHTTPS%E8%AF%A6%E8%A7%A3/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="HTTP和HTTPS介绍和原理详解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg"><meta property="article:published_time" content="2020-05-11T15:03:55.000Z"><meta property="article:modified_time" content="2022-01-25T06:45:21.318Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="HTTP"><meta property="article:tag" content="HTTPS"><meta property="article:tag" content="SSL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/05/11/HTTP%E5%92%8CHTTPS%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"HTTP和HTTPS详解",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-25 14:45:21"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HTTP和HTTPS详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-11T15:03:55.000Z" title="发表于 2020-05-11 23:03:55">2020-05-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-25T06:45:21.318Z" title="更新于 2022-01-25 14:45:21">2022-01-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="HTTP和HTTPS详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HTTP和HTTPS详解"><a href="#HTTP和HTTPS详解" class="headerlink" title="HTTP和HTTPS详解"></a>HTTP和HTTPS详解</h1><h2 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1-HTTP"></a>1-HTTP</h2><h3 id="1-1-HTTP介绍"><a href="#1-1-HTTP介绍" class="headerlink" title="1.1-HTTP介绍"></a>1.1-HTTP介绍</h3><p>HTTP 是一种 <code>超文本传输协议(Hypertext Transfer Protocol)</code>，<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong>。</p><p>HTTP 主要内容分为三部分，<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>。</p><ul><li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行<code>超链接</code>的跳转。</li><li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为<code>请求方</code>，把接到二进制数据包的一方称为<code>应答方</code>。</li><li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</li></ul><p>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><p>HTTP有多个版本，目前广泛使用的是HTTP/1.1版本。</p><h3 id="1-2-HTTP原理和工作流程"><a href="#1-2-HTTP原理和工作流程" class="headerlink" title="1.2-HTTP原理和工作流程"></a>1.2-HTTP原理和工作流程</h3><h4 id="1-HTTP原理"><a href="#1-HTTP原理" class="headerlink" title="1. HTTP原理"></a>1. HTTP原理</h4><p>HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的数据类型为HTML 文件,、图片文件, 查询结果等。</p><p>HTTP协议一般用于B/S架构，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。</p><p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。</p><h4 id="2-HTTP原理"><a href="#2-HTTP原理" class="headerlink" title="2. HTTP原理"></a>2. HTTP原理</h4><p>一次HTTP操作称为一个事务，其工作过程大概如下：</p><ol><li>用户在浏览器中键入需要访问网页的URL或者点击某个网页中链接；</li><li>浏览器根据URL中的域名，通过DNS解析出目标网页的IP地址；（然后将上面结合本机自己的信息，封装成一个http请求数据包）</li><li>在HTTP开始工作前，客户端首先会通过TCP/IP协议来和服务端建立链接（TCP三次握手）</li><li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li><li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：<code>Connection:keep-alive</code>，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ol><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E6%B5%81%E7%A8%8B.jpg"></p><h3 id="1-3-HTTP特点"><a href="#1-3-HTTP特点" class="headerlink" title="1.3-HTTP特点"></a>1.3-HTTP特点</h3><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><h3 id="1-4-URI和URL的区别"><a href="#1-4-URI和URL的区别" class="headerlink" title="1.4-URI和URL的区别"></a>1.4-URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><ul><li>URI：Uniform Resource Identifier 统一资源<strong>标识</strong>符</li><li>URL：Uniform Resource Location 统一资源<strong>定位</strong>符</li></ul><p>URI 是用来标识一个具体的资源的，我们可以通过 URI 知道一个资源是什么。</p><p>URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。</p><h3 id="1-5-HTTP的报文及其结构"><a href="#1-5-HTTP的报文及其结构" class="headerlink" title="1.5-HTTP的报文及其结构"></a>1.5-HTTP的报文及其结构</h3><h4 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h4><p>HTTP 请求报文大致可分为请求行、请求头、空行、请求主体四部分。请求行、请求头部和空行是必需的而报文主体是可选的，每个部分结尾都用空行来作为结束标志。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpeg"></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpeg"></p><ul><li><p><strong>请求行：</strong>请求方法（Method） + 空格 + 统一资源标识符（URI） + 空格 + HTTP版本 + CR LF ；</p><ul><li><p>请求方法：<strong>GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</strong></p><p>最常用的是<code>GET</code>和<code>POST</code>。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.jpeg"></p></li><li><p>URL字段用来指明目标资源的位置，它只包含一个完整URL中的文件路径和查询字符串这两部分，比如”/index.php?id=24”，而不包含协议、主机名和端口号。如果同一服务器上部署了多个网站，那么为了准确判断出请求的是哪个资源需要将URL字段和Host请求头的值（指定要访问的网站名）相结合使用。</p></li><li><p>协议版本字段说明该请求报文属于哪一版的http协议，比如HTTP/1.1或HTTP/1.0。</p></li></ul></li><li><p><strong>请求头：</strong>字段名 + 冒号 + 值 + CR LF ；</p><p>请求头部用来告知服务器该请求和客户端本身的一些额外信息，每个请求头都是一个键值对，键和值之间用英文冒号隔开。每个请求头单独形成一行，它们的末尾都是一个回车符和换行符。</p><p>在所有的请求头中，只有Host是必需的，其它请求头都是可选的。这里，我们将一些常见的请求头列于下表中：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8.jpeg"></p></li><li><p><strong>空行：</strong> 回车符（CR）+ 换行符（LF） ；</p><p>在请求头部的后面是一个空行，它只包含一个回车符和一个换行符，不包含其它任何内容，连空格也不能包含。这个空行用于标记请求头部已结束；它是必须要有的，即便使用GET这样不包含报文主体的请求方法时也要有这个空行。</p></li><li><p><strong>请求体：</strong> 由用户自定义添加，如post的body等；</p></li></ul><h4 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h4><p>HTTP响应报文状态行、响应头、空行、响应主体四部分，响应报文结构与请求报文结构唯一的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpeg"></p><p>状态行：HTTP版本 + 空格 + 状态码 + 空格 + 状态码描述 + CR LF ；</p><p>响应头：字段名 + 冒号 + 值 + CR LF ；</p><p>空行： 回车符（CR）+ 换行符（LF） ；</p><p>响应体： 由用户自定义添加，如post的body等；</p><p><strong>响应报文示例：</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%A4%BA%E4%BE%8B.jpeg"></p><h3 id="1-6-Get和Post的区别"><a href="#1-6-Get和Post的区别" class="headerlink" title="1.6-Get和Post的区别"></a>1.6-Get和Post的区别</h3><p>HTTP 中包括许多方法，<strong>Get 和 Post 是 HTTP 中最常用的两个方法</strong>，基本上使用 HTTP 方法中有 99% 都是在使用 Get 方法和 Post 方法，所以有必要我们对这两个方法有更加深刻的认识。</p><ul><li><p>get 方法一般用于请求，比如你在浏览器地址栏输入 <code>www.cxuanblog.com</code> 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于``</p><p><code>表单</code>的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull/拉的操作，而 post 相当于是一个 push/推的操作。</p></li><li><p>get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/test/demo_form.asp?name1=value1&amp;name2=value</span><br></pre></td></tr></table></figure><p>而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure></li><li><p>get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</p></li><li><p>get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。（get请求数据会被浏览器缓存）</p></li><li><p>get 请求在浏览器反复的 <code>回退/前进</code> 操作是无害的，而 post 操作会再次提交表单请求。</p></li><li><p>get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</p></li><li><p>get请求的URL可以被保存为浏览器书签，而post请求不行。</p></li></ul><h3 id="1-7-HTTP是无状态协议？"><a href="#1-7-HTTP是无状态协议？" class="headerlink" title="1.7-HTTP是无状态协议？"></a>1.7-HTTP是无状态协议？</h3><p><code>无状态协议(Stateless Protocol)</code> 就是指<strong>浏览器对于事务的处理没有记忆能力</strong>。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p><p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 <code>小甜饼(Cookie)</code> 的机制。它能够让浏览器具有<code>记忆</code>能力。</p><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h4><p>如果你的浏览器允许 cookie 的话，查看方式 <strong>chrome://settings/content/cookies</strong></p><p>当你向服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/HTTP%E6%97%A0%E7%8A%B6%E6%80%81.png"></p><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/11212.png"></p><h4 id="2-JWT"><a href="#2-JWT" class="headerlink" title="2. JWT"></a>2. JWT</h4><p>还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点</p><ul><li>JWT 的 Cookie 信息存储在<code>客户端</code>，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。</li><li>JWT 支持跨域认证，Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</li></ul><h3 id="1-8-HTTP响应状态码"><a href="#1-8-HTTP响应状态码" class="headerlink" title="1.8-HTTP响应状态码"></a>1.8-HTTP响应状态码</h3><p>状态代码由服务器发出，以响应客户端对服务器的请求。</p><ul><li><strong>1xx（信息）</strong>：收到请求，继续处理</li><li><strong>2xx（成功）</strong>：请求已成功接收，理解和接受</li><li><strong>3xx（重定向）</strong>：需要采取进一步措施才能完成请求</li><li><strong>4xx（客户端错误）</strong>：请求包含错误的语法或无法满足</li><li><strong>5xx（服务器错误）</strong>：服务器无法满足明显有效的请求</li></ul><h4 id="1-1xx（信息）"><a href="#1-1xx（信息）" class="headerlink" title="1. 1xx（信息）"></a>1. 1xx（信息）</h4><ul><li><code>100</code>：客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</li><li><code>101</code>：服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</li><li><code>102</code>：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li></ul><h4 id="2-2xx（成功）"><a href="#2-2xx（成功）" class="headerlink" title="2. 2xx（成功）"></a>2. 2xx（成功）</h4><ul><li><p><code>200</code>：请求已成功，请求所希望的响应头或数据体将随此响应返回。</p></li><li><p><code>201</code>：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</p></li><li><p><code>202</code>：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p></li><li><p><code>203</code>：服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p></li><li><p><code>204</code>：服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p></li><li><p><code>205</code>：告诉用户代理（浏览器）重置发送该请求的文档。服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p></li><li><p><code>206</code>：服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><p>当客户端使用Range请求头时，返回该状态码。　　</p><p>该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。响应必须包含如下的头部域： 　　</p><p>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。</p></li><li><p><code>207</code>：由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p></li></ul><h4 id="3-3xx（重定向）"><a href="#3-3xx（重定向）" class="headerlink" title="3. 3xx（重定向）"></a>3. 3xx（重定向）</h4><ul><li><p><code>300</code>：返回多个响应，需要浏览器或者用户选择，请求的资源可在多处得到；</p></li><li><p><code>301</code>：永久重定向，在Location响应首部的值仍为当前URL(隐式重定向)；</p><p>请求资源的URL被永久的改变，新的URL会在响应的Location中给出。</p><p>浏览器到新的URL重新请求资源，因为有些客户端会把请求方式method改成GET。所以该状态码建议GET和HEAD方法中使用。</p></li><li><p><code>302</code>：临时重定向，在Location响应首部的值仍为新的URL(显示重定向)；</p><p>请求资源的URL被暂时修改到Location提供的URL。未来可能还会有新的修改。</p><p>浏览器会根据新的URL重新请求资源。有些客户端会把方法method改为GET，建议在GET和HEAD方法中使用。</p></li><li><p><code>303</code>：建议客户端访问其他URL或访问方式，服务通过返回的响应数据指导客户端通过GET方法去另一个URL获取资源，通常用于POST或者PUT的请求返回结果，重定向到信息提示页面或者进度展示页面。</p><p>重定向页面的方法是GET方法。</p></li><li><p><code>304</code>：Not Modified 请求的资源没有改变，可以继续使用缓存，服务器根据请求头判断，需要资源未修改，只返回响应头；否则将资源一起返回。</p></li><li><p><code>305</code>：请求的资源必须从服务器指定的地址得。</p></li><li><p><code>306</code>：在最新版的规范中，306状态码已经不再被使用。</p></li><li><p><code>307</code>：临时重定向，基本和302相同。</p><p>唯一的区别是这个状态码严格禁止浏览器到新URL请求资源时修改原来的请求方式和请求体。</p><p>就是说原来使用POST，这次还是要使用POST。</p><p>如果想要用PUT方法去修改一个服务器上没有的资源，可以用303状态码</p><p>如果想要把一个POST方法改为GET，请使用303。</p></li><li><p><code>308</code>：永久重定向。基本和301相同。但是严格禁止修改请求方式和请求体。</p></li></ul><h4 id="4-4xx（客户端错误）"><a href="#4-4xx（客户端错误）" class="headerlink" title="4. 4xx（客户端错误）"></a>4. 4xx（客户端错误）</h4><ul><li><code>400</code>：错误请求。由于语法错误，该请求无法完成；没有host请求头字段，或者设置了超过一个的host请求头字段。</li><li><code>401</code>：未经授权。服务器拒绝响应，客户端未授权该请求。缺乏有效的身份认证凭证，一般可能是未登陆。登陆后一般都解决问题。</li><li><code>403</code>：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</li><li><code>404</code>：URL无效或者URL有效但是没有资源。</li><li><code>405</code>：请求方式Method不允许。但是GET和HEAD属于强制方式，不能返回这个状态码。</li><li><code>406</code>：资源类型不符合服务器要求，请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</li><li><code>407</code>：与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</li><li><code>408</code>：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</li><li><code>426</code>：告诉客户端需要升级通信协议。</li></ul><h4 id="5-5xx（服务器错误）"><a href="#5-5xx（服务器错误）" class="headerlink" title="5. 5xx（服务器错误）"></a>5. 5xx（服务器错误）</h4><ul><li><code>500</code>：服务器内部错误，未捕获。</li><li><code>501</code>：服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li><li><code>502</code>：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li><code>503</code>：无法服务。一般发生在因维护而停机或者服务过载，由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。</li><li><code>504</code>：网关超时。服务器作为网关或者代理，不能及时从上游服务器获取响应返回给客户端。</li><li><code>505</code>：发出的请求http版本服务器不支持。如果请求通过http2发送，服务器不支持http2.0，就会返回该状态码。</li></ul><h3 id="1-9-HTTP-1-0、HTTP-1-1和HTTP-2-0"><a href="#1-9-HTTP-1-0、HTTP-1-1和HTTP-2-0" class="headerlink" title="1.9-HTTP-1.0、HTTP-1.1和HTTP-2.0"></a>1.9-HTTP-1.0、HTTP-1.1和HTTP-2.0</h3><h4 id="1-HTTP-1-0"><a href="#1-HTTP-1-0" class="headerlink" title="1. HTTP-1.0"></a>1. HTTP-1.0</h4><p>HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。</p><ul><li>HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。</li><li>HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li><li>HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li><li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。</li></ul><h4 id="2-HTTP-1-1"><a href="#2-HTTP-1-1" class="headerlink" title="2. HTTP-1.1"></a>2. HTTP-1.1</h4><p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化</p><ul><li>HTTP 1.1 使用了摘要算法来进行身份验证</li><li>HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</li><li>HTTP 1.1 支持断点续传，通过使用请求头中的 <code>Range</code> 来实现。</li><li>HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li></ul><p><strong>HTTP-1.1缺陷：</strong></p><ul><li><h4 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a><strong>队头阻塞</strong></h4><p>队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p><p>针对队头阻塞：</p><ol><li><p>将同一页面的资源分散到不同域名下，提升连接上限。虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。</p></li><li><p>减少请求数量</p></li><li><p>内联一些资源：css、base64 图片等</p></li><li><p>合并小文件减少资源数</p></li></ol></li><li><h4 id="无状态特性"><a href="#无状态特性" class="headerlink" title="无状态特性"></a><strong>无状态特性</strong></h4><p>无状态是指协议对于连接状态没有<strong>记忆能力</strong>。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。上一次请求验证了用户名密码，而下一次请求服务器并不知道它与上一条请求有何关联，换句话说就是<strong>掉登录态</strong>。</p></li><li><h4 id="不安全性"><a href="#不安全性" class="headerlink" title="不安全性"></a><strong>不安全性</strong></h4><p>传输内容没有加密，中途可能被篡改和劫持。</p></li></ul><h4 id="3-HTTP-2-0"><a href="#3-HTTP-2-0" class="headerlink" title="3. HTTP-2.0"></a>3. HTTP-2.0</h4><p>HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下</p><ul><li><code>头部压缩</code>，由于 HTTP 1.1 经常会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。使用专门的 HPACK 算法，每次请求和响应只发送差异头部，一般可以达到 50% ~90% 的高压缩率。</li><li><code>二进制格式</code>，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率</li><li><code>强化安全</code>，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。</li><li><code>多路复用</code>，即每一个请求都是是用作连接共享。一个请求对应一个id，这样一个连接上可以有多个请求。</li><li><code>请求优先级</code>，虽然无限的并发流解决了队头阻塞的问题，但如果带宽受限，客户端可能会因防止堵塞通道而阻止请求。在网络通道被非关键资源堵塞时，高优先级的请求会被优先处理。</li><li><code>服务端推送</code>，<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">服务端推送（ServerPush）</a>，可以让服务端主动把资源文件推送给客户端。当然客户端也有权利选择是否接收。</li></ul><h2 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2-HTTPS"></a>2-HTTPS</h2><h3 id="2-1-什么是HTTPS？"><a href="#2-1-什么是HTTPS？" class="headerlink" title="2.1-什么是HTTPS？"></a>2.1-什么是HTTPS？</h3><p>维基百科对 HTTPS 的解释是：</p><blockquote><p>超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为 HTTP over TLS、HTTP over SSL 或 HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在 1994 年首次提出，随后扩展到互联网上。</p></blockquote><p><strong>抓重点：HTTPS=HTTP over SSL/TLS，也就是说，HTTPS 在传输层 TCP 和应用层 HTTP 之间，多走了一层 SSL/TLS。</strong></p><p>由此可见，<strong>TLS/SSL 是 HTTPS 的核心！</strong> <strong>SSL和TLS都是加密协议</strong>。<strong>SSL</strong>，全称 Secure Socket Layer，在 1994 年由网景公司（Netscape）最早提出 1.0 版本；<strong>TLS</strong>，全称 Transport Layer Security，则是 1999 年基于 SSL3.0 版本上改进而来的。官方建议弃用 SSL 而保留和采用 TLS，但是由于历史原因，SSL 仍然存在，而且很多人已经习惯 SSL 这个名词，因此现在索性就叫成 SSL/TLS。</p><ul><li>HTTP协议(HyperText Transfer Protocol，超文本传输协议)是大家最熟悉的一种协议，它是一个用于传输超媒体文档的协议，它位于OSI网络协议模型的应用层。但是它是明文传输协议，是非常不安全的，容易被人篡改和窃取数据。</li><li>SSL(Secure Socket Layer) —— 网景(Netscape)公司设计的主要用于web的安全传输协议。它位于TCP传输层协议和应用层协议之间。（它没有被划分在OSI网络协议模型中，且认为它是应用层的子层。）</li><li>众所周知，网景公司20世纪90年代在和微软的竞争中最终败下阵来，之后网景公司将SSL协议的管理权转交给IETF(Internet Engineering Task Force, <a target="_blank" rel="noopener" href="http://www.ietf.org).于是ietf将ssl作了标准化,重新命名为tls.于是ietf将ssl作了标准化,重新命名为tls/">www.ietf.org)。于是IETF将SSL作了标准化，重新命名为TLS.xn--ietfssl%2Ctls-o68q04a8c50mt9nhxfc5e1qcb41ewo6bpjcqwqez6w/</a>)(Transport Layer Security)。在1999年，TLS 1.0诞生了（其实也就是SSL 3.1）。</li><li>HTTPS(HyperText Transfer Protocol Secure)是建立在SSL/TLS协议之上，信息通信通过SSL/TLS进行加密，最后一个S就是<code>Secure</code>的缩写，代表安全的意思，<code>HTTPS = HTTP + SSL/TLS</code>。</li></ul><p><img src="https://gitee.com/lemon-cs/images/raw/master/HTTP%E5%92%8CHTTPS.png"></p><h3 id="2-2-为什么需要HTTPS？"><a href="#2-2-为什么需要HTTPS？" class="headerlink" title="2.2-为什么需要HTTPS？"></a>2.2-为什么需要HTTPS？</h3><p>肯定有不少同学不假思索：“当然是 HTTP 不安全，HTTPS 安全，所以选择 HTTPS 呗！”那么，HTTPS 比 HTTP“好”在哪里？</p><p>维基百科上对 HTTP 的解释如下：</p><blockquote><p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p><p>HTTP 的发展是由蒂姆·伯纳斯-李于 1989 年在欧洲核子研究组织（CERN）所发起。HTTP 的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的 RFC，其中最著名的是 1999 年 6 月公布的 RFC 2616，定义了 HTTP 协议中现今广泛使用的一个版本——HTTP 1.1。</p></blockquote><p>HTTP 协议是为了传输网页超文本（文本、图像、多媒体资源），以及规范客户端和服务器端之间互相请求资源的方法的应用层协议。在 1989 年最早推出了 HTTP 0.9 版本，而 1999 年公布的 HTTP 1.1 是到目前（2020 年）仍旧广泛使用的版本（引自《<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37387316">HTTP 协议几个版本的比较</a>》）。</p><p>但是这个 HTTP 1.1 版本存在一个很大的问题-<strong>明文传输（Plaintext/Clear Text）</strong>，这个问题在互联网时代的今天是致命的，一旦数据在公共网络中被第三方截获，其通信内容轻而易举地就被窃取了。</p><p>因此，HTTPS 应运而生，它被公认的三大优势有：</p><ol><li><strong>数据加密，防窃听</strong></li><li><strong>身份验证，防冒充</strong></li><li><strong>完整性校验，防篡改</strong></li></ol><p>第 1 点确实是解决了 HTTP 明文传输；至于第 2 和第 3 点，其他一些应用层协议也会遇到（服务端被冒充、数据被篡改是网络传输中“较常见”的问题）。</p><ul><li>保护隐私(Privacy)：所有信息都是加密传播，第三方无法窃听数据。如果使用HTTP明文传输数据的话，很可能被第三方劫持数据，那么所输入的密码或者其他个人资料都被暴露在他人面前，后果可想而知。</li><li>数据完整性(Integraty)：一旦第三方篡改了数据，接收方会知道数据经过了篡改，这样便保证了数据在传输过程中不被篡改 —— 数据的完整性。</li><li>身份认证(Identification)：第三方不可能冒充身份参与通信，因为服务器配备了由证书颁发机构（Certificate Authority，简称CA）颁发的安全证书，可以证实服务器的身份信息，防止第三方冒充身份。（也有少数情况下，通信需要客户端提供证书，例如银行系统，需要用户在登录的时候，插入银行提供给用户的USB，就是需要客户端提供证书，用来验证客户的身份信息。）</li></ul><h3 id="2-3-SSL-TLS的工作原理"><a href="#2-3-SSL-TLS的工作原理" class="headerlink" title="2.3-SSL/TLS的工作原理"></a>2.3-SSL/TLS的工作原理</h3><p>我们探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。</p><p>TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。</p><p>每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。</p><p>TLS 具体的握手过程会根据所使用的<code>密钥交换算法的类型</code>和双方支持的<code>密码套件</code>而不同。我们以<code>RSA 非对称加密</code>来讨论这个过程。</p><p>需要理解SSL/TLS的工作原理，我们需要掌握加密算法。加密算法有两种：对称加密和非对称加密：</p><ul><li>对称加密：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。</li><li>非对称加密：它需要生成两个密钥：公钥(Public Key)和私钥(Private Key)。公钥顾名思义是公开的，任何人都可以获得，而私钥是私人保管的。相信大多程序员已经对这种算法很熟悉了：我们提交代码到github的时候，就可以使用SSH key：在本地生成私钥和公钥，私钥放在本地<code>.ssh</code>目录中，公钥放在github网站上，这样每次提交代码，不用麻烦的输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。公钥负责加密，私钥负责解密；或者，私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。</li></ul><p>SSL/TLS是利用了对称加密和非对称加密的特点。先来看下整个SSL/TLS的握手过程：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/SSL.png"></p><ul><li>在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程</li><li>ClientHello：客户端通过向服务器发送 <code>hello</code> 消息来发起握手过程。这个消息中会夹带着客户端支持的 <code>TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)</code> 、客户端支持的密码套件、以及一串 <code>客户端随机数</code>。</li><li>ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。</li><li>认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 <code>Certificate</code> 报文，报文中包含公开密钥证书。最后服务器发送 <code>ServerHelloDone</code> 作为 <code>hello</code> 请求的响应。第一部分握手阶段结束。</li><li><code>加密阶段</code>：在第一个阶段握手完成后，客户端会发送 <code>ClientKeyExchange</code> 作为响应，这个响应中包含了一种称为 <code>The premaster secret</code> 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 <code>ChangeCipherSpec</code>，告诉服务端使用私钥解密这个 <code>premaster secret</code> 的字符串，然后客户端发送 <code>Finished</code> 告诉服务端自己发送完成了。</li></ul><blockquote><p>Session key 其实就是用公钥证书加密的公钥。</p></blockquote><ul><li><code>实现了安全的非对称加密</code>：然后，服务器再发送 <code>ChangeCipherSpec</code> 和 <code>Finished</code> 告诉客户端解密完成，至此实现了 RSA 的非对称加密。</li></ul><h3 id="2-4-HTTPS的工作原理"><a href="#2-4-HTTPS的工作原理" class="headerlink" title="2.4-HTTPS的工作原理"></a>2.4-HTTPS的工作原理</h3><p>HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p><strong>① 证书验证阶段</strong></p><ol><li>浏览器发起 HTTPS 请求</li><li>服务端返回 HTTPS 证书</li><li>客户端验证证书是否合法，如果不合法则提示告警</li></ol><p><strong>② 数据传输阶段</strong></p><ol><li>当证书验证合法后，在本地生成随机数</li><li>通过公钥加密随机数，并把加密后的随机数传输到服务端</li><li>服务端通过私钥对随机数进行解密</li><li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</li></ol><h3 id="2-5-为什么数据传输是用对称加密？"><a href="#2-5-为什么数据传输是用对称加密？" class="headerlink" title="2.5-为什么数据传输是用对称加密？"></a>2.5-为什么数据传输是用对称加密？</h3><p>首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；</p><p>另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。</p><h3 id="2-6-为什么需要-CA-认证机构颁发证书？"><a href="#2-6-为什么需要-CA-认证机构颁发证书？" class="headerlink" title="2.6-为什么需要 CA 认证机构颁发证书？"></a>2.6-为什么需要 CA 认证机构颁发证书？</h3><p>HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。</p><p>首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的 <strong>“中间人攻击”</strong> 问题。<br>“中间人攻击”的具体过程如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png"></p><p>过程原理：</p><ol><li>本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</li><li>中间人服务器返回中间人自己的证书</li><li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li><li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li><li>中间人以客户端的请求内容再向正规网站发起请求</li><li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</li><li>中间人凭借与正规网站建立的对称加密算法对内容进行解密</li><li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</li><li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li></ol><p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p><h3 id="2-7-浏览器是如何确保-CA-证书的合法性？"><a href="#2-7-浏览器是如何确保-CA-证书的合法性？" class="headerlink" title="2.7-浏览器是如何确保 CA 证书的合法性？"></a>2.7-浏览器是如何确保 CA 证书的合法性？</h3><h4 id="1-证书包含什么信息？"><a href="#1-证书包含什么信息？" class="headerlink" title="1. 证书包含什么信息？"></a>1. 证书包含什么信息？</h4><ul><li>颁发机构信息</li><li>公钥</li><li>公司信息</li><li>域名</li><li>有效期</li><li>指纹</li><li>……</li></ul><h4 id="2-证书的合法性依据是什么？"><a href="#2-证书的合法性依据是什么？" class="headerlink" title="2. 证书的合法性依据是什么？"></a>2. 证书的合法性依据是什么？</h4><p>首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。</p><h4 id="3-浏览器如何验证证书的合法性？"><a href="#3-浏览器如何验证证书的合法性？" class="headerlink" title="3. 浏览器如何验证证书的合法性？"></a>3. 浏览器如何验证证书的合法性？</h4><p>浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：</p><ol><li><p>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</p></li><li><p>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%9D%E8%AF%81%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8.png"></p></li><li><p>判断证书是否被篡改。需要与 CA 服务器进行校验；</p></li><li><p>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率</p></li></ol><p>以上任意一步都满足的情况下浏览器才认为证书是合法的。</p><blockquote><p>这里插一个我想了很久的但其实答案很简单的问题：<br>既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？</p><p>其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。</p></blockquote><h4 id="5-只有认证机构可以生成证书吗？"><a href="#5-只有认证机构可以生成证书吗？" class="headerlink" title="5. 只有认证机构可以生成证书吗？"></a>5. 只有认证机构可以生成证书吗？</h4><p>如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的<br>HTTPS 传输。例如早期的 12306 采用的便是手动安装私有证书的形式实现 HTTPS 访问。</p><h4 id="2-8-本地随机数被窃取怎么办？"><a href="#2-8-本地随机数被窃取怎么办？" class="headerlink" title="2.8-本地随机数被窃取怎么办？"></a>2.8-本地随机数被窃取怎么办？</h4><p>证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS<br>如何保证随机数不会被窃取？</p><p>其实 HTTPS 并不包含对随机数的安全保证，HTTPS<br>保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。</p><h3 id="2-9-用了-HTTPS-会被抓包吗？"><a href="#2-9-用了-HTTPS-会被抓包吗？" class="headerlink" title="2.9-用了 HTTPS 会被抓包吗？"></a>2.9-用了 HTTPS 会被抓包吗？</h3><p>HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。</p><p>但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。通常<br>HTTPS<br>抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？<br>HTTPS可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。</p><blockquote><p>参考</p><p>——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1o270rwqrDC2rGfgSqTUuA">https://mp.weixin.qq.com/s/1o270rwqrDC2rGfgSqTUuA</a></p><p>——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DsnzPiGdciJM-_TM6tbmyQ">https://mp.weixin.qq.com/s/DsnzPiGdciJM-_TM6tbmyQ</a></p><p>——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FyB3Dlg0_2LpIF1x1ElIPA">https://mp.weixin.qq.com/s/FyB3Dlg0_2LpIF1x1ElIPA</a></p><p>——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DsnzPiGdciJM-_TM6tbmyQ">https://mp.weixin.qq.com/s/DsnzPiGdciJM-_TM6tbmyQ</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/05/11/HTTP%E5%92%8CHTTPS%E8%AF%A6%E8%A7%A3/">https://lemon-cs.github.io/2020/05/11/HTTP%E5%92%8CHTTPS%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/HTTPS/">HTTPS</a><a class="post-meta__tags" href="/tags/SSL/">SSL</a></div><div class="post_share"><div class="social-share" data-image="https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05/14/MySQL%E5%9F%BA%E7%A1%80%E5%92%8C%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2022/01/759f29a6471f2f3b.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL基础和详解</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/11/BIONIOAIO/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2021/12/adda988fb50270fe.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BIO-NIO-AIO</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E8%AF%A6%E8%A7%A3"><span class="toc-text">HTTP和HTTPS详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HTTP"><span class="toc-text">1-HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-HTTP%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1-HTTP介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-HTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">1.2-HTTP原理和工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HTTP%E5%8E%9F%E7%90%86"><span class="toc-text">1. HTTP原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HTTP%E5%8E%9F%E7%90%86"><span class="toc-text">2. HTTP原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-HTTP%E7%89%B9%E7%82%B9"><span class="toc-text">1.3-HTTP特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.4-URI和URL的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-HTTP%E7%9A%84%E6%8A%A5%E6%96%87%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1.5-HTTP的报文及其结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-text">1. 请求报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-text">2. 响应报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Get%E5%92%8CPost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.6-Get和Post的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">1.7-HTTP是无状态协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Cookie"><span class="toc-text">1. Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JWT"><span class="toc-text">2. JWT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">1.8-HTTP响应状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1xx%EF%BC%88%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="toc-text">1. 1xx（信息）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2xx%EF%BC%88%E6%88%90%E5%8A%9F%EF%BC%89"><span class="toc-text">2. 2xx（成功）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3xx%EF%BC%88%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%89"><span class="toc-text">3. 3xx（重定向）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4xx%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%EF%BC%89"><span class="toc-text">4. 4xx（客户端错误）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5xx%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF%EF%BC%89"><span class="toc-text">5. 5xx（服务器错误）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-HTTP-1-0%E3%80%81HTTP-1-1%E5%92%8CHTTP-2-0"><span class="toc-text">1.9-HTTP-1.0、HTTP-1.1和HTTP-2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HTTP-1-0"><span class="toc-text">1. HTTP-1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HTTP-1-1"><span class="toc-text">2. HTTP-1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-text">队头阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%89%B9%E6%80%A7"><span class="toc-text">无状态特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">不安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HTTP-2-0"><span class="toc-text">3. HTTP-2.0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HTTPS"><span class="toc-text">2-HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFHTTPS%EF%BC%9F"><span class="toc-text">2.1-什么是HTTPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81HTTPS%EF%BC%9F"><span class="toc-text">2.2-为什么需要HTTPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-SSL-TLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.3-SSL&#x2F;TLS的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.4-HTTPS的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%98%AF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-text">2.5-为什么数据传输是用对称加密？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-CA-%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E8%AF%81%E4%B9%A6%EF%BC%9F"><span class="toc-text">2.6-为什么需要 CA 认证机构颁发证书？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D-CA-%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9F"><span class="toc-text">2.7-浏览器是如何确保 CA 证书的合法性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%81%E4%B9%A6%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-text">1. 证书包含什么信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%E4%BE%9D%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2. 证书的合法性依据是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9F"><span class="toc-text">3. 浏览器如何验证证书的合法性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%AA%E6%9C%89%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%90%97%EF%BC%9F"><span class="toc-text">5. 只有认证机构可以生成证书吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-%E6%9C%AC%E5%9C%B0%E9%9A%8F%E6%9C%BA%E6%95%B0%E8%A2%AB%E7%AA%83%E5%8F%96%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">2.8-本地随机数被窃取怎么办？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E7%94%A8%E4%BA%86-HTTPS-%E4%BC%9A%E8%A2%AB%E6%8A%93%E5%8C%85%E5%90%97%EF%BC%9F"><span class="toc-text">2.9-用了 HTTPS 会被抓包吗？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s3.bmp.ovh/imgs/2022/01/759f29a6471f2f3b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2021/12/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2021-12-03T14:09:50.000Z" title="发表于 2021-12-03 22:09:50">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/16/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB"><img src="https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go操作MongoDB"></a><div class="content"><a class="title" href="/2021/11/16/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB">Go操作MongoDB</a><time datetime="2021-11-16T14:09:50.000Z" title="发表于 2021-11-16 22:09:50">2021-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/21/MyBatis%E4%B9%8B%E6%8F%92%E4%BB%B6/" title="MyBatis之插件-8"><img src="https://static01.imgkr.com/temp/fa403895570e4cafb459adbcdca97dbe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MyBatis之插件-8"></a><div class="content"><a class="title" href="/2020/07/21/MyBatis%E4%B9%8B%E6%8F%92%E4%BB%B6/" title="MyBatis之插件-8">MyBatis之插件-8</a><time datetime="2020-07-21T06:31:42.000Z" title="发表于 2020-07-21 14:31:42">2020-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/20/MyBatis%E4%B9%8B%E7%BC%93%E5%AD%98/" title="MyBatis之缓存-7"><img src="https://static01.imgkr.com/temp/31d9be0ee4fc43549ffe1bd007bc4e59.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MyBatis之缓存-7"></a><div class="content"><a class="title" href="/2020/07/20/MyBatis%E4%B9%8B%E7%BC%93%E5%AD%98/" title="MyBatis之缓存-7">MyBatis之缓存-7</a><time datetime="2020-07-20T06:31:42.000Z" title="发表于 2020-07-20 14:31:42">2020-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/19/MyBatis%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/" title="MyBatis之注解开发-6"><img src="/./images/scotland.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MyBatis之注解开发-6"></a><div class="content"><a class="title" href="/2020/07/19/MyBatis%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/" title="MyBatis之注解开发-6">MyBatis之注解开发-6</a><time datetime="2020-07-19T06:31:42.000Z" title="发表于 2020-07-19 14:31:42">2020-07-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>