<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis入门学习笔记 | Lemon-CS</title><meta name="keywords" content="Redis"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis基础和原理详解"><meta property="og:type" content="article"><meta property="og:title" content="Redis入门学习笔记"><meta property="og:url" content="https://lemon-cs.github.io/2020/05/05/Redis%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="Redis基础和原理详解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg"><meta property="article:published_time" content="2020-05-05T06:32:50.000Z"><meta property="article:modified_time" content="2021-12-31T07:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="Redis"><meta property="article:tag" content="缓存"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/05/05/Redis%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Redis入门学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-31 15:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis入门学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-05T06:32:50.000Z" title="发表于 2020-05-05 14:32:50">2020-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-31T07:37:35.000Z" title="更新于 2021-12-31 15:37:35">2021-12-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">51.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>194分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Redis入门学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis学习笔记"><a href="#Redis学习笔记" class="headerlink" title="Redis学习笔记"></a>Redis学习笔记</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1-概述"></a>1-概述</h2><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h3 id="1-1-Redis简介"><a href="#1-1-Redis简介" class="headerlink" title="1.1-Redis简介"></a>1.1-Redis简介</h3><ul><li>Redis 全称是 Remote Dictionary Server</li><li>Redis 是一种基于键值对(key-value)的NoSQL数据库，Redis的值可以是由string(字符串)、hash(哈希)、list(列表)、set(集合)、zset(有序集合)、Bitmaps(位图)、HyperLogLog、GEO(地理信息定位)等多种数据结构和算法组成；</li><li>Redis会将所有数据都存放在内存中，所以它的读写性能非常惊人；</li><li>Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样发生类似断电或者机器故障的时候，内存中的数据不会”丢失”;</li><li>Redis提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。</li></ul><h3 id="1-2-Redis特性"><a href="#1-2-Redis特性" class="headerlink" title="1.2-Redis特性"></a>1.2-Redis特性</h3><ul><li>速度快 (读写性能 10万/秒)<ul><li>Redis的所有数据都是存放在内存中</li><li>Redis是用C语言实现的</li><li>Redis使用了单线程架构，预防了多线程可能产生的竞争问题</li></ul></li><li>基于键值对的数据结构服务器</li><li>丰富的功能(键过期、发布订阅实现消息系统)</li><li>简单稳定</li><li>客户端语言多(支持Redis的客户端语言非常多,Java、PHP、Python、C、C++、Nodejs等)</li><li>持久化 (Redis 提供了两种持久化方式:RDB 和 AOF)</li><li>主从复制</li><li>高可用和分布式</li></ul><h3 id="1-3-为什么使用Redis"><a href="#1-3-为什么使用Redis" class="headerlink" title="1.3-为什么使用Redis"></a>1.3-为什么使用Redis</h3><p>主要是从两个角度去考虑:性能和并发。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p><h4 id="1-性能（缓存快速响应）"><a href="#1-性能（缓存快速响应）" class="headerlink" title="1. 性能（缓存快速响应）"></a>1. 性能（缓存快速响应）</h4><p>我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入 Redis 中缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p><blockquote><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。</p></blockquote><h4 id="2-并发（减少了数据库请求）"><a href="#2-并发（减少了数据库请求）" class="headerlink" title="2. 并发（减少了数据库请求）"></a>2. 并发（减少了数据库请求）</h4><p>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p><blockquote><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p></blockquote><h3 id="1-4-为什么要用-redis-而不用-map-guava-做缓存"><a href="#1-4-为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="1.4-为什么要用 redis 而不用 map/guava 做缓存?"></a>1.4-为什么要用 redis 而不用 map/guava 做缓存?</h3><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p><h3 id="1-5-Redis是如何执行的？"><a href="#1-5-Redis是如何执行的？" class="headerlink" title="1.5-Redis是如何执行的？"></a>1.5-Redis是如何执行的？</h3><h4 id="1-命令执行流程"><a href="#1-命令执行流程" class="headerlink" title="1. 命令执行流程"></a>1. 命令执行流程</h4><p>一条命令的执行过程有很多细节，但大体可分为：客户端先将用户输入的命令，转化为 Redis 相关的通讯协议，再用 socket 连接的方式将内容发送给服务器端，服务器端在接收到相关内容之后，先将内容转化为具体的执行命令，再判断用户授权信息和其他相关信息，当验证通过之后会执行最终命令，命令执行完之后，会进行相关的信息记录和数据统计，然后再把执行结果发送给客户端，这样一条命令的执行流程就结束了。如果是集群模式的话，主节点还会将命令同步至子节点，下面我们一起来看更加具体的执行流程。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><ul><li><p><strong>步骤一：用户输入一条命令</strong></p></li><li><p><strong>步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端</strong></p><p>客户端和服务器端是基于 socket 通信的，服务器端在初始化时会创建了一个 socket 监听，用于监测链接客户端的 socket 链接，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 开启 Socket 事件监听</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>socket 小知识：每个 socket 被创建后，会分配两个缓冲区，输入缓冲区和输出缓冲区。 写入函数并不会立即向网络中传输数据，而是先将数据写入缓冲区中，再由 TCP 协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是 TCP 协议负责的事情。 注意：数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。 读取函数也是如此，它也是从输入缓冲区中读取数据，而不是直接从网络中读取。</p></blockquote><p>当 socket 成功连接之后，客户端会先把命令转换成 Redis 通讯协议（RESP 协议，REdis Serialization Protocol）发送给服务器端，这个通信协议是为了保障服务器能最快速的理解命令的含义而制定的，如果没有这个通讯协议，那么 Redis 服务器端要遍历所有的空格以确认此条命令的含义，这样会加大服务器的运算量，而直接发送通讯协议，相当于把服务器端的解析工作交给了每一个客户端，这样会很大程度的提高 Redis 的运行速度。例如，当我们输入 <code>set key val</code> 命令时，客户端会把这个命令转换为 <code>*3\r\n$3\r\nSET\r\n$4\r\nKEY\r\n$4\r\nVAL\r\n</code> 协议发送给服务器端。 更多通讯协议，可访问官方文档：<code>https://redis.io/topics/protocol</code></p></li><li><p><strong>扩展知识：I/O 多路复用</strong></p><p>Redis 使用的是 I/O 多路复用功能来监听多 socket 链接的，这样就可以使用一个线程链接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作，从而大大提高了 Redis 的运行效率。</p><p><strong>I/O 多路复用机制如下图所示:</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><p>综合来说，此步骤的执行流程如下：</p><ul><li>与服务器端以 socket 和 I/O 多路复用的技术建立链接；</li><li>将命令转换为 Redis 通讯协议，再将这些协议发送至缓冲区。</li></ul></li><li><p><strong>步骤三：服务器端接收到命令</strong></p><p>服务器会先去输入缓冲中读取数据，然后判断数据的大小是否超过了系统设置的值(默认是 1GB)，如果大于此值就会返回错误信息，并关闭客户端连接。 默认大小如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/1231241412412.png"></p><p>当数据大小验证通过之后，服务器端会对输入缓冲区中的请求命令进行分析，提取命令请求中包含的命令参数，存储在 client 对象(服务器端会为每个链接创建一个 Client 对象)的属性中。</p></li><li><p><strong>步骤四：执行前准备</strong></p><p>① 判断是否为退出命令，如果是则直接返回；</p><p>② 非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；</p><p>③ 获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；</p><p>④ 用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；</p><p>⑤ 集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；</p><p>⑥ 检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；</p><p>⑦ 持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；</p><p>⑧ 集群模式最少从节点(slave)验证，如果是集群模式并且配置了 repl<em>min</em>slaves<em>to</em>write(最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；</p><p>⑨ 只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；</p><p>⑩ 客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。</p><p>⑪ 从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；</p><p>⑫ 服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；</p><p>⑬ lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；</p><p>⑭ 事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；</p><p>⑮ 监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。</p><p>当服务器经过以上操作之后，就可以执行真正的操作命令了。</p></li><li><p><strong>步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。</strong></p></li><li><p><strong>步骤六：执行完后相关记录和统计</strong></p><p>① 检查慢查询是否开启，如果开启会记录慢查询日志；</p><p>② 检查统计信息是否开启，如果开启会记录一些统计信息，例如执行命令所耗费时长和计数器(calls)加1；</p><p>③ 检查持久化功能是否开启，如果开启则会记录持久化信息；</p><p>④ 如果有其它从服务器正在复制当前服务器，则会将刚刚执行的命令传播给其他从服务器。</p></li><li><p><strong>步骤七：返回结果给客户端</strong></p><p>命令执行完之后，服务器会通过 socket 的方式把执行结果发送给客户端，客户端再把结果展示给用户，至此一条命令的执行就结束了。</p></li></ul><h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h4><p>当用户输入一条命令之后，客户端会以 socket 的方式把数据转换成 Redis 协议，并发送至服务器端，服务器端在接受到数据之后，会先将协议转换为真正的执行命令，在经过各种验证以保证命令能够正确并安全的执行，但验证处理完之后，会调用具体的方法执行此条命令，执行完成之后会进行相关的统计和记录，然后再把执行结果返回给客户端，整个执行流程，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><h2 id="2-Redis的安装和使用"><a href="#2-Redis的安装和使用" class="headerlink" title="2-Redis的安装和使用"></a>2-Redis的安装和使用</h2><p>Redis 是由 C 语言开发的开源内存数据存储器，经常被用作数据库、缓存以及消息队列等。 Redis 因为其强大的功能和简洁的设计，深受广大开发者和公司的喜爱，几乎占领了内存数据库市场的所有份额。</p><h3 id="2-1-Redis的特性"><a href="#2-1-Redis的特性" class="headerlink" title="2.1-Redis的特性"></a>2.1-Redis的特性</h3><h4 id="1-多种数据类型支持"><a href="#1-多种数据类型支持" class="headerlink" title="1. 多种数据类型支持"></a>1. 多种数据类型支持</h4><p>Redis 支持多种数据类型，例如字符串、散列、列表、集合、有序集合、HyperLogLog、流、地理坐标等，每种类型都有对应的使用场景，同时也满足了所有开发者的需要。</p><h4 id="2-功能完善"><a href="#2-功能完善" class="headerlink" title="2. 功能完善"></a>2. 功能完善</h4><p>Redis 提供了很多的功能，例如消息队列、自动过期删除、事务、数据持久化、分布式锁、附近的人、慢查询分析、Sentinel 和集群等多项功能。</p><h4 id="3-高性能"><a href="#3-高性能" class="headerlink" title="3. 高性能"></a>3. 高性能</h4><p>Redis 是一款内存型数据库，因此在性能方面有天生的优势(内存操作比磁盘操作要快很多)，并且 Redis 在底层使用了更加高效的算法和数据结构，以最大限度的提高了 Redis 的性能。</p><h4 id="4-广泛的编程语言支持"><a href="#4-广泛的编程语言支持" class="headerlink" title="4. 广泛的编程语言支持"></a>4. 广泛的编程语言支持</h4><p>Redis 客户端有众多的开发者提供了相应的支持，这些客户端可以在 <code>https://redis.io/clients</code> 上找到，支持是编程语言，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p><p>可以看出几乎所有的编程语言，都有相应的客户端支持。</p><h4 id="5-使用简单"><a href="#5-使用简单" class="headerlink" title="5. 使用简单"></a>5. 使用简单</h4><p>Redis 的 API 虽然比较丰富，但操作的方法都非常的简便，并且需要传递的参数也不多，这样开发者就能更快的上手使用，而且 Redis 官方也提供了比较完整的说明文档。</p><h4 id="6-活跃性高-版本迭代快"><a href="#6-活跃性高-版本迭代快" class="headerlink" title="6. 活跃性高/版本迭代快"></a>6. 活跃性高/版本迭代快</h4><p>Redis 活跃度很高，这点可以在 Redis 的开源项目 <code>https://github.com/antirez/redis</code> 中发现，并且 Redis 的版本迭代也很快，到目前为止 Redis 的发布版本就已经有二百多个了。</p><h4 id="7-I-O-多路复用模型"><a href="#7-I-O-多路复用模型" class="headerlink" title="7. I/O 多路复用模型"></a>7. I/O 多路复用模型</h4><p>Redis 使用了多路 I/O 复用模型，“多路”指的是多个网络连接，“复用”指的是复用同一个线程，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求，这样就减少了创建和销毁线程所带来的时间消耗，从而到达高效处理大量并发请求的目的。</p><h3 id="2-2-Redis-发展历程"><a href="#2-2-Redis-发展历程" class="headerlink" title="2.2-Redis 发展历程"></a>2.2-Redis 发展历程</h3><p>Redis 的发展大概经过了以下几个过程：</p><ul><li>2009 年 5 月发布 Redis 初始版本；</li><li>2012 年发布 Redis 2.6，重构了大量的核心代码，去掉了所有和集群相关的代码；</li><li>2013 年 11 月发布 Redis 2.8，增加了部分主从复制功能；</li><li>2015 年 4 月发布 Redis 3.0，增加了集群功能；</li><li>2017 年 7 月发布 Redis 4.0 ，优化了复制功能和新增了混合持久化；</li><li>2018 年 10 月发布 Redis 5.0，增加了 Stream 数据类型；</li><li>2020 年 3-5 月计划发布 Redis 6.0 稳定版。</li></ul><h3 id="2-3-Redis的安装"><a href="#2-3-Redis的安装" class="headerlink" title="2.3-Redis的安装"></a>2.3-Redis的安装</h3><p>Redis 官方提供了 Linux 和 MacOS 服务端安装包，对于 Windows 还有提供正式的支持，之所以不支持 Windows 平台是因为目前 Linux 版本已经很稳定，并且也有大量的用户，如果开发 Windows 版本可能会带来很多的兼容性问题，但 Windows 平台还是有很多种方法可以安装 Redis 的，我们先来看 Redis 在 Linux 和 MacOS 平台的安装。</p><h4 id="1-源码安装"><a href="#1-源码安装" class="headerlink" title="1. 源码安装"></a>1. 源码安装</h4><h5 id="①-下载源码包"><a href="#①-下载源码包" class="headerlink" title="① 下载源码包"></a>① 下载源码包</h5><p>进入网址：<code>https://redis.io/download</code> 选择需要安装的版本，点击 <code>Download</code> 按钮，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD.png"></p><h5 id="②-解压安装包"><a href="#②-解压安装包" class="headerlink" title="② 解压安装包"></a>② 解压安装包</h5><p>使用命令：tar zxvf redis-5.0.7.tar.gz</p><h5 id="③-切换到-Redis-目录"><a href="#③-切换到-Redis-目录" class="headerlink" title="③ 切换到 Redis 目录"></a>③ 切换到 Redis 目录</h5><p>使用命令：cd /usr/local/redis-5.0.7/</p><h5 id="④-编译安装"><a href="#④-编译安装" class="headerlink" title="④ 编译安装"></a>④ 编译安装</h5><p>使用命令：sudo make install 安装完成，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85.png"></p><p>如果没有异常信息输出，向上图所示，则表示 Redis 已经安装成功。</p><h4 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2. Docker 安装"></a>2. Docker 安装</h4><p>Docker 的使用前提是必须先有 Docker，如果本机没有安装 Docker，对于 Linux 用户来说，可使用命令 <code>yum -y install docker</code> 在线安装 docker，如果是非 Linux 平台需要在官网下载并安装 Docker Desker。</p><h5 id="①-拉取-Reids-镜像"><a href="#①-拉取-Reids-镜像" class="headerlink" title="① 拉取 Reids 镜像"></a>① 拉取 Reids 镜像</h5><p>使用命令：</p><blockquote><p>docker pull redis</p></blockquote><p>如果要安装其他版本的 Redis，可使用 <code>docker pull redis:版本号</code> 的方式来安装。</p><h5 id="②-运行-Redis-容器"><a href="#②-运行-Redis-容器" class="headerlink" title="② 运行 Redis 容器"></a>② 运行 Redis 容器</h5><p>使用命令：</p><blockquote><p>docker run –name myredis -d -p 6379:6379 redis</p></blockquote><p>其中：</p><ul><li>–name：设置别名</li><li>-p：映射宿主端口到容器端口</li><li>-d：表示后台运行</li></ul><p>执行完成后截图如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/745674574.png"></p><p>如图所示，则证明 Redis 已经正常启动了。 如果要查询 Redis 的安装版本，可遵循下图的执行流程，先进入容器，在进入 Redis 的安装目录，执行 <code>redis-server -v</code> 命令，如图如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/26344745756r.png"></p><h5 id="③-执行命令"><a href="#③-执行命令" class="headerlink" title="③ 执行命令"></a>③ 执行命令</h5><p>Docker 版的 Redis 命令执行和其他方式安装的 Redis 不太一样，所以这里需要单独讲一下，我们要使用 redis-cli 工具，需要执行以下命令：</p><blockquote><p>docker exec -it myredis redis-cli</p></blockquote><p>其中“myredis”指的是容器中 Redis 服务端的别名。</p><h3 id="2-4-Redis的使用"><a href="#2-4-Redis的使用" class="headerlink" title="2.4-Redis的使用"></a>2.4-Redis的使用</h3><p>Redis 安装完之后，在 src 目录和 /usr/local/bin 目录下有几个很重要的可执行文件，这些可执行文件可以做很多事，如下表所示：</p><table><thead><tr><th align="left">可执行文件</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">redis-server</td><td align="left">启动 Redis</td></tr><tr><td align="left">redis-cli</td><td align="left">Redis 命令行工具</td></tr><tr><td align="left">redis-benchmark</td><td align="left">基准测试工具</td></tr><tr><td align="left">redis-check-aof</td><td align="left">AOF 持久化文件检测工具和修复工具</td></tr><tr><td align="left">redis-check-dump</td><td align="left">RDB 持久化文件检测工具和修复工具</td></tr><tr><td align="left">redis-sentinel</td><td align="left">启动 redis-sentinel</td></tr></tbody></table><h4 id="1-启动-Redis"><a href="#1-启动-Redis" class="headerlink" title="1. 启动 Redis"></a>1. 启动 Redis</h4><p>下面我们就用可执行文件 <code>redis-server</code> 来启动 Redis 服务器，我们在 Redis 的安装目录执行 <code>src/redis-server</code> 命令就可以启动 Redis 服务了，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E5%90%AF%E5%8A%A8.png"></p><p>可以看出 Redis 已经正常启动了，但这种启动方式，会使得 Redis 服务随着控制台的关闭而退出，因为 Redis 服务默认是非后台启动的，我们需要修改配置文件(redis.conf)，找到 <code>daemonize no</code> 改为 <code>daemonize yes</code> ，然后重启服务，此时 Redis 就是以后台运行方式启动了，并且不会随着控制台的关闭而退出。</p><p>daemonize 配置如下：</p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/daemonize">https://gitee.com/lemon-cs/images/raw/master/daemonize</a> 配置.png)</p><h4 id="2-使用可视化工具操作-Redis"><a href="#2-使用可视化工具操作-Redis" class="headerlink" title="2. 使用可视化工具操作 Redis"></a>2. 使用可视化工具操作 Redis</h4><p>Redis 启动之后就可以使用一些客户端工具进行链接和操作，如下图所示：</p><p><strong>Redis Desktop Manager:</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7.png"></p><p>可以看出 Redis 服务器默认有 16 个数据库实例，从 db0 到 db15，但这个数据库实例和传统的关系型数据库实例是不一样的。传统型数据库实例是通过连接字符串配置的，而 Redis 数据库连接字符串只有一个，并不能指定要使用的数据库实例。</p><p>在 Redis 中如果要切换数据库实例，只需要执行 <code>select n</code> 命令即可，例如需要连接 db1 ，使用 <code>select 1</code> 命令选择即可，默认连接的数据库实例是 db0。</p><blockquote><p>小贴士：当使用了 <code>flushall</code> 清空 Redis 数据库时，此数据库下的所有数据都会被清除。</p></blockquote><p>Redis 数据库的实例个数也可以通过配置文件更改，在 redis.conf 中找到 <code>databases 16</code> ，修改后面的数字重启 Redis 服务就会生效。</p><h4 id="3-使用-redis-cli-操作-Redis"><a href="#3-使用-redis-cli-操作-Redis" class="headerlink" title="3. 使用 redis-cli 操作 Redis"></a>3. 使用 redis-cli 操作 Redis</h4><p>redis-cli 是官方自带的客户端链接工具，它可以配合命令行来对 Redis 进行操作，在 Redis 的安装目录使用 <code>src/redis-cli</code> 命令即可链接并操作 Redis，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/redis-cli.png"></p><h2 id="3-Redis的数据类型"><a href="#3-Redis的数据类型" class="headerlink" title="3-Redis的数据类型"></a>3-Redis的数据类型</h2><p>Redis 发展到现在已经有 9 种数据类型了，其中最基础、最常用的数据类型有 5 种，它们分别是：字符串类型、列表类型、哈希表类型、集合类型、有序集合类型，而在这 5 种数据类型中最常用的是字符串类型。</p><h3 id="3-1-字符串"><a href="#3-1-字符串" class="headerlink" title="3.1-字符串"></a>3.1-字符串</h3><p>字符串类型的全称是 Simple Dynamic Strings 简称 SDS，中文意思是：简单动态字符串。它是以键值对 key-value 的形式进行存储的，根据 key 来存储和获取 value 值，它的使用相对来说比较简单，但在实际项目中应用非常广泛。</p><h4 id="1-字符串类型能做什么？"><a href="#1-字符串类型能做什么？" class="headerlink" title="1. 字符串类型能做什么？"></a>1. 字符串类型能做什么？</h4><p>字符串类型的使用场景有很多，但从功能的角度来区分，大致可分为以下两种：</p><ul><li>字符串存储和操作；</li><li>整数类型和浮点类型的存储和计算。</li></ul><p>字符串最常用的业务场景有以下几个：</p><ul><li><h4 id="页面数据缓存"><a href="#页面数据缓存" class="headerlink" title="页面数据缓存"></a>页面数据缓存</h4><p>我们知道，一个系统最宝贵的资源就是数据库资源，随着公司业务的发展壮大，数据库的存储量也会越来越大，并且要处理的请求也越来越多，当数据量和并发量到达一定级别之后，数据库就变成了拖慢系统运行的“罪魁祸首”，为了避免这种情况的发生，我们可以把查询结果放入缓存(Redis)中，让下次同样的查询直接去缓存系统取结果，而非查询数据库，这样既减少了数据库的压力，同时也提高了程序的运行速度。</p><p>介于以上这个思路，我们可以把文章详情页的数据放入缓存系统。具体的做法是先将文章详情页序列化为字符串存入缓存，再从缓存中读取到字符串，反序列化成对象，然后再赋值到页面进行显示 (当然也可以用哈希类型进行存储)，这样我们就实现了文章详情页的缓存功能，架构流程对比图如下所示。</p><p>原始系统运行流程图：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%8E%9F%E5%A7%8B%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>引入缓存系统后的流程图：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%BC%95%E5%85%A5%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p></li><li><h4 id="数字计算与统计"><a href="#数字计算与统计" class="headerlink" title="数字计算与统计"></a>数字计算与统计</h4><p>Redis 可以用来存储整数和浮点类型的数据，并且可以通过命令直接累加并存储整数信息，这样就省去了每次先要取数据、转换数据、拼加数据、再存入数据的麻烦，只需要使用一个命令就可以完成此流程，具体实现过程本文下半部分会讲。这样我们就可以使用此功能来实现访问量的统计，当有人访问时访问量 +1 就可以了。</p></li><li><h4 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p><p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题。分布式系统每次会把请求随机分配到不同的服务器，因此我们需要借助缓存系统对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去统一的缓存系统获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p><p><strong>分布式系统单独存储 Session 流程图：</strong></p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/%E5%AD%98%E5%82%A8">https://gitee.com/lemon-cs/images/raw/master/存储</a> Session 流程图.png)</p><p><strong>分布式系统使用统一的缓存系统存储 Session 流程图：</strong></p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8">https://gitee.com/lemon-cs/images/raw/master/缓存系统存储</a> Session 流程图.png)</p></li></ul><h4 id="2-字符串如何使用？"><a href="#2-字符串如何使用？" class="headerlink" title="2. 字符串如何使用？"></a>2. 字符串如何使用？</h4><p>通常我们会使用两种方式来操作 Redis：第一种是使用命令行来操作，例如 redis-cli；另一种是使用代码的方式来操作，下面我们分别来看。</p><h5 id="1）命令行操作方式"><a href="#1）命令行操作方式" class="headerlink" title="1）命令行操作方式"></a>1）命令行操作方式</h5><p>字符串的操作命令有很多，但大体可分为以下几类：</p><ul><li>单个键值对操作</li><li>多个键值对操作</li><li>数字统计</li></ul><p>我们本文使用 redis-cli 来实现对 Redis 的操作，在使用命令之前，先输入 <code>redis-cli</code> 来链接到 Redis 服务器。</p><h6 id="①-单个键值对操作"><a href="#①-单个键值对操作" class="headerlink" title="① 单个键值对操作"></a>① 单个键值对操作</h6><ul><li><p><strong>添加键值对</strong></p><p>语法：set key value [expiration EX seconds|PX milliseconds] [NX|XX] 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set k1 val1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><h6 id="获取键值对"><a href="#获取键值对" class="headerlink" title="获取键值对"></a>获取键值对</h6><p>语法：get key 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;val1&quot;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="给元素追加值"><a href="#给元素追加值" class="headerlink" title="给元素追加值"></a>给元素追加值</h6><p>语法：append key value 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">append k1 <span class="title">append</span></span></span><br><span class="line"><span class="function"><span class="params">(integer)</span> 5</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; get k1</span></span><br><span class="line"><span class="function">&quot;v1append&quot;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="查询字符串的长度"><a href="#查询字符串的长度" class="headerlink" title="查询字符串的长度"></a>查询字符串的长度</h6><p>语法：strlen key 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">strlen <span class="title">k1</span></span></span><br><span class="line"><span class="function"><span class="params">(integer)</span> 5</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="②-多个键值对操作"><a href="#②-多个键值对操作" class="headerlink" title="② 多个键值对操作"></a>② 多个键值对操作</h6><ul><li><h6 id="创建一个或多个键值对"><a href="#创建一个或多个键值对" class="headerlink" title="创建一个或多个键值对"></a>创建一个或多个键值对</h6><p>语法：mset key value [key value …] 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; mset k2 v2 k3 v3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：mset 是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，不会出现某些 key 被更新，而另一些 key 没被更新的情况。</p></blockquote></li><li><h6 id="查询一个或多个元素"><a href="#查询一个或多个元素" class="headerlink" title="查询一个或多个元素"></a>查询一个或多个元素</h6><p>语法：mget key [key …] 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; mget k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="③-数字统计"><a href="#③-数字统计" class="headerlink" title="③ 数字统计"></a>③ 数字统计</h6><p>在 Redis 中可以直接操作整型和浮点型，例如可以直接使用命令来加、减值。</p><ul><li><h6 id="给整数类型的值加-1"><a href="#给整数类型的值加-1" class="headerlink" title="给整数类型的值加 1"></a>给整数类型的值加 1</h6><p>语法：incr key 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">incr <span class="title">k1</span></span></span><br><span class="line"><span class="function"><span class="params">(integer)</span> 4</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; get k1</span></span><br><span class="line"><span class="function">&quot;4&quot;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="给整数类型的值减-1"><a href="#给整数类型的值减-1" class="headerlink" title="给整数类型的值减 1"></a>给整数类型的值减 1</h6><p>语法：decr key 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">decr <span class="title">k1</span></span></span><br><span class="line"><span class="function"><span class="params">(integer)</span> 3</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; get k1</span></span><br><span class="line"><span class="function">&quot;3&quot;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="根据-key-减去指定的值"><a href="#根据-key-减去指定的值" class="headerlink" title="根据 key 减去指定的值"></a>根据 key 减去指定的值</h6><p>语法：decrby key decrement 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; decrby k1 <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行减法操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">get <span class="title">k2</span></span></span><br><span class="line"><span class="function"><span class="params">(nil)</span></span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; decrby k2 3</span></span><br><span class="line"><span class="function"><span class="params">(integer)</span> -3</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; get k2</span></span><br><span class="line"><span class="function">&quot;-3&quot;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="根据-key-加指定的整数值"><a href="#根据-key-加指定的整数值" class="headerlink" title="根据 key 加指定的整数值"></a>根据 key 加指定的整数值</h6><p>语法：incrby key increment 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby k1 <span class="number">2</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行加整数值的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">get <span class="title">k3</span></span></span><br><span class="line"><span class="function"><span class="params">(nil)</span></span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; incrby k3 5</span></span><br><span class="line"><span class="function"><span class="params">(integer)</span> 5</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; get k3</span></span><br><span class="line"><span class="function">&quot;5&quot;</span></span><br></pre></td></tr></table></figure></li><li><h6 id="根据-key-加上指定的浮点数"><a href="#根据-key-加上指定的浮点数" class="headerlink" title="根据 key 加上指定的浮点数"></a>根据 key 加上指定的浮点数</h6><p>语法：incrbyfloat key increment 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k3</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrbyfloat k3 <span class="number">4.9</span></span><br><span class="line"><span class="string">&quot;9.9&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get k3</span><br><span class="line"><span class="string">&quot;9.9&quot;</span></span><br></pre></td></tr></table></figure><p>如果 key 不存在，则会先初始化此 key 为 0 ，然后再执行加浮点数的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="function">get <span class="title">k4</span></span></span><br><span class="line"><span class="function"><span class="params">(nil)</span></span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; incrbyfloat k4 4.4</span></span><br><span class="line"><span class="function">&quot;4.4&quot;</span></span><br><span class="line"><span class="function">127.0.0.1:6379&gt; get k4</span></span><br><span class="line"><span class="function">&quot;4.4&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2）代码操作方式"><a href="#2）代码操作方式" class="headerlink" title="2）代码操作方式"></a>2）代码操作方式</h5><p>本文我们使用 Java 语言来实现对 Redis 的操作，首先我们在项目中添加对 Jedis 框架的引用，如果是 Maven 项目，我们会在 pom.xml 文件中添加如下信息：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Jedis 是 Redis 官方推荐的 Java 客户端开发包，用于实现快速简单的操作 Redis。添加完 Jedis 之后，我们来写具体的操作代码，操作函数与命令方式的调用比较相似，如下代码所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// jedis.auth(&quot;xxx&quot;); // 输入密码，没有密码，可以不设置</span></span><br><span class="line">        <span class="comment">// 添加一个元素</span></span><br><span class="line">        jedis.set(<span class="string">&quot;mystr&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        String myStr = jedis.get(<span class="string">&quot;mystr&quot;</span>);</span><br><span class="line">        System.out.println(myStr); <span class="comment">// 输出：redis</span></span><br><span class="line">        <span class="comment">// 添加多个元素(key,value,key2,value2)</span></span><br><span class="line">        jedis.mset(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;lang&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取多个元素</span></span><br><span class="line">        List&lt;String&gt; mlist = jedis.mget(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;lang&quot;</span>);</span><br><span class="line">        System.out.println(mlist);  <span class="comment">// 输出：[redis, java]</span></span><br><span class="line">        <span class="comment">// 给元素追加字符串</span></span><br><span class="line">        jedis.append(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;,mysql&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印追加的字符串</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;db&quot;</span>)); <span class="comment">// 输出：redis,mysql</span></span><br><span class="line">        <span class="comment">// 当 key 不存在时，赋值键值</span></span><br><span class="line">        Long setnx = jedis.setnx(<span class="string">&quot;db&quot;</span>, <span class="string">&quot;db2&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为 db 元素已经存在，所以会返回 0 条修改</span></span><br><span class="line">        System.out.println(setnx); <span class="comment">// 输出：0</span></span><br><span class="line">        <span class="comment">// 字符串截取</span></span><br><span class="line">        String range = jedis.getrange(<span class="string">&quot;db&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(range); <span class="comment">// 输出：red</span></span><br><span class="line">        <span class="comment">// 添加键值并设置过期时间(单位：毫秒)</span></span><br><span class="line">        String setex = jedis.setex(<span class="string">&quot;db&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        System.out.println(setex); <span class="comment">// 输出：ok</span></span><br><span class="line">        <span class="comment">// 查询键值的过期时间</span></span><br><span class="line">        Long ttl = jedis.ttl(<span class="string">&quot;db&quot;</span>);</span><br><span class="line">        System.out.println(ttl); <span class="comment">// 输出：1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-代码实战"><a href="#3-代码实战" class="headerlink" title="3. 代码实战"></a>3. 代码实战</h4><p>本文的上半部分我们讲到了字符串的很多种使用场景，本小节就以字符串存储用户对象信息为例，我们先将用户对象信息序列化为字符串存储在 Redis，再从 Redis 中取出字符串并反序列化为对象信息为例，使用 Java 语言来实现。</p><p>首先添加 JSON 转换类，用于对象和字符串之间的序列化和反序列化，我们这里采用 Google 的 Gson 来实现，首先在 pom.xml 文件中添加如下引用：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完 Gson 引用之后，我们来写具体的业务代码，先见用户信息序列化之后存储在 Redis 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"><span class="comment">// 构建用户数据</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Redis&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">10</span>);</span><br><span class="line">String jsonUser = gson.toJson(user);</span><br><span class="line"><span class="comment">// 打印用户信息(json)</span></span><br><span class="line">System.out.println(jsonUser); <span class="comment">// 输出：&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Redis&quot;,&quot;age&quot;:10&#125;</span></span><br><span class="line"><span class="comment">// 把字符串存入 Redis</span></span><br><span class="line">jedis.set(<span class="string">&quot;user&quot;</span>, jsonUser);</span><br></pre></td></tr></table></figure><p>当使用用户信息时，我们从 Redis 反序列化出来，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String getUserData = jedis.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">User userData = gson.fromJson(getUserData, User.class);</span><br><span class="line"><span class="comment">// 打印对象属性信息</span></span><br><span class="line">System.out.println(userData.getId() + <span class="string">&quot;:&quot;</span> + userData.getName()); <span class="comment">// 输出结果：1:Redis</span></span><br></pre></td></tr></table></figure><p>以上两个步骤就完成了用户信息存放至 Redis 中的过程，也是常用的经典使用场景之一。</p><h4 id="4-字符串的内部实现"><a href="#4-字符串的内部实现" class="headerlink" title="4. 字符串的内部实现"></a>4. 字符串的内部实现</h4><h5 id="1）源码分析"><a href="#1）源码分析" class="headerlink" title="1）源码分析"></a>1）源码分析</h5><p>Redis 3.2 之前 SDS 源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sds</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// 已占用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">// 剩余可以字节数</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 存储字符串的数据空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Redis 3.2 之前 SDS 内部是一个带有长度信息的字节数组，存储结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><p>为了更加有效的利用内存，Redis 3.2 优化了 SDS 的存储结构，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* 已使用长度，1 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 总长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 真正存储字符串的数据空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* 已使用长度，2 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* 已使用长度，4 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span> <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* 已使用长度，8 字节存储 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以针对不同长度的字符串申请相应的存储类型，从而有效的节约了内存使用。</p><h5 id="2）数据类型"><a href="#2）数据类型" class="headerlink" title="2）数据类型"></a>2）数据类型</h5><p>我们可以使用 <code>object encoding key</code> 命令来查看对象(键值对)存储的数据类型，当我们使用此命令来查询 SDS 对象时，发现 SDS 对象竟然包含了三种不同的数据类型：int、embstr 和 raw。</p><h6 id="①-int-类型"><a href="#①-int-类型" class="headerlink" title="① int 类型"></a>① int 类型</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 666</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure><h6 id="②-embstr-类型"><a href="#②-embstr-类型" class="headerlink" title="② embstr 类型"></a>② embstr 类型</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure><h6 id="③-raw-类型"><a href="#③-raw-类型" class="headerlink" title="③ raw 类型"></a>③ raw 类型</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key abcdefghigklmnopqrstyvwxyzabcdefghigklmnopqrs</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>int 类型很好理解，整数类型对应的就是 int 类型，而字符串则对应是 embstr 类型，当字符串长度大于 44 字节时，会变为 raw 类型存储。</p><h5 id="3）为什么是-44-字节？"><a href="#3）为什么是-44-字节？" class="headerlink" title="3）为什么是 44 字节？"></a>3）为什么是 44 字节？</h5><p>在 Redis 中，如果 SDS 的存储值大于 64 字节时，Redis 的内存分配器会认为此对象为大字符串，并使用 raw 类型来存储，当数据小于 64 字节时(字符串类型)，会使用 embstr 类型存储。既然内存分配器的判断标准是 64 字节，那为什么 embstr 类型和 raw 类型的存储判断值是 44 字节？</p><p>这是因为 Redis 在存储对象时，会创建此对象的关联信息，redisObject 对象头和 SDS 自身属性信息，这些信息都会占用一定的存储空间，因此长度判断标准就从 64 字节变成了 44 字节。</p><p>在 Redis 中，所有的对象都会包含 redisObject 对象头。我们先来看 redisObject 对象的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 4 bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// 3 个字节</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 4 个字节</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 8 个字节</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>它的参数说明如下：</p><ul><li>type：对象的数据类型，例如：string、list、hash 等，占用 4 bits 也就是半个字符的大小；</li><li>encoding：对象数据编码，占用 4 bits；</li><li>lru：记录对象的 LRU(Least Recently Used 的缩写，即最近最少使用)信息，内存回收时会用到此属性，占用 24 bits(3 字节)；</li><li>refcount：引用计数器，占用 32 bits(4 字节)；</li><li>*ptr：对象指针用于指向具体的内容，占用 64 bits(8 字节)。</li></ul><p>redisObject 总共占用 0.5 bytes + 0.5 bytes + 3 bytes + 4 bytes + 8 bytes = 16 bytes(字节)。</p><p>了解了 redisObject 之后，我们再来看 SDS 自身的数据结构，从 SDS 的源码可以看出，SDS 的存储类型一共有 5 种：SDS<em>TYPE</em>5、SDS<em>TYPE</em>8、SDS<em>TYPE</em>16、SDS<em>TYPE</em>32、SDS<em>TYPE</em>64，在这些类型中最小的存储类型为 SDS<em>TYPE</em>５，但 SDS<em>TYPE</em>５ 类型会默认转成 SDS<em>TYPE</em>8，以下源码可以证明，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/352365346346.png"></p><p>那我们直接来看 SDS<em>TYPE</em>8 的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出除了内容数组(buf)之外，其他三个属性分别占用了 1 个字节，最终分隔字符等于 64 字节，减去 redisObject 的 16 个字节，再减去 SDS 自身的 3 个字节，再减去结束符 <code>\0</code> 结束符占用 1 个字节，最终的结果是 44 字节(64-16-3-1=44)，内存占用如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8.png"></p><h4 id="5-更多字符串操作命令"><a href="#5-更多字符串操作命令" class="headerlink" title="5. 更多字符串操作命令"></a>5. 更多字符串操作命令</h4><h5 id="1-键值对过期操作"><a href="#1-键值对过期操作" class="headerlink" title="1) 键值对过期操作"></a>1) 键值对过期操作</h5><ul><li><h4 id="添加键值对并设置过期时间"><a href="#添加键值对并设置过期时间" class="headerlink" title="添加键值对并设置过期时间"></a>添加键值对并设置过期时间</h4><p>语法：set key value [expiration EX seconds|PX milliseconds] [NX|XX] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 val1 ex 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>设置键值对 k1=val1，过期时间为 1000 秒。 查询键的过期时间可以使用 ttl key，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 997</span><br></pre></td></tr></table></figure></li><li><h4 id="赋值字符串，并设置过期时间-单位-秒"><a href="#赋值字符串，并设置过期时间-单位-秒" class="headerlink" title="赋值字符串，并设置过期时间(单位/秒)"></a>赋值字符串，并设置过期时间(单位/秒)</h4><p>语法：setex key seconds value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex k1 1000 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 999</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><p>如果 key 已经存在，setex 命令将会覆写原来的旧值。</p></li><li><h4 id="赋值字符串，并设置过期时间-单位-毫秒"><a href="#赋值字符串，并设置过期时间-单位-毫秒" class="headerlink" title="赋值字符串，并设置过期时间(单位/毫秒)"></a>赋值字符串，并设置过期时间(单位/毫秒)</h4><p>与 setex 用法类似，只不过 psetex 设置的单位是毫秒。 语法：psetex key milliseconds value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psetex k1 100000 v11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 97</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v11&quot;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-字符串操作进阶"><a href="#2-字符串操作进阶" class="headerlink" title="2) 字符串操作进阶"></a>2) 字符串操作进阶</h5><ul><li><h4 id="根据指定的范围截取字符串"><a href="#根据指定的范围截取字符串" class="headerlink" title="根据指定的范围截取字符串"></a>根据指定的范围截取字符串</h4><p>语法：getrange key start end 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange hello 0 4</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange hello 0 -1</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange hello 0 -2</span><br><span class="line">&quot;hello worl&quot;</span><br></pre></td></tr></table></figure><p>负数表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。</p></li><li><h4 id="设置字符串新值并返回旧值"><a href="#设置字符串新值并返回旧值" class="headerlink" title="设置字符串新值并返回旧值"></a>设置字符串新值并返回旧值</h4><p>语法：getset key value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset db mysql</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;mysql&quot;</span><br></pre></td></tr></table></figure><p>使用 getset 命令时，如果 key 不为字符串会报错，如下效果所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type myset</span><br><span class="line">set</span><br><span class="line">127.0.0.1:6379&gt; getset myset v1</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p>根据 type 命令可以查询出 key 所对应的数据类型为非字符串，在使用 getset 命令就会报错。</p></li><li><h4 id="赋值-创建-键值对，当-key-不存在时"><a href="#赋值-创建-键值对，当-key-不存在时" class="headerlink" title="赋值(创建)键值对，当 key 不存在时"></a>赋值(创建)键值对，当 key 不存在时</h4><p>如果 key 已经存在，则执行命令无效，不会修改原来的值，否则会创建新的键值对。 语法：setnx key value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx k9 v9</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get k9</span><br><span class="line">&quot;v9&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx k9 v99</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k9</span><br><span class="line">&quot;v9&quot;</span><br></pre></td></tr></table></figure></li><li><h4 id="设置一个或多个键值，当所有键值都不存在时"><a href="#设置一个或多个键值，当所有键值都不存在时" class="headerlink" title="设置一个或多个键值，当所有键值都不存在时"></a>设置一个或多个键值，当所有键值都不存在时</h4><p>语法：msetnx key value [key value …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; msetnx k5 v5 k6 v6</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; mget k5 k6</span><br><span class="line">1) &quot;v5&quot;</span><br><span class="line">2) &quot;v6&quot;</span><br></pre></td></tr></table></figure><p>注意：msetnx 是一个原子操作，当一个操作失败时，其他操作也会失败。例如，如果有一个已经存在的值，那么全部键值都会设置失败，效果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;val1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k8</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k8 v8</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;val1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k8</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li><h4 id="截取字符串并赋值"><a href="#截取字符串并赋值" class="headerlink" title="截取字符串并赋值"></a>截取字符串并赋值</h4><p>语法：setrange key offset value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello java&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange hello 6 redis</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;hello redis&quot;</span><br></pre></td></tr></table></figure><p>如果待截取的键不存在，会当作空白字符串处理，效果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setrange mystr 3 mystring</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get mystring</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>以上这些命令基本涵盖了所有的字符串操作，有些不常用，但很好用，例如 <code>setnx key value</code> 命令，当 key 已经存在，则执行命令无效，并不会覆盖原有的值，如果没有此 key 则会新创建一个键值对。</p></li></ul><h3 id="3-2-字典类型（Hash）"><a href="#3-2-字典类型（Hash）" class="headerlink" title="3.2-字典类型（Hash）"></a>3.2-字典类型（Hash）</h3><p>字典类型 (Hash) 又被成为散列类型或者是哈希表类型，它是将一个键值 (key) 和一个特殊的“哈希表”关联起来，这个“哈希表”表包含两列数据：字段和值。例如我们使用字典类型来存储一篇文章的详情信息，存储结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Hash%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><p>同理我们也可以使用字典类型来存储用户信息，并且使用字典类型来存储此类信息，是不需要手动序列化和反序列化数据的，所以使用起来更加的方便和高效。</p><h4 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h4><p>首先我们使用命令行工具 redis-cli，来对字典类型进行相关的操作。</p><h5 id="1）插入单个元素"><a href="#1）插入单个元素" class="headerlink" title="1）插入单个元素"></a>1）插入单个元素</h5><p>语法：hset key field value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash key2 value2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h5 id="2）当某键不存在时，插入数据"><a href="#2）当某键不存在时，插入数据" class="headerlink" title="2）当某键不存在时，插入数据"></a>2）当某键不存在时，插入数据</h5><p>语法：hsetnx key field value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash k4 v4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k4</span><br><span class="line">&quot;v4&quot;</span><br></pre></td></tr></table></figure><p>如果<strong>尝试插入已存在的键</strong>，不会改变原来的值，示例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash k4 val4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k4</span><br><span class="line">&quot;v4&quot;</span><br></pre></td></tr></table></figure><p>尝试修改已经存在的 k4 赋值为 val4，但并没有生效，查询 k4 的结果依然是原来的值 v4。</p><h5 id="3）查询单个元素"><a href="#3）查询单个元素" class="headerlink" title="3）查询单个元素"></a>3）查询单个元素</h5><p>语法：hget key field 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash key1</span><br><span class="line">&quot;value1&quot;</span><br></pre></td></tr></table></figure><h5 id="4）删除-key-中的一个或多个元素"><a href="#4）删除-key-中的一个或多个元素" class="headerlink" title="4）删除 key 中的一个或多个元素"></a>4）删除 key 中的一个或多个元素</h5><p>语法：hdel myhash field [field …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash key1 key2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>注意：不能使用类似于 <code>hdel myhash</code> 的命令删除整个 Hash 值的。</p><h5 id="5）某个整数值累加计算"><a href="#5）某个整数值累加计算" class="headerlink" title="5）某个整数值累加计算"></a>5）某个整数值累加计算</h5><p>语法：hincrby key field increment 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash k3 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash k3 2</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; hget myhash k3</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure><h4 id="2-代码实战"><a href="#2-代码实战" class="headerlink" title="2. 代码实战"></a>2. 代码实战</h4><p>接下来我们用 Java 代码实现对 Redis 的操作，同样我们先引入 Jedis 框架 ，接下来再用代码来对字典类型进行操作，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 把 Key 值定义为变量</span></span><br><span class="line">        <span class="keyword">final</span> String REDISKEY = <span class="string">&quot;myhash&quot;</span>;</span><br><span class="line">        <span class="comment">// 插入单个元素</span></span><br><span class="line">        jedis.hset(REDISKEY, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询单个元素</span></span><br><span class="line">        Map&lt;String, String&gt; singleMap = jedis.hgetAll(REDISKEY);</span><br><span class="line">        System.out.println(singleMap.get(<span class="string">&quot;key1&quot;</span>));  <span class="comment">// 输出：value1</span></span><br><span class="line">        <span class="comment">// 查询所有元素</span></span><br><span class="line">        Map&lt;String, String&gt; allMap = jedis.hgetAll(REDISKEY);</span><br><span class="line">        System.out.println(allMap.get(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// 输出：val2</span></span><br><span class="line">        System.out.println(allMap); <span class="comment">// 输出：&#123;key1=value1, k1=val1, k2=val2, k3=9.2, k4=v4...&#125;</span></span><br><span class="line">        <span class="comment">// 删除单个元素</span></span><br><span class="line">        Long delResult = jedis.hdel(REDISKEY, <span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果：&quot;</span> + delResult);    <span class="comment">// 输出：删除结果：1</span></span><br><span class="line">        <span class="comment">// 查询单个元素</span></span><br><span class="line">        System.out.println(jedis.hget(REDISKEY, <span class="string">&quot;key1&quot;</span>)); <span class="comment">// 输出：返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，在 Jedis 中我们可以直接使用 Map 来接收 Redis 中读取的字典类型的数据，省去了手动转化的麻烦，还是比较方便的。</p><h4 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h4><p>字典类型本质上是由数组和链表结构组成的，来看字典类型的源码实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span> <span class="comment">// dict.h</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个 entry</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>字典类型的数据结构，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Hash%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p>通常情况下字典类型会使用数组的方式来存储相关的数据，但发生哈希冲突时才会使用链表的结构来存储数据。</p><h4 id="4-哈希冲突"><a href="#4-哈希冲突" class="headerlink" title="4. 哈希冲突"></a>4. 哈希冲突</h4><p>字典类型的存储流程是先将键值进行 Hash 计算，得到存储键值对应的数组索引，再根据数组索引进行数据存储，但在小概率事件下可能会出完全不相同的键值进行 Hash 计算之后，得到相同的 Hash 值，这种情况我们称之为<strong>哈希冲突</strong>。</p><p>哈希冲突一般通过链表的形式解决，相同的哈希值会对应一个链表结构，每次有哈希冲突时，就把新的元素插入到链表的尾部，请参考上面数据结构的那张图。</p><p>键值查询的流程如下：</p><ul><li>通过算法 (Hash，计算和取余等) 操作获得数组的索引值，根据索引值找到对应的元素；</li><li>判断元素和查找的键值是否相等，相等则成功返回数据，否则需要查看 next 指针是否还有对应其他元素，如果没有，则返回 null，如果有的话，重复此步骤。</li></ul><p>键值查询流程，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E9%94%AE%E5%80%BC%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png"></p><h4 id="5-渐进式rehash"><a href="#5-渐进式rehash" class="headerlink" title="5. 渐进式rehash"></a>5. 渐进式rehash</h4><p>Redis 为了保证应用的高性能运行，提供了一个重要的机制——渐进式 rehash。 渐进式 rehash 是用来保证字典缩放效率的，也就是说在字典进行扩容或者缩容是会采取渐进式 rehash 的机制。</p><h5 id="1-扩容"><a href="#1-扩容" class="headerlink" title="1) 扩容"></a>1) 扩容</h5><p>当元素数量等于数组长度时就会进行扩容操作，源码在 dict.c 文件中，核心代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 需要的容量小于当前容量，则不需要扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictht n; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size); <span class="comment">// 重新计算扩容后的值</span></span><br><span class="line">    <span class="comment">/* 计算新的扩容大小等于当前容量，不需要扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">/* 分配一个新的哈希表，并将所有指针初始化为NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次初始化</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n; <span class="comment">// 把增量输入放入新 ht[1] 中</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// 非默认值 -1，表示需要进行 rehash</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出，如果需要扩容则会申请一个新的内存地址赋值给 ht[1]，并把字典的 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p><h5 id="2-缩容"><a href="#2-缩容" class="headerlink" title="2) 缩容"></a>2) 缩容</h5><p>当字典的使用容量不足总空间的 10% 时就会触发缩容，Redis 在进行缩容时也会把 rehashindex 设置为 0，表示之后需要进行 rehash 操作。</p><h5 id="3-渐进式rehash流程"><a href="#3-渐进式rehash流程" class="headerlink" title="3) 渐进式rehash流程"></a>3) 渐进式rehash流程</h5><p>在进行渐进式 rehash 时，会同时保留两个 hash 结构，新键值对加入时会直接插入到新的 hash 结构中，并会把旧 hash 结构中的元素一点一点的移动到新的 hash 结构中，当移除完最后一个元素时，清空旧 hash 结构，主要的执行流程如下：</p><ul><li>扩容或者缩容时把字典中的字段 rehashidx 标识为 0；</li><li>在执行定时任务或者执行客户端的 hset、hdel 等操作指令时，判断是否需要触发 rehash 操作（通过 rehashidx 标识判断），如果需要触发 rehash 操作，也就是调用 dictRehash 函数，dictRehash 函数会把 ht[0] 中的元素依次添加到新的 Hash 表 ht[1] 中；</li><li>rehash 操作完成之后，清空 Hash 表 ht[0]，然后对调 ht[1] 和 ht[0] 的值，把新的数据表 ht[1] 更改为 ht[0]，然后把字典中的 rehashidx 标识为 -1，表示不需要执行 rehash 操作。</li></ul><h4 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. 使用场景</h4><p>哈希字典的典型使用场景如下：</p><ul><li>商品购物车，购物车非常适合用哈希字典表示，使用人员唯一编号作为字典的 key，value 值可以存储商品的 id 和数量等信息；</li><li>存储用户的属性信息，使用人员唯一编号作为字典的 key，value 值为属性字段和对应的值；</li><li>存储文章详情页信息等。</li></ul><h4 id="7-更多字典操作命令"><a href="#7-更多字典操作命令" class="headerlink" title="7. 更多字典操作命令"></a>7. 更多字典操作命令</h4><ul><li><h5 id="插入一个或多个元素"><a href="#插入一个或多个元素" class="headerlink" title="插入一个或多个元素"></a>插入一个或多个元素</h5><p>语法：hmset key field value [field value …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset myhash k1 val1 k2 val2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash k1 k2</span><br><span class="line">1) &quot;val1&quot;</span><br><span class="line">2) &quot;val2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询一个或多个元素-1"><a href="#查询一个或多个元素-1" class="headerlink" title="查询一个或多个元素"></a>查询一个或多个元素</h5><p>语法：hmget key field [field …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget myhash k1 k2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询某个-key-的所有字段"><a href="#查询某个-key-的所有字段" class="headerlink" title="查询某个 key 的所有字段"></a>查询某个 key 的所有字段</h5><p>语法：hkeys key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询某个-key-的所有值"><a href="#查询某个-key-的所有值" class="headerlink" title="查询某个 key 的所有值"></a>查询某个 key 的所有值</h5><p>语法：hvals key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询某个-key-的所有字段和值"><a href="#查询某个-key-的所有字段和值" class="headerlink" title="查询某个 key 的所有字段和值"></a>查询某个 key 的所有字段和值</h5><p>语法：hgetall key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="某个浮点值累加计算"><a href="#某个浮点值累加计算" class="headerlink" title="某个浮点值累加计算"></a>某个浮点值累加计算</h5><p>语法：hincrbyfloat key field increment 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrbyfloat myhash k3 2.2</span><br><span class="line">&quot;9.2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询元素是否存在"><a href="#查询元素是否存在" class="headerlink" title="查询元素是否存在"></a>查询元素是否存在</h5><p>语法：hexists key field 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists myhash key1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><h5 id="查询元素个数"><a href="#查询元素个数" class="headerlink" title="查询元素个数"></a>查询元素个数</h5><p>语法：hlen key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-列表（List）"><a href="#3-3-列表（List）" class="headerlink" title="3.3-列表（List）"></a>3.3-列表（List）</h3><p>列表类型 (List) 是一个使用链表结构存储的有序结构，它的元素插入会按照先后顺序存储到链表结构中，因此它的元素操作 (插入\删除) 时间复杂度为 O(1)，所以相对来说速度还是比较快的，但它的查询时间复杂度为 O(n)，因此查询可能会比较慢。</p><h4 id="1-基础使用-1"><a href="#1-基础使用-1" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h4><p>列表类型的使用相对来说比较简单，对它的操作就相当操作一个没有任何 key 值的 value 集合，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%88%97%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><ul><li><h5 id="给列表添加一个或多个元素"><a href="#给列表添加一个或多个元素" class="headerlink" title="给列表添加一个或多个元素"></a>给列表添加一个或多个元素</h5><p>语法：lpush key value [value …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li><li><h5 id="给列表尾部添加一个或多个元素"><a href="#给列表尾部添加一个或多个元素" class="headerlink" title="给列表尾部添加一个或多个元素"></a>给列表尾部添加一个或多个元素</h5><p>语法：rpush key value [value …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list2 1 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></li><li><h5 id="返回列表指定区间内的元素"><a href="#返回列表指定区间内的元素" class="headerlink" title="返回列表指定区间内的元素"></a>返回列表指定区间内的元素</h5><p>语法：lrange key start stop 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">&quot;3&quot;</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&quot;2&quot;</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>其中 -1 代表列表中的最后一个元素。</p></li><li><h5 id="获取并删除列表的第一个元素"><a href="#获取并删除列表的第一个元素" class="headerlink" title="获取并删除列表的第一个元素"></a>获取并删除列表的第一个元素</h5><p>语法：lpop key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="获取并删除列表的最后一个元素"><a href="#获取并删除列表的最后一个元素" class="headerlink" title="获取并删除列表的最后一个元素"></a>获取并删除列表的最后一个元素</h5><p>语法：rpop key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="根据下标获取对应的元素"><a href="#根据下标获取对应的元素" class="headerlink" title="根据下标获取对应的元素"></a>根据下标获取对应的元素</h5><p>语法：lindex key index 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list3 a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-代码实战-1"><a href="#2-代码实战-1" class="headerlink" title="2. 代码实战"></a>2. 代码实战</h4><p>下面来看列表类型在 Java 中的使用，同样先添加 Jedis 框架，使用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 声明 Redis key</span></span><br><span class="line">        <span class="keyword">final</span> String REDISKEY = <span class="string">&quot;list&quot;</span>;</span><br><span class="line">        <span class="comment">// 在头部插入一个或多个元素</span></span><br><span class="line">        Long lpushResult = jedis.lpush(REDISKEY, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Sql&quot;</span>);</span><br><span class="line">        System.out.println(lpushResult); <span class="comment">// 输出：2</span></span><br><span class="line">        <span class="comment">// 获取第 0 个元素的值</span></span><br><span class="line">        String idValue = jedis.lindex(REDISKEY, <span class="number">0</span>);</span><br><span class="line">        System.out.println(idValue); <span class="comment">// 输出：Sql</span></span><br><span class="line">        <span class="comment">// 查询指定区间的元素</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(REDISKEY, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">// 输出：[Sql, Java]</span></span><br><span class="line">        <span class="comment">// 在元素 Java 前面添加 MySQL 元素</span></span><br><span class="line">        jedis.linsert(REDISKEY, ListPosition.BEFORE, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">        System.out.println(jedis.lrange(REDISKEY, <span class="number">0</span>, -<span class="number">1</span>)); <span class="comment">// 输出：[Sql, MySQL, Java]</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><blockquote><p>2 Sql [Sql, Java] [Sql, MySQL, Java]</p></blockquote><h4 id="3-内部实现"><a href="#3-内部实现" class="headerlink" title="3. 内部实现"></a>3. 内部实现</h4><p>我们先用 <code>debug encoding key</code> 来查看列表类型的内部存储类型，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding list</span><br><span class="line">&quot;quicklist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，列表类型的底层数据类型是 quicklist。</p><p>quicklist (快速列表) 是 Redis 3.2 引入的数据类型，早期的列表类型使用的是ziplist (压缩列表) 和双向链表组成的，Redis 3.2 改为用 quicklist 来存储列表元素。</p><p>我们来看下 quicklist 的实现源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span> <span class="comment">// src/quicklist.h</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* ziplist 的个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* quicklist 的节点数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* LZF 压缩算法深度 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">/* 对应的 ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist 字节数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* ziplist 个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 该节点先前是否被压缩 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* 节点太小无法压缩 */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; </span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure><p>从以上源码可以看出 quicklist 是一个双向链表，链表中的每个节点实际上是一个 ziplist，它们的结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/quicklist%E7%BB%93%E6%9E%84.png"></p><p>ziplist 作为 quicklist 的实际存储结构，它本质是一个字节数组，ziplist 数据结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/ziplist%E7%BB%93%E6%9E%84.png"></p><p>其中的字段含义如下：</p><ul><li>zlbytes：压缩列表字节长度，占 4 字节；</li><li>zltail：压缩列表尾元素相对于起始元素地址的偏移量，占 4 字节；</li><li>zllen：压缩列表的元素个数；</li><li>entryX：压缩列表存储的所有元素，可以是字节数组或者是整数；</li><li>zlend：压缩列表的结尾，占 1 字节。</li></ul><h4 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4. 源码解析"></a>4. 源码解析</h4><p>下面我们来看一下更多关于列表类型的源码实现。</p><h5 id="1-添加功能源码分析"><a href="#1-添加功能源码分析" class="headerlink" title="1) 添加功能源码分析"></a>1) 添加功能源码分析</h5><p>quicklist 添加操作对应函数是 quicklistPush，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        <span class="comment">// 在列表头部添加元素</span></span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        <span class="comment">// 在列表尾部添加元素</span></span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 quicklistPushHead 为例，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        <span class="comment">// 在头部节点插入元素</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 头部节点不能继续插入，需要新建 quicklistNode、ziplist 进行插入</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新建的 quicklistNode 插入到 quicklist 结构中</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quicklistPushHead 函数的执行流程，先判断 quicklist 的 head 节点是否可以插入数据，如果可以插入则使用 ziplist 的接口进行插入，否则就新建 quicklistNode 节点进行插入。</p><p>函数的入参是待插入的 quicklist，还有需要插入的值 value 以及他的大小 sz。</p><p>函数的返回值为 int，0 表示没有新建 head，1 表示新建了 head。 quicklistPushHead 执行流程，如下图所示：</p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/quicklistPushHead">https://gitee.com/lemon-cs/images/raw/master/quicklistPushHead</a> 执行流程.png)</p><h5 id="2-删除功能源码分析"><a href="#2-删除功能源码分析" class="headerlink" title="2) 删除功能源码分析"></a>2) 删除功能源码分析</h5><p>quicklist 元素删除分为两种情况：单一元素删除和区间元素删除，它们都位于 src/quicklist.c 文件中。</p><h6 id="①-单一元素删除"><a href="#①-单一元素删除" class="headerlink" title="① 单一元素删除"></a>① 单一元素删除</h6><p>单一元素的删除函数是 quicklistDelEntry，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    <span class="keyword">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 quicklistDelEntry 函数的底层，依赖 quicklistDelIndex 函数进行元素删除。</p><h6 id="②-区间元素删除"><a href="#②-区间元素删除" class="headerlink" title="② 区间元素删除"></a>② 区间元素删除</h6><p>区间元素删除的函数是 quicklistDelRange，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start 表示开始删除的下标，count 表示要删除的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extent = count; </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// 删除的元素个数大于已有元素</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// 删除指定的元素个数</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// extent 为剩余需要删除的元素个数，</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 保存下个 quicklistNode，因为本节点可能会被删除</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> del;</span><br><span class="line">        <span class="keyword">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 删除整个 quicklistNode</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">           <span class="comment">// 删除本节点的所有元素</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// entry.offset&lt;0 表示从后向前，相反则表示从前向后剩余的元素个数</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除本节点部分元素</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line">        D(<span class="string">&quot;[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), &quot;</span></span><br><span class="line">          <span class="string">&quot;node count: %u&quot;</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余待删除元素的个数</span></span><br><span class="line">        extent -= del;</span><br><span class="line">        <span class="comment">// 下个 quicklistNode</span></span><br><span class="line">        node = next;</span><br><span class="line">        <span class="comment">// 从下个 quicklistNode 起始位置开始删除</span></span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p><p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p><h5 id="3-更多源码"><a href="#3-更多源码" class="headerlink" title="3) 更多源码"></a>3) 更多源码</h5><p>除了上面介绍的几个常用函数之外，还有一些更多的函数，例如：</p><ul><li>quicklistCreate：创建 quicklist；</li><li>quicklistInsertAfter：在某个元素的后面添加数据；</li><li>quicklistInsertBefore：在某个元素的前面添加数据；</li><li>quicklistPop：取出并删除列表的第一个或最后一个元素；</li><li>quicklistReplaceAtIndex：替换某个元素。</li></ul><h4 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h4><p>列表的典型使用场景有以下两个：</p><ul><li>消息队列：列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列；</li><li>文章列表：对于博客站点来说，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。</li></ul><p>列表类型并不是简单的双向链表，而是采用了 quicklist 的数据结构对数据进行存取，quicklist 是 Redis 3.2 新增的数据类型，它的底层采取的是压缩列表加双向链表的存储结构，quicklist 为了存储更多的数据，会对每个 quicklistNode 节点进行压缩，这样就可以有效的存储更多的消息队列或者文章的数据了。</p><h4 id="6-更多列表操作命令"><a href="#6-更多列表操作命令" class="headerlink" title="6. 更多列表操作命令"></a>6. 更多列表操作命令</h4><ul><li><h5 id="在某值之前-之后添加某个元素"><a href="#在某值之前-之后添加某个元素" class="headerlink" title="在某值之前/之后添加某个元素"></a>在某值之前/之后添加某个元素</h5><p>语法：linsert key before|after pivot value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; linsert list3 before b A</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list3 0 -1</span><br><span class="line">&quot;a&quot;</span><br><span class="line">&quot;A&quot;</span><br><span class="line">&quot;b&quot;</span><br><span class="line">&quot;c&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="根据下标修改元素"><a href="#根据下标修改元素" class="headerlink" title="根据下标修改元素"></a>根据下标修改元素</h5><p>语法：lset key index value 示例<em>：</em></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list3 0 A</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lindex list3 0</span><br><span class="line">&quot;A&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="根据下标删除元素"><a href="#根据下标删除元素" class="headerlink" title="根据下标删除元素"></a>根据下标删除元素</h5><p>语法：ltrim key start stop 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list a b c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ltrim list 0 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询列表的长度"><a href="#查询列表的长度" class="headerlink" title="查询列表的长度"></a>查询列表的长度</h5><p>语法：llen key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><h5 id="删除指定个数的元素"><a href="#删除指定个数的元素" class="headerlink" title="删除指定个数的元素"></a>删除指定个数的元素</h5><p><strong>语法</strong>：lrem key count value 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list a a b b c c</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 a</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-集合类型-Set"><a href="#3-4-集合类型-Set" class="headerlink" title="3.4-集合类型 (Set)"></a>3.4-集合类型 (Set)</h3><p>集合类型 (Set) 是一个无序并唯一的键值集合。</p><p>之所以说集合类型是一个无序集合，是因为它的存储顺序不会按照插入的先后顺序进行存储，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset v2 v1 v3 #插入数据 v2、v1、v3 </span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset #查询数据</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>从上面代码执行结果可以看出，myset 的存储顺序并不是以插入的先后顺序进行存储的。</p><p>集合类型和列表类型的区别如下：</p><ul><li>列表可以存储重复元素，集合只能存储非重复元素；</li><li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li></ul><h4 id="1-基础使用-2"><a href="#1-基础使用-2" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h4><p>集合类型的功能比列表类型丰富一些，集合类型可以用来统计多个集合的交集、错集和并集，如下代码所示。</p><h5 id="1）添加一个或多个元素"><a href="#1）添加一个或多个元素" class="headerlink" title="1）添加一个或多个元素"></a>1）添加一个或多个元素</h5><p>语法：sadd key member [member …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset v1 v2 v3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h5 id="2）查询集合所有元素"><a href="#2）查询集合所有元素" class="headerlink" title="2）查询集合所有元素"></a>2）查询集合所有元素</h5><p>语法：smembers key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br></pre></td></tr></table></figure><h5 id="3）查询集合的成员数量"><a href="#3）查询集合的成员数量" class="headerlink" title="3）查询集合的成员数量"></a>3）查询集合的成员数量</h5><p>语法：scard key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h5 id="4）查询集合中是否包含某个元素"><a href="#4）查询集合中是否包含某个元素" class="headerlink" title="4）查询集合中是否包含某个元素"></a>4）查询集合中是否包含某个元素</h5><p>语法：sismember key member 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember myset v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset v4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h5 id="5）从一个集合中移动一个元素到另一个集合"><a href="#5）从一个集合中移动一个元素到另一个集合" class="headerlink" title="5）从一个集合中移动一个元素到另一个集合"></a>5）从一个集合中移动一个元素到另一个集合</h5><p>语法：smove source destination member 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 v3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><h5 id="6）移除集合中一个或多个元素"><a href="#6）移除集合中一个或多个元素" class="headerlink" title="6）移除集合中一个或多个元素"></a>6）移除集合中一个或多个元素</h5><p>语法：srem key member [member …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;v5&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem myset v5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v1&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br></pre></td></tr></table></figure><p>注意：使用 srem 指令，不存在的元素将会被忽略。</p><h4 id="2-代码实战-2"><a href="#2-代码实战-2" class="headerlink" title="2. 代码实战"></a>2. 代码实战</h4><p>下面来看集合类型在 Java 中的使用，同样先添加 Jedis 框架，使用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建集合并添加元素</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询集合中的所有元素</span></span><br><span class="line">        Set&lt;String&gt; members = jedis.smembers(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(members); <span class="comment">// 输出：[java, golang]</span></span><br><span class="line">        <span class="comment">// 查询集合中的元素数量</span></span><br><span class="line">        System.out.println(jedis.scard(<span class="string">&quot;set1&quot;</span>));</span><br><span class="line">        <span class="comment">// 移除集合中的一个元素</span></span><br><span class="line">        jedis.srem(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        System.out.println(jedis.smembers(<span class="string">&quot;set1&quot;</span>)); <span class="comment">// 输出：[java]</span></span><br><span class="line">        <span class="comment">// 创建集合 set2 并添加元素</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;golang&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询两个集合中交集</span></span><br><span class="line">        Set&lt;String&gt; inters = jedis.sinter(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(inters); <span class="comment">// 输出：[java]</span></span><br><span class="line">        <span class="comment">// 查询两个集合中并集</span></span><br><span class="line">        Set&lt;String&gt; unions = jedis.sunion(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">        System.out.println(unions); <span class="comment">// 输出：[java,golang]</span></span><br><span class="line">        <span class="comment">// 查询两个集合的错集</span></span><br><span class="line">        Set&lt;String&gt; diffs = jedis.sdiff(<span class="string">&quot;set2&quot;</span>, <span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(diffs); <span class="comment">// 输出：[golang]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-内部实现-1"><a href="#3-内部实现-1" class="headerlink" title="3. 内部实现"></a>3. 内部实现</h4><p>集合类型是由 intset (整数集合) 或 hashtable (普通哈希表) 组成的。当集合类型以 hashtable 存储时，哈希表的 key 为要插入的元素值，而哈希表的 value 则为 Null，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%93%E6%9E%84.png"></p><p>当集合中所有的值都为整数时，Redis 会使用 intset 结构来存储，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset 1 9 3 -2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding myset</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>当所有元素都为整数时，集合会以 intset 结构进行(数据)存储</strong>。 当发生以下两种情况时，会导致集合类型使用 hashtable 而非 intset 存储： 1）当元素的个数超过一定数量时，默认是 512 个，该值可通过命令 <code>set-max-intset-entries xxx</code> 来配置。 2）当元素为非整数时，集合将会使用 hashtable 来存储，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myht &quot;redis&quot; &quot;db&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding myht</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>当元素为非整数时，集合会使用 hashtable 进行存储</strong>。</p><h4 id="4-源码解析-1"><a href="#4-源码解析-1" class="headerlink" title="4. 源码解析"></a>4. 源码解析</h4><p>集合源码在 t_set.c 文件中，核心源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 添加元素到集合</span></span><br><span class="line"><span class="comment"> * 如果当前值已经存在，则返回 0 不作任何处理，否则就添加该元素，并返回 1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 字典类型</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 把 value 作为字典到 key，将 Null 作为字典到 value，将元素存入到字典</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// inset 数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">// 超过 inset 的最大存储数量，则使用字典类型存储</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转化为整数类型失败，使用字典类型存储</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未知编码(类型)</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些代码验证了，我们上面所说的内容，当元素都为整数并且元素的个数没有到达设置的最大值时，键值的存储使用的是 intset 的数据结构，反之到元素超过了一定的范围，又或者是存储的元素为非整数时，集合会选择使用 hashtable 的数据结构进行存储。</p><h4 id="5-使用场景-1"><a href="#5-使用场景-1" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h4><p>集合类型的经典使用场景如下：</p><ul><li>微博关注我的人和我关注的人都适合用集合存储，可以保证人员不会重复；</li><li>中奖人信息也适合用集合类型存储，这样可以保证一个人不会重复中奖。</li></ul><p>集合类型是由整数集合 (intset) 或者是哈希表 (hashtable) 组成的，集合类型比较适合用来数据去重和保障数据的唯一性，除此之外，集合类型还可以用来统计多个集合的交集、错集和并集 。当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><h4 id="6-更多集合操作命令"><a href="#6-更多集合操作命令" class="headerlink" title="6. 更多集合操作命令"></a>6. 更多集合操作命令</h4><ul><li><h5 id="移除并返回集合中的一个随机元素"><a href="#移除并返回集合中的一个随机元素" class="headerlink" title="移除并返回集合中的一个随机元素"></a>移除并返回集合中的一个随机元素</h5><p>语法：spop key [count] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset 1</span><br><span class="line">1) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="随机返回集合中指定数量的元素列表"><a href="#随机返回集合中指定数量的元素列表" class="headerlink" title="随机返回集合中指定数量的元素列表"></a>随机返回集合中指定数量的元素列表</h5><p>语法：srandmember key [count] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="返回一个集合或多个集合的交集"><a href="#返回一个集合或多个集合的交集" class="headerlink" title="返回一个集合或多个集合的交集"></a>返回一个集合或多个集合的交集</h5><p>语法：sinter key [key …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter myset myset2</span><br><span class="line">1) &quot;v1&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="把集合的交集复制到新的集合中"><a href="#把集合的交集复制到新的集合中" class="headerlink" title="把集合的交集复制到新的集合中"></a>把集合的交集复制到新的集合中</h5><p>语法：sinterstore destination key [key …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v8&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinterstore myset3 myset myset2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset3</span><br><span class="line">1) &quot;v1&quot;</span><br></pre></td></tr></table></figure><p>命令解析：从以上代码可以看出，我们把集合 myset 和 集合 myset2 的合集元素 v1 复制到了新的集合 myset3 中，但 v1 并不会从原有集合中移除。</p></li><li><h5 id="查询一个或多个集合的并集"><a href="#查询一个或多个集合的并集" class="headerlink" title="查询一个或多个集合的并集"></a>查询一个或多个集合的并集</h5><p>语法：sunion key [key …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion group1 group2</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="把一个或多个集合的并集复制到新集合中"><a href="#把一个或多个集合的并集复制到新集合中" class="headerlink" title="把一个或多个集合的并集复制到新集合中"></a>把一个或多个集合的并集复制到新集合中</h5><p>语法：sunionstore destination key [key …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunionstore group3 group1 group2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers group3</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br></pre></td></tr></table></figure><p>注意：只是把一个或多个集合的并集复制到新集合中，并不会在原集合中删除复制的元素。</p></li><li><h5 id="查询一个或多个集合的错集"><a href="#查询一个或多个集合的错集" class="headerlink" title="查询一个或多个集合的错集"></a>查询一个或多个集合的错集</h5><p>语法：sdiff key [key …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff group1 group2</span><br><span class="line">1) &quot;java&quot;</span><br></pre></td></tr></table></figure><p>注意：执行命令时集合的先后顺序会影响返回的结果，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sdiff group1 group2</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff group2 group1</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure><p>这是因为查询错集是以第一个集合为主的，当第二个元素包含第一个元素时，查询的错集结果就是空。</p></li><li><h5 id="把一个或多个集合的错集复制到新集合"><a href="#把一个或多个集合的错集复制到新集合" class="headerlink" title="把一个或多个集合的错集复制到新集合"></a>把一个或多个集合的错集复制到新集合</h5><p>语法：sdiffstore destination key [key …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers group1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers group2</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiffstore group3 group1 group2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers group3</span><br><span class="line">1) &quot;java&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-有序集合类型-Sorted-Set"><a href="#3-5-有序集合类型-Sorted-Set" class="headerlink" title="3.5-有序集合类型 (Sorted Set)"></a>3.5-有序集合类型 (Sorted Set)</h3><p>有序集合类型 (Sorted Set) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合的存储元素值也是不能重复的，但分值是可以重复的。</p><p>当我们把学生的成绩存储在有序集合中时，它的存储结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><h4 id="1-基础使用-3"><a href="#1-基础使用-3" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h4><h5 id="1）添加一个或多个元素-1"><a href="#1）添加一个或多个元素-1" class="headerlink" title="1）添加一个或多个元素"></a>1）添加一个或多个元素</h5><p>语法：zadd key [NX|XX] [CH] [INCR] score member [score member …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset1 10 java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 3 golang 4 sql 1 redis</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>可以看出有序集合的添加是 <code>zadd 键值 分值1 元素值1 分值2 元素值2</code> 的形式添加的。</p><h5 id="2）查询所有元素列表"><a href="#2）查询所有元素列表" class="headerlink" title="2）查询所有元素列表"></a>2）查询所有元素列表</h5><p>语法：zrange key start stop [WITHSCORES] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;mysql&quot;</span><br><span class="line">3) &quot;java&quot;</span><br></pre></td></tr></table></figure><p>其中 -1 表示最后一个元素，查询结果包含开始和结束元素。</p><h5 id="3）删除一个或多个元素-根据元素值"><a href="#3）删除一个或多个元素-根据元素值" class="headerlink" title="3）删除一个或多个元素(根据元素值)"></a>3）删除一个或多个元素(根据元素值)</h5><p>语法：zrem key member [member …] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;sql&quot;</span><br><span class="line">4) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem zset1 redis sql #删除元素：reids、sql</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;java&quot;</span><br></pre></td></tr></table></figure><p>删除命令中如果包含了不存在的元素，并不会影响命令的正常执行，不存在的元素将会被忽略。</p><h5 id="4）查询某元素的-score-值"><a href="#4）查询某元素的-score-值" class="headerlink" title="4）查询某元素的 score 值"></a>4）查询某元素的 score 值</h5><p>语法：zscore key member 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 redis</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h5 id="5）查询-score-区间内元素"><a href="#5）查询-score-区间内元素" class="headerlink" title="5）查询 score 区间内元素"></a>5）查询 score 区间内元素</h5><p>语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count] 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrangebyscore zset1 3 10</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;sql&quot;</span><br><span class="line">4) &quot;java&quot;</span><br></pre></td></tr></table></figure><h5 id="6）查询某元素排名"><a href="#6）查询某元素排名" class="headerlink" title="6）查询某元素排名"></a>6）查询某元素排名</h5><p>语法：zrank key member 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset 5 redis 10 java 8 mysql #创建有序集合</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrank zset java #查询元素排序</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrank zset redis</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>可以看出，排名是从 0 开始的，排名可以理解为元素排序后的下标值。</p><h4 id="2-代码实战-3"><a href="#2-代码实战-3" class="headerlink" title="2. 代码实战"></a>2. 代码实战</h4><p>下面来看有序集合在 Java 中的使用，同样先添加 Jedis 框架，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZSetExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;小明&quot;</span>, <span class="number">80.5d</span>);</span><br><span class="line">        map.put(<span class="string">&quot;小红&quot;</span>, <span class="number">75d</span>);</span><br><span class="line">        map.put(<span class="string">&quot;老王&quot;</span>, <span class="number">85d</span>);</span><br><span class="line">        <span class="comment">// 为有序集合(ZSet)添加元素</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;grade&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询分数在 80 分到 100 分之间的人(包含 80 分和 100 分)</span></span><br><span class="line">        Set&lt;String&gt; gradeSet = jedis.zrangeByScore(<span class="string">&quot;grade&quot;</span>, <span class="number">80</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(gradeSet); <span class="comment">// 输出：[小明, 老王]</span></span><br><span class="line">        <span class="comment">// 查询小红的排名(排名从 0 开始)</span></span><br><span class="line">        System.out.println(jedis.zrank(<span class="string">&quot;grade&quot;</span>, <span class="string">&quot;小明&quot;</span>)); <span class="comment">// 输出：1</span></span><br><span class="line">        <span class="comment">// 从集合中移除老王</span></span><br><span class="line">        jedis.zrem(<span class="string">&quot;grade&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询有序集合中的所有元素(根据排名从小到大)</span></span><br><span class="line">        Set&lt;String&gt; range = jedis.zrange(<span class="string">&quot;grade&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(range); <span class="comment">// 输出：[小红, 小明]</span></span><br><span class="line">        <span class="comment">// 查询有序集合中的所有元素(根据 score 从小到大)</span></span><br><span class="line">        Set&lt;String&gt; rangeByScore = jedis.zrangeByScore(<span class="string">&quot;grade&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(rangeByScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-内部实现-2"><a href="#3-内部实现-2" class="headerlink" title="3. 内部实现"></a>3. 内部实现</h4><p>有序集合是由 ziplist (压缩列表) 或 skiplist (跳跃表) 组成的。</p><h5 id="1）ziplist"><a href="#1）ziplist" class="headerlink" title="1）ziplist"></a>1）ziplist</h5><p>当数据比较少时，有序集合使用的是 ziplist 存储的，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myzset 1 db 2 redis 3 mysql</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding myzset</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure><p>从结果可以看出，有序集合把 myset 键值对存储在 ziplist 结构中了。 有序集合使用 ziplist 格式存储必须满足以下两个条件：</p><ul><li>有序集合保存的元素个数要小于 128 个；</li><li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li></ul><p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。 接下来我们来测试以下，当有序集合中某个元素长度大于 64 字节时会发生什么情况？ 代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zmaxleng 1.0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zmaxleng</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd zmaxleng 2.0 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding zmaxleng</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看出，当有序集合保存的所有元素成员的长度大于 64 字节时，有序集合就会从 ziplist 转换成为 skiplist。</p><blockquote><p>小贴士：可以通过配置文件中的 zset-max-ziplist-entries（默认 128）和 zset-max-ziplist-value（默认 64）来设置有序集合使用 ziplist 存储的临界值。</p></blockquote><h5 id="2）skiplist"><a href="#2）skiplist" class="headerlink" title="2）skiplist"></a>2）skiplist</h5><p>skiplist 数据编码底层是使用 zset 结构实现的，而 zset 结构中包含了一个字典和一个跳跃表，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>更多关于跳跃表的源码实现，会在后面的章节详细介绍。</p><h6 id="①-跳跃表实现原理"><a href="#①-跳跃表实现原理" class="headerlink" title="① 跳跃表实现原理"></a>① 跳跃表实现原理</h6><p>跳跃表的结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png"></p><p>根据以上图片展示，当我们在跳跃表中查询值 32 时，执行流程如下：</p><ul><li>从最上层开始找，1 比 32 小，在当前层移动到下一个节点进行比较；</li><li>7 比 32 小，当前层移动下一个节点比较，由于下一个节点指向 Null，所以以 7 为目标，移动到下一层继续向后比较；</li><li>18 小于 32，继续向后移动查找，对比 77 大于 32，以 18 为目标，移动到下一层继续向后比较；</li><li>对比 32 等于 32，值被顺利找到。</li></ul><p>从上面的流程可以看出，跳跃表会想从最上层开始找起，依次向后查找，如果本层的节点大于要找的值，或者本层的节点为 Null 时，以上一个节点为目标，往下移一层继续向后查找并循环此流程，直到找到该节点并返回，如果对比到最后一个元素仍未找到，则返回 Null。</p><h6 id="②-为什么是跳跃表？而非红黑树？"><a href="#②-为什么是跳跃表？而非红黑树？" class="headerlink" title="② 为什么是跳跃表？而非红黑树？"></a>② 为什么是跳跃表？而非红黑树？</h6><p>因为跳跃表的性能和红黑树基本相近，但却比红黑树更好实现，所有 Redis 的有序集合会选用跳跃表来实现存储。</p><h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><p>有序集合的经典使用场景如下：</p><ul><li>学生成绩排名</li><li>粉丝列表，根据关注的先后时间排序</li></ul><p>有序集合具有唯一性和排序的功能，排序功能是借助分值字段 score 实现的，score 字段不仅可以实现排序功能，还可以实现数据的赛选与过滤的功能。我们还了解到了有序集合是由 压缩列表 (ziplist) 或跳跃列表 (skiplist) 来存储的，当元素个数小于 128 个，并且所有元素的值都小于 64 字节时，有序集合会采取 ziplist 来存储，反之则会用 skiplist 来存储，其中 skiplist 是从上往下、从前往后进行元素查找的，相比于传统的普通列表，可能会快很多，因为普通列表只能从前往后依次查找。</p><h4 id="6-更多有序集合操作命令"><a href="#6-更多有序集合操作命令" class="headerlink" title="6. 更多有序集合操作命令"></a>6. 更多有序集合操作命令</h4><ul><li><h5 id="查询有序集合的总个数"><a href="#查询有序集合的总个数" class="headerlink" title="查询有序集合的总个数"></a>查询有序集合的总个数</h5><p>语法：zcard key 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcard zset1</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li><li><h5 id="查询-score-区间内的元素个数"><a href="#查询-score-区间内的元素个数" class="headerlink" title="查询 score 区间内的元素个数"></a>查询 score 区间内的元素个数</h5><p>语法：zcount key min max 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount zset1 0 10</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li><li><h5 id="累加元素的-score-值"><a href="#累加元素的-score-值" class="headerlink" title="累加元素的 score 值"></a>累加元素的 score 值</h5><p>语法：zincrby key increment member 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 redis #查询 zset1 的 score 值</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zincrby zset1 2 redis #累加 score 值</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zscore zset1 redis</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="查询某元素倒序排名"><a href="#查询某元素倒序排名" class="headerlink" title="查询某元素倒序排名"></a>查询某元素倒序排名</h5><p>语法：zrevrank key member 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrank zset1 python #倒序查询</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #正序列表</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="根据排名删除元素"><a href="#根据排名删除元素" class="headerlink" title="根据排名删除元素"></a>根据排名删除元素</h5><p>语法：zremrangebyrank key start stop 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyrank zset1 0 2 #删除元素</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1 #查询所有元素</span><br><span class="line">1) &quot;python&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="删除-score-区间内的元素"><a href="#删除-score-区间内的元素" class="headerlink" title="删除 score 区间内的元素"></a>删除 score 区间内的元素</h5><p>语法：zremrangebyscore key min max 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore zset1 python</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyscore zset1 4 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zscore zset1 python</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li><li><h5 id="复制交集元素到新集合"><a href="#复制交集元素到新集合" class="headerlink" title="复制交集元素到新集合"></a>复制交集元素到新集合</h5><p>语法：zinterstore destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MA 参数 numkeys 表示需要几个集合参与查询。 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange zset2 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;db&quot;</span><br><span class="line">127.0.0.1:6379&gt; zinterstore zset3 2 zset1 zset2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange zset3 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br></pre></td></tr></table></figure></li><li><h5 id="复制并集元素到新集合"><a href="#复制并集元素到新集合" class="headerlink" title="复制并集元素到新集合"></a>复制并集元素到新集合</h5><p>语法：zunionstore destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MA 示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange zset2 0 -1</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;db&quot;</span><br><span class="line">127.0.0.1:6379&gt; zunionstore zset3 2 zset1 zset2</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; zrange zset3 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">5) &quot;db&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Redis持久化机制"><a href="#4-Redis持久化机制" class="headerlink" title="4-Redis持久化机制"></a>4-Redis持久化机制</h2><p>Redis 的读写都是在内存中，所以它的性能较高，但在内存中的数据会随着服务器的重启而丢失，为了保证数据不丢失，我们需要将内存中的数据存储到磁盘，以便 Redis 重启时能够从磁盘中恢复原有的数据，而整个过程就叫做 Redis 持久化。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><p>也是 Redis 和 Memcached 的主要区别之一，因为 Memcached 不具备持久化功能。</p><p>Redis 持久化拥有以下三种方式：</p><ul><li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li><li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li></ul><h3 id="4-1-RDB"><a href="#4-1-RDB" class="headerlink" title="4.1-RDB"></a>4.1-RDB</h3><p>RDB（Redis DataBase）是将某一个时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。</p><h4 id="1-持久化触发"><a href="#1-持久化触发" class="headerlink" title="1. 持久化触发"></a>1. 持久化触发</h4><p>RDB 的持久化触发方式有两类：一类是手动触发，另一类是自动触发。</p><h5 id="1）手动触发"><a href="#1）手动触发" class="headerlink" title="1）手动触发"></a>1）手动触发</h5><p>手动触发持久化的操作有两个： <code>save</code> 和 <code>bgsave</code> ，它们主要区别体现在：是否阻塞 Redis 主线程的执行。</p><h6 id="①-save-命令"><a href="#①-save-命令" class="headerlink" title="① save 命令"></a>① save 命令</h6><p>在客户端中执行 <code>save</code> 命令，就会触发 Redis 的持久化，但同时也是使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以<strong>在生产环境一定要慎用</strong>。</p><p><code>save</code> 命令使用如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/save.png"></p><p>从图片可以看出，当执行完 <code>save</code> 命令之后，持久化文件 <code>dump.rdb</code> 的修改时间就变了，这就表示 <code>save</code> 成功的触发了 RDB 持久化。 <code>save</code> 命令执行流程，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/save%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><h6 id="②-bgsave-命令"><a href="#②-bgsave-命令" class="headerlink" title="② bgsave 命令"></a>② bgsave 命令</h6><p>bgsave（background save）既后台保存的意思， 它和 <code>save</code> 命令最大的区别就是 <code>bgsave</code> 会 fork() 一个子进程来执行持久化，整个过程中只有在 fork() 子进程时有短暂的阻塞，当子进程被创建之后，Redis 的主进程就可以响应其他客户端的请求了，相对于整个流程都阻塞的 <code>save</code> 命令来说，显然 <code>bgsave</code> 命令更适合我们使用。 <code>bgsave</code> 命令使用，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/bgsave.png"></p><p><code>bgsave</code> 执行流程，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/bgsave%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><h4 id="2）自动触发"><a href="#2）自动触发" class="headerlink" title="2）自动触发"></a>2）自动触发</h4><p>说完了 RDB 的手动触发方式，下面来看如何自动触发 RDB 持久化？ RDB 自动持久化主要来源于以下几种情况。</p><h6 id="①-save-m-n"><a href="#①-save-m-n" class="headerlink" title="① save m n"></a>① save m n</h6><p><code>save m n</code> 是指在 m 秒内，如果有 n 个键发生改变，则自动触发持久化。 参数 m 和 n 可以在 Redis 的配置文件中找到，例如，<code>save 60 1</code> 则表明在 60 秒内，至少有一个键发生改变，就会触发 RDB 持久化。 自动触发持久化，本质是 Redis 通过判断，如果满足设置的触发条件，自动执行一次 <code>bgsave</code> 命令。 注意：当设置多个 save m n 命令时，满足任意一个条件都会触发持久化。 例如，我们设置了以下两个 save m n 命令：</p><ul><li>save 60 10</li><li>save 600 1</li></ul><p>当 60s 内如果有 10 次 Redis 键值发生改变，就会触发持久化；如果 60s 内 Redis 的键值改变次数少于 10 次，那么 Redis 就会判断 600s 内，Redis 的键值是否至少被修改了一次，如果满足则会触发持久化。</p><h6 id="②-flushall"><a href="#②-flushall" class="headerlink" title="② flushall"></a>② flushall</h6><p><code>flushall</code> 命令用于清空 Redis 数据库，在生产环境下一定慎用，当 Redis 执行了 <code>flushall</code> 命令之后，则会触发自动持久化，把 RDB 文件清空。 执行结果如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/flushall.png"></p><h6 id="③-主从同步触发"><a href="#③-主从同步触发" class="headerlink" title="③ 主从同步触发"></a>③ 主从同步触发</h6><p>在 Redis 主从复制中，当从节点执行全量复制操作时，主节点会执行 <code>bgsave</code> 命令，并将 RDB 文件发送给从节点，该过程会自动触发 Redis 持久化。</p><h4 id="2-配置说明"><a href="#2-配置说明" class="headerlink" title="2. 配置说明"></a>2. 配置说明</h4><p>合理的设置 RDB 的配置，可以保障 Redis 高效且稳定的运行，下面一起来看 RDB 的配置项都有哪些？</p><p>RDB 配置参数可以在 Redis 的配置文件中找见，具体内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RDB 保存的条件</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。</span></span><br><span class="line"><span class="meta">stop-writes-on-bgsave-error</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB 文件压缩</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB 文件名</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB 文件目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br></pre></td></tr></table></figure><p>其中比较重要的参数如下列表：</p><p><strong>① save 参数</strong> 它是用来配置触发 RDB 持久化条件的参数，满足保存条件时将会把数据持久化到硬盘。 默认配置说明如下：</p><ul><li>save 900 1：表示 900 秒内如果至少有 1 个 key 值变化，则把数据持久化到硬盘；</li><li>save 300 10：表示 300 秒内如果至少有 10 个 key 值变化，则把数据持久化到硬盘；</li><li>save 60 10000：表示 60 秒内如果至少有 10000 个 key 值变化，则把数据持久化到硬盘。</li></ul><p><strong>② rdbcompression 参数</strong> 它的默认值是 <code>yes</code> 表示开启 RDB 文件压缩，Redis 会采用 LZF 算法进行压缩。如果不想消耗 CPU 性能来进行文件压缩的话，可以设置为关闭此功能，这样的缺点是需要更多的磁盘空间来保存文件。</p><p><strong>③ rdbchecksum 参数</strong> 它的默认值为 <code>yes</code> 表示写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</p><h4 id="3-配置查询"><a href="#3-配置查询" class="headerlink" title="3. 配置查询"></a>3. 配置查询</h4><p>Redis 中可以使用命令查询当前配置参数。查询命令的格式为：<code>config get xxx</code> ，例如，想要获取 RDB 文件的存储名称设置，可以使用 <code>config get dbfilename</code> ，执行效果如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/dbfilename.png"></p><p>查询 RDB 的文件目录，可使用命令 <code>config get dir</code> ，执行效果如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/dir.png"></p><h4 id="4-配置设置"><a href="#4-配置设置" class="headerlink" title="4. 配置设置"></a>4. 配置设置</h4><p>设置 RDB 的配置，可以通过以下两种方式：</p><ul><li>手动修改 Redis 配置文件；</li><li>使用命令行设置，例如，使用 <code>config set dir &quot;/usr/data&quot;</code> 就是用于修改 RDB 的存储目录。</li></ul><p><strong>注意</strong>：手动修改 Redis 配置文件的方式是全局生效的，即重启 Redis 服务器设置参数也不会丢失，而使用命令修改的方式，在 Redis 重启之后就会丢失。但手动修改 Redis 配置文件，想要立即生效需要重启 Redis 服务器，而命令的方式则不需要重启 Redis 服务器。</p><blockquote><p>小贴士：Redis 的配置文件位于 Redis 安装目录的根路径下，默认名称为 redis.conf。</p></blockquote><h4 id="5-RDB-文件恢复"><a href="#5-RDB-文件恢复" class="headerlink" title="5. RDB 文件恢复"></a>5. RDB 文件恢复</h4><p>当 Redis 服务器启动时，如果 Redis 根目录存在 RDB 文件 dump.rdb，Redis 就会自动加载 RDB 文件恢复持久化数据。 如果根目录没有 dump.rdb 文件，请先将 dump.rdb 文件移动到 Redis 的根目录。 <strong>验证 RDB 文件是否被加载</strong> Redis 在启动时有日志信息，会显示是否加载了 RDB 文件，我们执行 Redis 启动命令：<code>src/redis-server redis.conf</code> ，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/RDB%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D.png"></p><p>从日志上可以看出， Redis 服务在启动时已经正常加载了 RDB 文件。</p><blockquote><p>小贴士：Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p></blockquote><h4 id="6-RDB的优缺点"><a href="#6-RDB的优缺点" class="headerlink" title="6. RDB的优缺点"></a>6. RDB的优缺点</h4><h5 id="1）RDB-优点"><a href="#1）RDB-优点" class="headerlink" title="1）RDB 优点"></a>1）RDB 优点</h5><ul><li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li><li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li><li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</li><li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li></ul><h5 id="2）RDB-缺点"><a href="#2）RDB-缺点" class="headerlink" title="2）RDB 缺点"></a>2）RDB 缺点</h5><ul><li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据；</li><li>RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li></ul><h4 id="7-禁用持久化"><a href="#7-禁用持久化" class="headerlink" title="7. 禁用持久化"></a>7. 禁用持久化</h4><p>禁用持久化可以提高 Redis 的执行效率，如果对数据丢失不敏感的情况下，可以在连接客户端的情况下，执行 <code>config set save &quot;&quot;</code> 命令即可禁用 Redis 的持久化。</p><h3 id="4-2-AOF"><a href="#4-2-AOF" class="headerlink" title="4.2-AOF"></a>4.2-AOF</h3><p>使用 RDB 持久化有一个风险，它可能会造成最新数据丢失的风险。因为 RDB 的持久化有一定的时间间隔，在这个时间段内如果 Redis 服务意外终止的话，就会造成最新的数据全部丢失。</p><p>可能会操作 Redis 服务意外终止的条件：</p><ul><li>安装 Redis 的机器停止运行，蓝屏或者系统崩溃；</li><li>安装 Redis 的机器出现电源故障，例如突然断电；</li><li>使用 <code>kill -9 Redis_PID</code> 等。</li></ul><p>那么如何解决以上的这些问题呢？Redis 为我们提供了另一种持久化的方案——AOF。</p><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>AOF（Append Only File）中文是附加到文件，顾名思义 AOF 可以把 Redis 每个键值对操作都记录到文件（appendonly.aof）中。</p><h4 id="2-持久化查询和设置"><a href="#2-持久化查询和设置" class="headerlink" title="2. 持久化查询和设置"></a>2. 持久化查询和设置</h4><h5 id="1）查询-AOF-启动状态"><a href="#1）查询-AOF-启动状态" class="headerlink" title="1）查询 AOF 启动状态"></a>1）查询 AOF 启动状态</h5><p>使用 <code>config get appendonly</code> 命令，如下图所示：</p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/%E6%9F%A5%E8%AF%A2">https://gitee.com/lemon-cs/images/raw/master/查询</a> AOF 启动状态.png)</p><p>其中，第一行为 AOF 文件的名称，而最后一行表示 AOF 启动的状态，yes 表示已启动，no 表示未启动。</p><h5 id="2）开启-AOF-持久化"><a href="#2）开启-AOF-持久化" class="headerlink" title="2）开启 AOF 持久化"></a>2）开启 AOF 持久化</h5><p>Redis 默认是关闭 AOF 持久化的，想要开启 AOF 持久化，有以下两种方式：</p><ul><li>通过命令行的方式；</li><li>通过修改配置文件的方式（redis.conf）。</li></ul><p>下面分别来看以上两种方式的实现。</p><h6 id="①-命令行启动-AOF"><a href="#①-命令行启动-AOF" class="headerlink" title="① 命令行启动 AOF"></a>① 命令行启动 AOF</h6><p>命令行启动 AOF，使用 <code>config set appendonly yes</code> 命令。</p><p><strong>命令行启动 AOF 的优缺点</strong>：命令行启动优点是无需重启 Redis 服务，缺点是如果 Redis 服务重启，则之前使用命令行设置的配置就会失效。</p><h6 id="②-配置文件启动-AOF"><a href="#②-配置文件启动-AOF" class="headerlink" title="② 配置文件启动 AOF"></a>② 配置文件启动 AOF</h6><p>Redis 的配置文件在它的根路径下的 redis.conf 文件中，获取 Redis 的根目录可以使用命令 <code>config get dir</code> 获取，只需要在配置文件中设置 <code>appendonly yes</code> 即可，默认 <code>appendonly no</code> 表示关闭 AOF 持久化。</p><p><strong>配置文件启动 AOF 的优缺点</strong>：修改配置文件的缺点是每次修改配置文件都要重启 Redis 服务才能生效，优点是无论重启多少次 Redis 服务，配置文件中设置的配置信息都不会失效。</p><h4 id="3-触发持久化"><a href="#3-触发持久化" class="headerlink" title="3. 触发持久化"></a>3. 触发持久化</h4><p>AOF 持久化开启之后，只要满足一定条件，就会触发 AOF 持久化。AOF 的触发条件分为两种：自动触发和手动触发。</p><h5 id="1）自动触发"><a href="#1）自动触发" class="headerlink" title="1）自动触发"></a>1）自动触发</h5><p>有两种情况可以自动触发 AOF 持久化，分为是：<strong>满足 AOF 设置的策略触发</strong>和<strong>满足 AOF 重写触发。</strong>其中，AOF 重写触发会在本文的后半部分详细介绍，这里重点来说 AOF 持久化策略都有哪些。 AOF 持久化策略，分为以下三种：</p><ul><li>always：每条 Redis 操作命令都会写入磁盘，最多丢失一条数据；</li><li>everysec：每秒钟写入一次磁盘，最多丢失一秒的数据；</li><li>no：不设置写入磁盘的规则，根据当前操作系统来决定何时写入磁盘，Linux 默认 30s 写入一次数据至磁盘。</li></ul><p>这三种配置可以在 Redis 的配置文件（redis.conf）中设置，如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启每秒写入一次的持久化策略</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：因为每次写入磁盘都会对 Redis 的性能造成一定的影响，所以要根据用户的实际情况设置相应的策略，一般设置每秒写入一次磁盘的频率就可以满足大部分的使用场景了。</p></blockquote><p>触发自动持久化的两种情况，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%A7%A6%E5%8F%91%E8%87%AA%E5%8A%A8%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><h5 id="2-手动触发"><a href="#2-手动触发" class="headerlink" title="2) 手动触发"></a>2) 手动触发</h5><p>在客户端执行 <code>bgrewriteaof</code> 命令就可以手动触发 AOF 持久化，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91AOF.png"></p><p>可以看出执行完 <code>bgrewriteaof</code> 命令之后，AOF 持久化就会被触发。</p><h4 id="4-AOF-文件重写"><a href="#4-AOF-文件重写" class="headerlink" title="4. AOF 文件重写"></a>4. AOF 文件重写</h4><p>AOF 是通过记录 Redis 的执行命令来持久化（保存）数据的，所以随着时间的流逝 AOF 文件会越来越多，这样不仅增加了服务器的存储压力，也会造成 Redis 重启速度变慢，为了解决这个问题 Redis 提供了 AOF 重写的功能。</p><h5 id="1）什么是-AOF-重写？"><a href="#1）什么是-AOF-重写？" class="headerlink" title="1）什么是 AOF 重写？"></a>1）什么是 AOF 重写？</h5><p>AOF 重写指的是它会直接读取 Redis 服务器当前的状态，并压缩保存为 AOF 文件。例如，我们增加了一个计数器，并对它做了 99 次修改，如果不做 AOF 重写的话，那么持久化文件中就会有 100 条记录执行命令的信息，而 AOF 重写之后，之后记录一条此计数器最终的结果信息，这样就去除了所有的无效信息。</p><h5 id="2）AOF-重写实现"><a href="#2）AOF-重写实现" class="headerlink" title="2）AOF 重写实现"></a>2）AOF 重写实现</h5><p>触发 AOF 文件重写，要满足两个条件，这两个条件也是配置在 Redis 配置文件中的，它们分别：</p><ul><li>auto-aof-rewrite-min-size：允许 AOF 重写的最小文件容量，默认是 64mb 。</li><li>auto-aof-rewrite-percentage：AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次（上次）的 AOF 文件大一倍时，才会启动 AOF 文件重写。</li></ul><p>查询 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 的值，可使用 <code>config get xxx</code> 命令，如下图所示：</p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/AOF">https://gitee.com/lemon-cs/images/raw/master/AOF</a> 重写配置.png)</p><blockquote><p>小贴士：只有同时满足 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 设置的条件，才会触发 AOF 文件重写。</p></blockquote><p><strong>注意</strong>：使用 <code>bgrewriteaof</code> 命令，可以自动触发 AOF 文件重写。</p><h5 id="3）AOF-重写流程"><a href="#3）AOF-重写流程" class="headerlink" title="3）AOF 重写流程"></a>3）AOF 重写流程</h5><p>AOF 文件重写是生成一个全新的文件，并把当前数据的最少操作命令保存到新文件上，当把所有的数据都保存至新文件之后，Redis 会交换两个文件，并把最新的持久化操作命令追加到新文件上。</p><h4 id="5-配置说明"><a href="#5-配置说明" class="headerlink" title="5. 配置说明"></a>5. 配置说明</h4><p>合理的设置 AOF 的配置，可以保障 Redis 高效且稳定的运行，以下是 AOF 的全部配置信息和说明。</p><p>AOF 的配置参数在 Redis 的配置文件中，也就是 Redis 根路径下的 <code>redis.conf</code> 文件中，配置参数和说明如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启 AOF，yes 为开启，默认是关闭</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># AOF 默认文件名</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># AOF 持久化策略配置</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># AOF 文件重写的大小比例，默认值是 100，表示 100%，也就是只有当前 AOF 文件，比最后一次的 AOF 文件大一倍时，才会启动 AOF 文件重写。</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 允许 AOF 重写的最小文件容量</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否开启启动时加载 AOF 文件效验，默认值是 yes，表示尽可能的加载 AOF 文件，忽略错误部分信息，并启动 Redis 服务。</span></span><br><span class="line"><span class="comment"># 如果值为 no，则表示，停止启动 Redis，用户必须手动修复 AOF 文件才能正常启动 Redis 服务。</span></span><br><span class="line"><span class="meta">aof-load-truncated</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure><p>其中比较重要的是 appendfsync 参数，用它来设置 AOF 的持久化策略，可以选择按时间间隔或者操作次数来存储 AOF 文件，这个参数的三个值在文章开头有说明，这里就不再复述了。</p><h4 id="6-数据恢复"><a href="#6-数据恢复" class="headerlink" title="6. 数据恢复"></a>6. 数据恢复</h4><h5 id="1）正常数据恢复"><a href="#1）正常数据恢复" class="headerlink" title="1）正常数据恢复"></a>1）正常数据恢复</h5><p>正常情况下，只要开启了 AOF 持久化，并且提供了正常的 appendonly.aof 文件，在 Redis 启动时就会自定加载 AOF 文件并启动，执行如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/AOF%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D.png"></p><p>其中 <code>DB loaded from append only file......</code> 表示 Redis 服务器在启动时，先去加载了 AOF 持久化文件。</p><blockquote><p>小贴士：默认情况下 appendonly.aof 文件保存在 Redis 的根目录下。</p></blockquote><p><strong>持久化文件加载规则</strong></p><ul><li>如果只开启了 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复；</li><li>如果只开启了 RDB 持久化，Redis 启动时只会加载 RDB 文件（dump.rdb），进行数据恢复；</li><li>如果同时开启了 RDB 和 AOF 持久化，Redis 启动时只会加载 AOF 文件（appendonly.aof），进行数据恢复。</li></ul><p>在 AOF 开启的情况下，即使 AOF 文件不存在，只有 RDB 文件，也不会加载 RDB 文件。 AOF 和 RDB 的加载流程如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D.png"></p><h5 id="2）简单异常数据恢复"><a href="#2）简单异常数据恢复" class="headerlink" title="2）简单异常数据恢复"></a>2）简单异常数据恢复</h5><p>在 AOF 写入文件时如果服务器崩溃，或者是 AOF 存储已满的情况下，AOF 的最后一条命令可能被截断，这就是异常的 AOF 文件。</p><p>在 AOF 文件异常的情况下，如果为修改 Redis 的配置文件，也就是使用 <code>aof-load-truncated</code> 等于 <code>yes</code> 的配置，Redis 在启动时会忽略最后一条命令，并顺利启动 Redis，执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Reading RDB preamble from AOF file...</span><br><span class="line">* Reading the remaining AOF tail...</span><br><span class="line"># !!! Warning: short read while loading the AOF file !!!</span><br><span class="line"># !!! Truncating the AOF at offset 439 !!!</span><br><span class="line"># AOF loaded anyway because aof-load-truncated is enabled</span><br></pre></td></tr></table></figure><h5 id="3）复杂异常数据恢复"><a href="#3）复杂异常数据恢复" class="headerlink" title="3）复杂异常数据恢复"></a>3）复杂异常数据恢复</h5><p>AOF 文件可能出现更糟糕的情况，当 AOF 文件不仅被截断，而且中间的命令也被破坏，这个时候再启动 Redis 会提示错误信息并中止运行，错误信息如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Reading the remaining AOF tail...</span><br><span class="line"># Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>出现此类问题的解决方案如下：</p><ol><li>首先使用 AOF 修复工具，检测出现的问题，在命令行中输入 <code>redis-check-aof</code> 命令，它会跳转到出现问题的命令行，这个时候可以尝试手动修复此文件；</li><li>如果无法手动修复，我们可以使用 <code>redis-check-aof --fix</code> 自动修复 AOF 异常文件，不过执行此命令，可能会导致异常部分至文件末尾的数据全部被丢弃。</li></ol><h4 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="7. 优缺点"></a>7. 优缺点</h4><h5 id="1-AOF-优点"><a href="#1-AOF-优点" class="headerlink" title="1) AOF 优点"></a>1) AOF 优点</h5><ul><li>AOF 持久化保存的数据更加完整，AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据；</li><li>AOF 采用的是命令追加的写入方式，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复；</li><li>AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方式存入了磁盘。即使不小心使用 <code>flushall</code> 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的 <code>flushall</code> 命令，重启 Redis 即可恢复之前误删的数据。</li></ul><h5 id="2-AOF-缺点"><a href="#2-AOF-缺点" class="headerlink" title="2) AOF 缺点"></a>2) AOF 缺点</h5><ul><li>对于相同的数据集来说，AOF 文件要大于 RDB 文件；</li><li>在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好；</li><li>RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。</li></ul><p>AOF 保存数据更加完整，它可以记录每次 Redis 的键值变化，或者是选择每秒保存一次数据。AOF 的持久化文件更加易读，但相比与二进制的 RDB 来说，所占的存储空间也越大，为了解决这个问题，AOF 提供自动化重写机制，最大程度的减少了 AOF 占用空间大的问题。同时 AOF 也提供了很方便的异常文件恢复命令： <code>redis-check-aof --fix</code> ，为使用 AOF 提供了很好的保障。</p><h3 id="4-3-混合持久化"><a href="#4-3-混合持久化" class="headerlink" title="4.3-混合持久化"></a>4.3-混合持久化</h3><p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时使用 RDB 和 AOF 各种的优点，Redis 4.0 之后新增了混合持久化的方式。</p><p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p><p>混合持久化的数据存储结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%BB%93%E6%9E%84.png"></p><h4 id="1-开启混合持久化"><a href="#1-开启混合持久化" class="headerlink" title="1. 开启混合持久化"></a>1. 开启混合持久化</h4><p>查询是否开启混合持久化可以使用 <code>config get aof-use-rdb-preamble</code> 命令，执行结果如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%BC%80%E5%90%AF%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><p>其中 yes 表示已经开启混合持久化，no 表示关闭，Redis 5.0 默认值为 yes。 如果是其他版本的 Redis 首先需要检查一下，是否已经开启了混合持久化，如果关闭的情况下，可以通过以下两种方式开启：</p><ul><li>通过命令行开启</li><li>通过修改 Redis 配置文件开启</li></ul><h5 id="1）通过命令行开启"><a href="#1）通过命令行开启" class="headerlink" title="1）通过命令行开启"></a>1）通过命令行开启</h5><p>使用命令 <code>config set aof-use-rdb-preamble yes</code>。</p><blockquote><p>小贴士：命令行设置配置的缺点是重启 Redis 服务之后，设置的配置就会失效。</p></blockquote><h5 id="2）通过修改-Redis-配置文件开启"><a href="#2）通过修改-Redis-配置文件开启" class="headerlink" title="2）通过修改 Redis 配置文件开启"></a>2）通过修改 Redis 配置文件开启</h5><p>在 Redis 的根路径下找到 redis.conf 文件，把配置文件中的 <code>aof-use-rdb-preamble no</code> 改为 <code>aof-use-rdb-preamble yes</code> 如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE.png"></p><h4 id="2-实例运行"><a href="#2-实例运行" class="headerlink" title="2. 实例运行"></a>2. 实例运行</h4><p>当在混合持久化关闭的情况下，使用 <code>bgrewriteaof</code> 触发 AOF 文件重写之后，查看 appendonly.aof 文件的持久化日志，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/AOF%E6%96%87%E4%BB%B6.png"></p><p>可以看出，当混合持久化关闭的情况下 AOF 持久化文件存储的为标准的 AOF 格式的文件。 当混合持久化开启的模式下，使用 <code>bgrewriteaof</code> 命令触发 AOF 文件重写，得到 appendonly.aof 的文件内容如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84AOF%E6%96%87%E4%BB%B6.png"></p><p>可以看出 appendonly.aof 文件存储的内容是 <code>REDIS</code> 开头的 RDB 格式的内容，并非为 AOF 格式的日志。</p><h4 id="3-数据恢复和源码解析"><a href="#3-数据恢复和源码解析" class="headerlink" title="3. 数据恢复和源码解析"></a>3. 数据恢复和源码解析</h4><p>混合持久化的数据恢复和 AOF 持久化过程是一样的，只需要把 appendonly.aof 放到 Redis 的根目录，在 Redis 启动时，只要开启了 AOF 持久化，Redis 就会自动加载并恢复数据。 Redis 启动信息如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D.png"></p><p>可以看出 Redis 在服务器初始化的时候加载了 AOF 文件的内容。</p><h5 id="1）混合持久化的加载流程"><a href="#1）混合持久化的加载流程" class="headerlink" title="1）混合持久化的加载流程"></a>1）混合持久化的加载流程</h5><p>混合持久化的加载流程如下：</p><ol><li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li><li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程；</li><li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li><li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li></ol><p>AOF 加载流程图如下图所示：</p><p>![](<a target="_blank" rel="noopener" href="https://gitee.com/lemon-cs/images/raw/master/AOF">https://gitee.com/lemon-cs/images/raw/master/AOF</a> 加载流程图.png)</p><h5 id="2）源码解析"><a href="#2）源码解析" class="headerlink" title="2）源码解析"></a>2）源码解析</h5><p>Redis 判断 AOF 文件的开头是否是 RDB 格式的，是通过关键字 <code>REDIS</code> 判断的，RDB 文件的开头一定是 <code>REDIS</code> 关键字开头的，判断源码在 Redis 的 src/aof.c 中，核心代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line"><span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// AOF 文件开头非 RDB 格式，非混合持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* RDB preamble. Pass loading the RDB functions. */</span></span><br><span class="line">    rio rdb;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    <span class="comment">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF</span></span><br><span class="line">    <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,<span class="literal">NULL</span>,<span class="number">1</span>) != C_OK) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载 AOF 格式的数据</span></span><br></pre></td></tr></table></figure><p>可以看出 Redis 是通过判断 AOF 文件的开头是否是 <code>REDIS</code> 关键字，来确定此文件是否为混合持久化文件的。</p><blockquote><p>小贴士：AOF 格式的开头是 *，而 RDB 格式的开头是 REDIS。</p></blockquote><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4 优缺点"></a>4 优缺点</h4><h5 id="混合持久化优点："><a href="#混合持久化优点：" class="headerlink" title="混合持久化优点："></a><strong>混合持久化优点：</strong></h5><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><h5 id="混合持久化缺点："><a href="#混合持久化缺点：" class="headerlink" title="混合持久化缺点："></a><strong>混合持久化缺点：</strong></h5><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h4 id="5-持久化最佳实践"><a href="#5-持久化最佳实践" class="headerlink" title="5. 持久化最佳实践"></a>5. 持久化最佳实践</h4><p>持久化虽然保证了数据不丢失，但同时拖慢了 Redis 的运行速度，那怎么更合理的使用 Redis 的持久化功能呢？ Redis 持久化的最佳实践可从以下几个方面考虑。</p><h5 id="1）控制持久化开关"><a href="#1）控制持久化开关" class="headerlink" title="1）控制持久化开关"></a>1）控制持久化开关</h5><p>使用者可根据实际的业务情况考虑，如果对数据的丢失不敏感的情况下，可考虑关闭 Redis 的持久化，这样所以的键值操作都在内存中，就可以保证最高效率的运行 Redis 了。 持久化关闭操作：</p><ul><li>关闭 RDB 持久化，使用命令： <code>config set save &quot;&quot;</code></li><li>关闭 AOF 和 混合持久化，使用命令： <code>config set appendonly no</code></li></ul><h5 id="2）主从部署"><a href="#2）主从部署" class="headerlink" title="2）主从部署"></a>2）主从部署</h5><p>使用主从部署，一台用于响应主业务，一台用于数据持久化，这样就可能让 Redis 更加高效的运行。</p><h5 id="3）使用混合持久化"><a href="#3）使用混合持久化" class="headerlink" title="3）使用混合持久化"></a>3）使用混合持久化</h5><p>混合持久化结合了 RDB 和 AOF 的优点，Redis 5.0 默认是开启的。</p><h5 id="4）使用配置更高的机器"><a href="#4）使用配置更高的机器" class="headerlink" title="4）使用配置更高的机器"></a>4）使用配置更高的机器</h5><p>Redis 对 CPU 的要求并不高，反而是对内存和磁盘的要求很高，因为 Redis 大部分时候都在做读写操作，使用更多的内存和更快的磁盘，对 Redis 性能的提高非常有帮助。</p><h2 id="5-Redis-事务"><a href="#5-Redis-事务" class="headerlink" title="5-Redis 事务"></a>5-Redis 事务</h2><p>事务指的是提供一种将多个命令打包，一次性按顺序地执行的机制，并且保证服务器只有在执行完事务中的所有命令后，才会继续处理此客户端的其他命令。</p><p>事务也是其他关系型数据库所必备的基础功能，以支付的场景为例，正常情况下只有正常消费完成之后，才会减去账户余额。但如果没有事务的保障，可能会发生消费失败了，但依旧会把账户的余额给扣减了，我想这种情况应该任何人都无法接受吧？所以事务是数据库中一项非常重要的基础功能。</p><h3 id="5-1-事务基本使用"><a href="#5-1-事务基本使用" class="headerlink" title="5.1-事务基本使用"></a>5.1-事务基本使用</h3><p>事务在其他语言中，一般分为以下三个阶段：</p><ul><li>开启事务——Begin Transaction</li><li>执行业务代码，提交事务——Commit Transaction</li><li>业务处理中出现异常，回滚事务——Rollback Transaction</li></ul><p>以 Java 中的事务执行为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">begin();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 中的事务从开始到结束也是要经历三个阶段：</p><ul><li>开启事务</li><li>命令入列</li><li>执行事务/放弃事务</li></ul><p>其中，开启事务使用 multi 命令，事务执行使用 exec 命令，放弃事务使用 discard 命令。</p><h3 id="5-2-开启事务"><a href="#5-2-开启事务" class="headerlink" title="5.2-开启事务"></a>5.2-<strong>开启事务</strong></h3><p>multi 命令用于开启事务，实现代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>multi 命令可以让客户端从非事务模式状态，变为事务模式状态。</p><p><strong>注意</strong>：multi 命令不能嵌套使用，如果已经开启了事务的情况下，再执行 multi 命令，会提示如下错误：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(error) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure><p>执行效果，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br></pre></td></tr></table></figure><p>当客户端是非事务状态时，使用 multi 命令，客户端会返回结果 OK，如果客户端已经是事务状态，再执行 multi 命令会 multi 命令不能嵌套的错误，但不会终止客户端为事务的状态。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81.png"></p><h3 id="5-3-命令入列"><a href="#5-3-命令入列" class="headerlink" title="5.3-命令入列"></a>5.3-<strong>命令入列</strong></h3><p>客户端进入事务状态之后，执行的所有常规 Redis 操作命令（非触发事务执行或放弃和导致入列异常的命令）会依次入列，命令入列成功后会返回 QUEUED，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>执行流程如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E4%BA%8B%E5%8A%A1%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><p><strong>注意</strong>：命令会按照先进先出（FIFO）的顺序出入列，也就是说事务会按照命令的入列顺序，从前往后依次执行。</p><h3 id="5-4-执行事务-放弃事务"><a href="#5-4-执行事务-放弃事务" class="headerlink" title="5.4-执行事务/放弃事务"></a>5.4-<strong>执行事务/放弃事务</strong></h3><p>执行事务的命令是 exec，放弃事务的命令是 discard。</p><p>执行事务示例代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>放弃事务示例代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> discard</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>执行流程如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B.png"></p><h3 id="5-5-事务错误-amp-回滚"><a href="#5-5-事务错误-amp-回滚" class="headerlink" title="5.5-事务错误&amp;回滚"></a>5.5-事务错误&amp;回滚</h3><p>事务执行中的错误分为以下三类：</p><ul><li>执行时才会出现的错误（简称：执行时错误）；</li><li>入列时错误，不会终止整个事务；</li><li>入列时错误，会终止整个事务。</li></ul><h4 id="1-执行时错误"><a href="#1-执行时错误" class="headerlink" title="1. 执行时错误"></a><strong>1. 执行时错误</strong></h4><p>示例代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> expire k 10s</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>执行命令解释如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A.png"></p><p>从以上结果可以看出，即使事务队列中某个命令在执行期间发生了错误，事务也会继续执行，直到事务队列中所有命令执行完成。</p><h4 id="2-入列错误不会导致事务结束"><a href="#2-入列错误不会导致事务结束" class="headerlink" title="2. 入列错误不会导致事务结束"></a>2. <strong>入列错误不会导致事务结束</strong></h4><p>示例代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">(error) ERR MULTI calls can not be nested</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>执行命令解释如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF.png"></p><p>可以看出，重复执行 multi 会导致入列错误，但不会终止事务，最终查询的结果是事务执行成功了。除了重复执行 multi 命令，还有在事务状态下执行 watch 也是同样的效果，下文会详细讲解关于 watch 的内容。</p><h4 id="3-入列错误导致事务结束"><a href="#3-入列错误导致事务结束" class="headerlink" title="3. 入列错误导致事务结束"></a>3. <strong>入列错误导致事务结束</strong></h4><p>示例代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k</span></span><br><span class="line">(error) ERR wrong number of arguments for &#x27;set&#x27; command</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>执行命令解释如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F.png"></p><h4 id="4-为什么不支持事务回滚？"><a href="#4-为什么不支持事务回滚？" class="headerlink" title="4. 为什么不支持事务回滚？"></a>4. <strong>为什么不支持事务回滚？</strong></h4><p>Redis 官方文档的解释如下：</p><blockquote><p>If you have a relational databases background, the fact that Redis commands can fail during a transaction, but still Redis will execute the rest of the transaction instead of rolling back, may look odd to you.</p><p>However there are good opinions for this behavior:</p><ul><li>Redis commands can fail only if called with a wrong syntax (and the problem is not detectable during the command queueing), or against keys holding the wrong data type: this means that in practical terms a failing command is the result of a programming errors, and a kind of error that is very likely to be detected during development, and not in production.</li><li>Redis is internally simplified and faster because it does not need the ability to roll back.</li></ul><p>An argument against Redis point of view is that bugs happen, however it should be noted that in general the roll back does not save you from programming errors. For instance if a query increments a key by 2 instead of 1, or increments the wrong key, there is no way for a rollback mechanism to help. Given that no one can save the programmer from his or her errors, and that the kind of errors required for a Redis command to fail are unlikely to enter in production, we selected the simpler and faster approach of not supporting roll backs on errors.</p></blockquote><p>大概的意思是，作者不支持事务回滚的原因有以下两个：</p><ul><li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li><li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li></ul><p>这里不支持事务回滚，指的是不支持运行时错误的事务回滚。</p><h3 id="5-6-监控"><a href="#5-6-监控" class="headerlink" title="5.6- 监控"></a>5.6- 监控</h3><p>watch 命令用于客户端并发情况下，为事务提供一个乐观锁（CAS，Check And Set），也就是可以用 watch 命令来监控一个或多个变量，如果在事务的过程中，某个<strong>监控项被修改</strong>了，那么<strong>整个事务</strong>就会<strong>终止执行</strong>。</p><p>watch 基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch key [key ...]</span><br></pre></td></tr></table></figure><p><code>watch</code> 示例代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：以上事务在执行期间，也就是开启事务（multi）之后，执行事务（exec）之前，模拟多客户端并发操作了变量 k 的值，这个时候再去执行事务，才会出现如上结果，exec 执行的结果为 nil。</p><p>可以看出，当执行 exec 返回的结果是 nil 时，表示 watch 监控的对象在事务执行的过程中被修改了。从 <code>get k</code> 的结果也可以印证，因为事务中设置的值 <code>set k v2</code> 并未正常执行。</p><p>执行流程如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/watch%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><p><strong>注意</strong>： watch 命令只能在客户端开启事务之前执行，在事务中执行 watch 命令会引发错误，但不会造成整个事务失败，如下代码所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> watch k</span></span><br><span class="line">(error) ERR WATCH inside MULTI is not allowed</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure><p>执行命令解释如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/watch%E6%89%A7%E8%A1%8C%E8%A7%A3%E9%87%8A.png"></p><p><strong>unwatch 命令用于清除所有之前监控的所有对象（键值对）。</strong></p><p>unwatch 示例如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> watch k</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> multi</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> unwatch</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> k v2</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">exec</span></span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get k</span></span><br><span class="line">&quot;v2&quot;</span><br></pre></td></tr></table></figure><p>可以看出，即使在事务的执行过程中，k 值被修改了，因为调用了 unwatch 命令，整个事务依然会顺利执行。</p><h3 id="5-7-代码实战"><a href="#5-7-代码实战" class="headerlink" title="5.7-代码实战"></a>5.7-代码实战</h3><p>以下是事务在 Java 中的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置键值</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启监视 watch</span></span><br><span class="line">        jedis.watch(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 开始事务</span></span><br><span class="line">        Transaction tx = jedis.multi();</span><br><span class="line">        <span class="comment">// 命令入列</span></span><br><span class="line">        tx.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行事务</span></span><br><span class="line">        tx.exec();</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8-小结"></a>5.8-小结</h3><p>事务为多个命令提供一次性按顺序执行的机制，与 Redis 事务相关的命令有以下五个：</p><ul><li>multi：开启事务</li><li>exec：执行事务</li><li>discard：丢弃事务</li><li>watch：为事务提供乐观锁实现</li><li>unwatch：取消监控（取消事务中的乐观锁）</li></ul><p>正常情况下 Redis 事务分为三个阶段：开启事务、命令入列、执行事务。Redis 事务并不支持运行时错误的事务回滚，但在某些入列错误，如 <code>set key</code> 或者是 <code>watch</code> 监控项被修改时，提供整个事务回滚的功能。</p><h2 id="6-Redis键值过期"><a href="#6-Redis键值过期" class="headerlink" title="6-Redis键值过期"></a>6-Redis键值过期</h2><p>Redis 所有的数据结构都可以设置过期时间，时间一到，就会自动删除。你可以想象 Redis 内部有一个死神，时刻盯着所有设置了过期时间的 key，寿命一到就会立即收割。</p><p>你还可以进一步站在死神的角度思考，会不会因为同一时间太多的 key 过期，以至于忙不过来。同时因为 Redis 是单线程的，收割的时间也会占用线程的处理时间，如果收割的太过于繁忙，会不会导致线上读写指令出现卡顿。</p><p>这些问题 Antirez 早就想到了，所有在过期这件事上，Redis 非常小心。</p><h3 id="6-1-Redis过期策略"><a href="#6-1-Redis过期策略" class="headerlink" title="6.1-Redis过期策略"></a>6.1-Redis过期策略</h3><h4 id="1-过期的-key-集合"><a href="#1-过期的-key-集合" class="headerlink" title="1. 过期的 key 集合"></a>1. 过期的 key 集合</h4><p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。</p><h4 id="2-定时扫描策略"><a href="#2-定时扫描策略" class="headerlink" title="2. 定时扫描策略"></a>2. 定时扫描策略</h4><p>Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</p><ol><li>从过期字典中随机 20 个 key；</li><li>删除这 20 个 key 中已经过期的 key；</li><li>如果过期的 key 比率超过 1/4，那就重复步骤 1；</li></ol><p>同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</p><p>设想一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？</p><p>毫无疑问，Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀疏，才会停止 (循环次数明显下降)。这就会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。</p><p>当客户端请求到来时，服务器如果正好进入过期扫描状态，客户端的请求将会等待至少 25ms 后才会进行处理，如果客户端将超时时间设置的比较短，比如 10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现很多异常。而且这时你还无法从 Redis 的 slowlog 中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间。</p><p>所以业务开发人员一定要注意过期时间，如果有大批量的 key 过期，要给过期时间设置一个随机范围，而不宜全部在同一时间过期，分散过期处理的压力。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在目标过期时间上增加一天的随机时间</span></span><br><span class="line"><span class="meta">redis.expire_at(key,</span> <span class="string">random.randint(86400) + expire_ts)</span></span><br></pre></td></tr></table></figure><p>在一些活动系统中，因为活动是一期一会，下一期活动举办时，前面几期的很多数据都可以丢弃了，所以需要给相关的活动数据设置一个过期时间，以减少不必要的 Redis 内存占用。如果不加注意，你可能会将过期时间设置为活动结束时间再增加一个常量的冗余时间，如果参与活动的人数太多，就会导致大量的 key 同时过期。</p><h4 id="3-从库的过期策略"><a href="#3-从库的过期策略" class="headerlink" title="3. 从库的过期策略"></a>3. 从库的过期策略</h4><p>从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 <code>del</code> 指令，同步到所有的从库，从库通过执行这条 <code>del</code> 指令来删除过期的 key。</p><p>因为指令同步是异步进行的，所以主库过期的 key 的 <code>del</code> 指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在。</p><h3 id="6-2-Redis-键值过期操作"><a href="#6-2-Redis-键值过期操作" class="headerlink" title="6.2-Redis 键值过期操作"></a>6.2-Redis 键值过期操作</h3><h4 id="1-过期设置"><a href="#1-过期设置" class="headerlink" title="1. 过期设置"></a>1. 过期设置</h4><p>Redis 中设置过期时间主要通过以下四种方式：</p><ul><li>expire key seconds：设置 key 在 n 秒后过期；</li><li>pexpire key milliseconds：设置 key 在 n 毫秒后过期；</li><li>expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；</li><li>pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；</li></ul><p>下面分别来看以上这些命令的具体实现。</p><ul><li><h5 id="expire：N-秒后过期"><a href="#expire：N-秒后过期" class="headerlink" title="expire：N 秒后过期"></a><strong>expire：N 秒后过期</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire key 100</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key</span><br><span class="line">(integer) 97</span><br></pre></td></tr></table></figure><p>其中命令 ttl 的全称是 Time To Live，表示此键值在 n 秒后过期。例如，上面的结果 97 表示 key 在 97s 后过期。</p></li><li><h5 id="pexpire：N-毫秒后过期"><a href="#pexpire：N-毫秒后过期" class="headerlink" title="pexpire：N 毫秒后过期"></a><strong>pexpire：N 毫秒后过期</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key2 value2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pexpire key2 100000</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pttl key2</span><br><span class="line">(integer) 94524</span><br></pre></td></tr></table></figure><p>其中 <code>pexpire key2 100000</code> 表示设置 key2 在 100000 毫秒（100 秒）后过期。</p></li><li><h5 id="expireat：过期时间戳精确到秒"><a href="#expireat：过期时间戳精确到秒" class="headerlink" title="expireat：过期时间戳精确到秒"></a><strong>expireat：过期时间戳精确到秒</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key3 value3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expireat key3 1573472683</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 67</span><br></pre></td></tr></table></figure><p>其中 <code>expireat key3 1573472683</code> 表示 key3 在时间戳 1573472683 后过期（精确到秒），使用 ttl 查询可以发现在 67s 后 key3 会过期。</p><blockquote><p>小贴士：在 Redis 可以使用 time 命令查询当前时间的时间戳（精确到秒），示例如下：</p><p>127.0.0.1:6379&gt; time</p><ol><li><p>“1573472563”</p></li><li><p>“248426”</p></li></ol></blockquote></li><li><h5 id="pexpireat：过期时间戳精确到毫秒"><a href="#pexpireat：过期时间戳精确到毫秒" class="headerlink" title="pexpireat：过期时间戳精确到毫秒"></a><strong>pexpireat：过期时间戳精确到毫秒</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key4 value4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pexpireat key4 1573472683000</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pttl key4</span><br><span class="line">(integer) 3522</span><br></pre></td></tr></table></figure><p>其中 <code>pexpireat key4 1573472683000</code> 表示 key4 在时间戳 1573472683000 后过期（精确到毫秒），使用 ttl 查询可以发现在 3522ms 后 key4 会过期。</p></li><li><h5 id="字符串中的过期操作"><a href="#字符串中的过期操作" class="headerlink" title="字符串中的过期操作"></a><strong>字符串中的过期操作</strong></h5><p>字符串中几个直接操作过期时间的方法，如下列表：</p><ul><li>set key value ex seconds：设置键值对的同时指定过期时间（精确到秒）；</li><li>set key value px milliseconds：设置键值对的同时指定过期时间（精确到毫秒）；</li><li>setex key seconds valule：设置键值对的同时指定过期时间（精确到秒）。</li></ul><p>实现示例如下。</p><h6 id="1-set-key-value-ex-seconds"><a href="#1-set-key-value-ex-seconds" class="headerlink" title="1. set key value ex seconds"></a><strong>1. set key value ex seconds</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k v ex 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k</span><br><span class="line">(integer) 97</span><br></pre></td></tr></table></figure><h6 id="2-set-key-value-ex-milliseconds"><a href="#2-set-key-value-ex-milliseconds" class="headerlink" title="2. set key value ex milliseconds"></a><strong>2. set key value ex milliseconds</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k2 v2 px 100000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pttl k2</span><br><span class="line">(integer) 92483</span><br></pre></td></tr></table></figure><h6 id="3-setex-key-seconds-valule"><a href="#3-setex-key-seconds-valule" class="headerlink" title="3. setex key seconds valule"></a><strong>3. setex key seconds valule</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex k3 100 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl k3</span><br><span class="line">(integer) 91</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-移除过期时间"><a href="#2-移除过期时间" class="headerlink" title="2. 移除过期时间"></a>2. 移除过期时间</h4><p>使用命令： <code>persist key</code> 可以移除键值的过期时间，如下代码所示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl k3</span><br><span class="line">(integer) 97</span><br><span class="line">127.0.0.1:6379&gt; persist k3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl k3</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><p>可以看出第一次使用 ttl 查询 k3 会在 97s 后过期，当使用了 persist 命令之后，在查询 k3 的存活时间发现结果是 -1，它表示 k3 永不过期。</p><h4 id="3-Java实现过期操作"><a href="#3-Java实现过期操作" class="headerlink" title="3. Java实现过期操作"></a>3. Java实现过期操作</h4><p>本文将使用 Jedis 框架来实现对 Redis 过期时间的操作，如下代码所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码(如果没有密码，此行可省略)</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对（默认情况下永不过期）</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询 TTL（过期时间）</span></span><br><span class="line">        Long ttl = jedis.ttl(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过期时间：&quot;</span> + ttl);</span><br><span class="line">        <span class="comment">// 设置 100s 后过期</span></span><br><span class="line">        jedis.expire(<span class="string">&quot;k&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 等待 1s 后执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行 expire 后的 TTL=&quot;</span> + jedis.ttl(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过期时间：-1</span><br><span class="line">执行 expire 后的 TTL=99</span><br></pre></td></tr></table></figure><p>可以看出使用 Jedis 来操作 Redis 的过期时间还是很方便的，可直接使用 <code>jedis.ttl(&quot;k&quot;)</code> 查询键值的生存时间，使用 <code>jedis.expire(&quot;k&quot;,seconds)</code> 方法设置过期时间（精确到秒）。</p><blockquote><p>小贴士：使用 Jedis 之前，先要把 Jedis 引入到程序中，如果使用的是 Maven 项目的，直接在 pom.xml 文件中添加以下引用：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;version&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>更多过期操作方法</strong>，如下列表：</p><ul><li>pexpire(String key, long milliseconds)：设置 n 毫秒后过期；</li><li>expireAt(String key, long unixTime)：设置某个时间戳后过期（精确到秒）；</li><li>pexpireAt(String key, long millisecondsTimestamp)：设置某个时间戳后过期（精确到毫秒）；</li><li>persist(String key)：移除过期时间。</li></ul><p>完整示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Redis 连接</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 设置 Redis 密码(如果没有密码，此行可省略)</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对（默认情况下永不过期）</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询 TTL（过期时间）</span></span><br><span class="line">        Long ttl = jedis.ttl(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过期时间：&quot;</span> + ttl);</span><br><span class="line">        <span class="comment">// 设置 100s 后过期</span></span><br><span class="line">        jedis.expire(<span class="string">&quot;k&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 等待 1s 后执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 打印过期日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行 expire 后的 TTL=&quot;</span> + jedis.ttl(<span class="string">&quot;k&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置 n 毫秒后过期</span></span><br><span class="line">        jedis.pexpire(<span class="string">&quot;k&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 设置某个时间戳后过期（精确到秒）</span></span><br><span class="line">        jedis.expireAt(<span class="string">&quot;k&quot;</span>, <span class="number">1573468990</span>);</span><br><span class="line">        <span class="comment">// 设置某个时间戳后过期（精确到毫秒）</span></span><br><span class="line">        jedis.pexpireAt(<span class="string">&quot;k&quot;</span>, <span class="number">1573468990000L</span>);</span><br><span class="line">        <span class="comment">// 移除过期时间</span></span><br><span class="line">        jedis.persist(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-持久化中的过期键"><a href="#4-持久化中的过期键" class="headerlink" title="4. 持久化中的过期键"></a>4. 持久化中的过期键</h4><p>上面我们讲了过期键在 Redis 正常运行中一些使用案例，接下来，我们来看 Redis 在持久化的过程中是如何处理过期键的。</p><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p><ul><li><h5 id="RDB-中的过期键"><a href="#RDB-中的过期键" class="headerlink" title="RDB 中的过期键"></a><strong>RDB 中的过期键</strong></h5><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p><h6 id="1-RDB-文件生成"><a href="#1-RDB-文件生成" class="headerlink" title="1. RDB 文件生成"></a><strong>1. RDB 文件生成</strong></h6><p>从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键不会被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p><h6 id="2-RDB-文件加载"><a href="#2-RDB-文件加载" class="headerlink" title="2. RDB 文件加载"></a><strong>2. RDB 文件加载</strong></h6><p>RDB 加载分为以下两种情况：</p><ul><li>如果 Redis 是主服务器运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li><li>如果 Redis 是从服务器运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul><p>RDB 文件加载的源码可以在 rdb.c 文件的 rdbLoad() 函数中找到，源码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if the key already expired. This function is used when loading</span></span><br><span class="line"><span class="comment">* an RDB file from disk, either at startup, or when an RDB was</span></span><br><span class="line"><span class="comment">* received from the master. In the latter case, the master is</span></span><br><span class="line"><span class="comment">* responsible for key expiry. If we would expire keys here, the</span></span><br><span class="line"><span class="comment">* snapshot taken by the master may not be reflected on the slave. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 如果服务器为主节点的话，</span></span><br><span class="line"><span class="comment">* 那么在键已经过期的时候，不再将它们关联到数据库中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">    decrRefCount(key);</span><br><span class="line">    decrRefCount(val);</span><br><span class="line">    <span class="comment">// 跳过</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="AOF-中的过期键"><a href="#AOF-中的过期键" class="headerlink" title="AOF 中的过期键"></a><strong>AOF 中的过期键</strong></h5><h6 id="1-AOF-文件写入"><a href="#1-AOF-文件写入" class="headerlink" title="1. AOF 文件写入"></a><strong>1. AOF 文件写入</strong></h6><p>当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。</p><h6 id="2-AOF-重写"><a href="#2-AOF-重写" class="headerlink" title="2. AOF 重写"></a><strong>2. AOF 重写</strong></h6><p>执行 AOF 重写时，会对 Redis 中的键值对进行检查已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。</p></li></ul><h4 id="5-主从库的过期键"><a href="#5-主从库的过期键" class="headerlink" title="5. 主从库的过期键"></a>5. 主从库的过期键</h4><p>当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p><p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h4><p>本文我们知道了 Redis 中的四种设置过期时间的方式：expire、pexpire、expireat、pexpireat，其中比较常用的是 expire 设置键值 n 秒后过期。</p><p>字符串中可以在添加键值的同时设置过期时间，并可以使用 persist 命令移除过期时间。同时我们也知道了过期键在 RDB 写入和 AOF 重写时都不会被记录。</p><p>过期键在主从模式下，从库对过期键的处理要完全依靠主库，主库删除过期键之后会发送 del 命令给所有的从库。</p><p>本文的知识点，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Redis%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C.png"></p><h3 id="6-3-Redis-过期策略与源码分析"><a href="#6-3-Redis-过期策略与源码分析" class="headerlink" title="6.3-Redis 过期策略与源码分析"></a>6.3-Redis 过期策略与源码分析</h3><h4 id="1-过期键执行流程"><a href="#1-过期键执行流程" class="headerlink" title="1. 过期键执行流程"></a>1. 过期键执行流程</h4><p>Redis 之所以能知道那些键值过期，是因为在 Redis 中维护了一个字典，存储了所有设置了过期时间的键值，我们称之为过期字典。</p><p>过期键判断流程如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.png"></p><h4 id="2-过期键源码分析"><a href="#2-过期键源码分析" class="headerlink" title="2. 过期键源码分析"></a>2. 过期键源码分析</h4><p>过期键存储在 redisDb 结构中，源代码在 src/server.h 文件中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></span><br><span class="line"><span class="comment"> * by integers from 0 (the default database) up to the max configured</span></span><br><span class="line"><span class="comment"> * database. The database number is the &#x27;id&#x27; field in the structure. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：本文的所有源码都是基于 Redis 5。</p></blockquote><p>过期键数据结构如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%BF%87%E6%9C%9F%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><h4 id="3-过期策略"><a href="#3-过期策略" class="headerlink" title="3. 过期策略"></a>3. 过期策略</h4><p>Redis 会删除已过期的键值，以此来减少 Redis 的空间占用，但因为 Redis 本身是单线的，如果因为删除操作而影响主业务的执行就得不偿失了，为此 Redis 需要制定多个（过期）删除策略来保证糟糕的事情不会发生。</p><p>常见的过期策略有以下三种：</p><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p>下面分别来看每种策略有何不同。</p><ul><li><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a><strong>定时删除</strong></h5><p>在设置键值过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。</p><ul><li><strong>优点：</strong>保证内存可以被尽快地释放。</li><li><strong>缺点：</strong>在 Redis 高负载的情况下或有大量过期键需要同时处理时，会造成 Redis 服务器卡顿，影响主业务执行。</li></ul></li><li><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h5><p>不主动删除过期键，每次从数据库获取键值时判断是否过期，如果过期则删除键值，并返回 null。</p><ul><li><strong>优点：</strong>因为每次访问时，才会判断过期键，所以此策略只会使用很少的系统资源。</li><li><strong>缺点：</strong>系统占用空间删除不及时，导致空间利用率降低，造成了一定的空间浪费。</li></ul><p><strong>源码解析</strong></p><p>惰性删除的源码位于 src/db.c 文件的 expireIfNeeded 方法中，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断键是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    <span class="comment">// 增加过期键个数</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 传播键过期的消息</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">    <span class="comment">// server.lazyfree_lazy_expire 为 1 表示异步删除（懒空间释放），反之同步删除</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断键是否过期</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line">    <span class="comment">/* Don&#x27;t expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有对数据库的读写命令在执行之前，都会调用 expireIfNeeded 方法判断键值是否过期，过期则会从数据库中删除，反之则不做任何处理。</p><p>惰性删除执行流程，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p></li><li><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h5><p>每隔一段时间检查一次数据库，随机删除一些过期键。</p><p>Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 <code>hz 10</code>。</p><p>需要注意的是：Redis 每次扫描并不是遍历过期字典中的所有键，而是采用随机抽取判断并删除过期键的形式执行的。</p><h6 id="1-定期删除流程"><a href="#1-定期删除流程" class="headerlink" title="1. 定期删除流程"></a><strong>1. 定期删除流程</strong></h6><ol><li>从过期字典中随机取出 20 个键；</li><li>删除这 20 个键中过期的键；</li><li>如果过期 key 的比例超过 25%，重复步骤 1。</li></ol><p>同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</p><p>定期删除执行流程，如下图所示：</p></li></ul><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><ul><li><strong>优点：</strong>通过限制删除操作的时长和频率，来减少删除操作对 Redis 主业务的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li><li><strong>缺点：</strong>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li></ul><h6 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. <strong>源码解析</strong></h6><p>定期删除的核心源码在 src/expire.c 文件下的 activeExpireCycle 方法中，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* 上次定期删除遍历到的数据库ID */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* 上一次执行快速定期删除的时间点 */</span></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL; <span class="comment">// 每次定期删除，遍历的数据库的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ACTIVE_EXPIRE_CYCLE_FAST_DURATION 是快速定期删除的执行时长</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">    <span class="comment">// 慢速定期删除的执行时长</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* 删除操作的执行时长 */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> expired;</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line">        current_db++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// .......</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 每个数据库中检查的键的数量</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line">            <span class="comment">// 从数据库中随机选取 num 个键进行检查</span></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedInteger</span><br><span class="line">                <span class="comment">// 过期检查，并对过期键进行删除</span></span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* We want the average TTL of keys yet not expired. */</span></span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">                total_sampled++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 每次检查只删除 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4 个过期键 */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>activeExpireCycle 方法在规定的时间，分多次遍历各个数据库，从过期字典中随机检查一部分过期键的过期时间，删除其中的过期键。</p><p>这个函数有两种执行模式，一个是快速模式一个是慢速模式，体现是代码中的 timelimit 变量，这个变量是用来约束此函数的运行时间的。快速模式下 timelimit 的值是固定的，等于预定义常量 ACTIVE_EXPIRE_CYCLE_FAST_DURATION，慢速模式下，这个变量的值是通过 <code>1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100</code> 计算的。</p><ul><li><h5 id="Redis-使用的过期策略"><a href="#Redis-使用的过期策略" class="headerlink" title="Redis 使用的过期策略"></a><strong>Redis 使用的过期策略</strong></h5><p>Redis 使用的是惰性删除加定期删除的过期策略。</p></li></ul><h2 id="7-Redis-管道技术—Pipeline"><a href="#7-Redis-管道技术—Pipeline" class="headerlink" title="7-Redis 管道技术—Pipeline"></a>7-Redis 管道技术—Pipeline</h2><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p><p>通常情况下 Redis 是单行执行的，客户端先向服务器发送请求，服务端接收并处理请求后再把结果返回给客户端，这种处理模式在非频繁请求时不会有任何问题。</p><p>但如果出现集中大批量的请求时，因为每个请求都要经历先请求再响应的过程，这就会造成网络资源浪费，此时就需要管道技术来把所有的命令整合一次发给服务端，再一次响应给客户端，这样就能大大的提升了 Redis 的响应速度。</p><p><strong>普通命令模式，如下图所示：</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png"></p><p>两个连续的写操作和两个连续的读操作总共只会花费一次网络来回，就好比连续的 write 操作合并了，连续的 read 操作也合并了一样。</p><p><strong>管道模式，如下图所示：</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.png"></p><p>这便是管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常的流程。客户端通过对管道中的指令列表改变读写顺序就可以大幅节省 IO 时间。管道中指令越多，效果越好。</p><h3 id="7-1-管道技术的作用"><a href="#7-1-管道技术的作用" class="headerlink" title="7.1-管道技术的作用"></a>7.1-管道技术的作用</h3><p>管道技术解决了多个命令集中请求时造成网络资源浪费的问题，加快了 Redis 的响应速度，让 Redis 拥有更高的运行速度。但要注意的一点是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><h3 id="7-2-管道技术的本质"><a href="#7-2-管道技术的本质" class="headerlink" title="7.2-管道技术的本质"></a>7.2-管道技术的本质</h3><p>接下来我们深入分析一个请求交互的流程，真实的情况是它很复杂，因为要经过网络协议栈，这个就得深入内核了。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E7%9A%84%E6%B5%81%E7%A8%8B.png"></p><p>上图就是一个完整的请求交互流程图。我用文字来仔细描述一遍：</p><ol><li>客户端进程调用<code>write</code>将消息写到操作系统内核为套接字分配的发送缓冲<code>send buffer</code>。</li><li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到服务器的网卡。</li><li>服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲<code>recv buffer</code>。</li><li>服务器进程调用<code>read</code>从接收缓冲中取出消息进行处理。</li><li>服务器进程调用<code>write</code>将响应消息写到内核为套接字分配的发送缓冲<code>send buffer</code>。</li><li>服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到客户端的网卡。</li><li>客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲<code>recv buffer</code>。</li><li>客户端进程调用<code>read</code>从接收缓冲中取出消息返回给上层业务逻辑进行处理。</li><li>结束。</li></ol><p>其中步骤 5<del>8 和 1</del>4 是一样的，只不过方向是反过来的，一个是请求，一个是响应。</p><p>我们开始以为 <code>write</code> 操作是要等到对方收到消息才会返回，但实际上不是这样的。<code>write</code> 操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空闲空间来，这个就是写操作 IO 操作的真正耗时。</p><p>我们开始以为 <code>read</code> 操作是从目标机器拉取数据，但实际上不是这样的。<code>read</code> 操作只负责将数据从本地操作系统内核的接收缓冲中取出来就了事了。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读操作 IO 操作的真正耗时。</p><p>所以对于<code>value = redis.get(key)</code>这样一个简单的请求来说，<code>write</code>操作几乎没有耗时，直接写到发送缓冲就返回，而<code>read</code>就会比较耗时了，因为它要等待消息经过网络路由到目标机器处理后的响应消息,再回送到当前的内核读缓冲才可以返回。<strong>这才是一个网络来回的真正开销</strong>。</p><p>而对于管道来说，连续的<code>write</code>操作根本就没有耗时，之后第一个<code>read</code>操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓冲了，后续的 <code>read</code> 操作直接就可以从缓冲拿到结果，瞬间就返回了。</p><h3 id="7-3-管道技术的使用"><a href="#7-3-管道技术的使用" class="headerlink" title="7.3-管道技术的使用"></a>7.3-管道技术的使用</h3><p>本文我们使用 Jedis 客户端提供的 Pipeline 对象来实现管道技术。首先先获取 Pipeline 对象，再为 Pipeline 对象设置需要执行的命令，最后再使用 sync() 方法或 syncAndReturnAll() 方法来统一执行这些命令，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipelineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            pipe.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行耗时：297毫秒</span><br></pre></td></tr></table></figure><p>如果要接收管道所有命令的执行结果，可使用 syncAndReturnAll() 方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipelineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 获取 Pipeline 对象</span></span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line">        <span class="comment">// 设置多个 Redis 命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令并返回结果</span></span><br><span class="line">        List&lt;Object&gt; res = pipe.syncAndReturnAll();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : res) &#123;</span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-管道技术-VS-普通命令"><a href="#7-4-管道技术-VS-普通命令" class="headerlink" title="7.4-管道技术 VS 普通命令"></a>7.4-管道技术 VS 普通命令</h3><p>上面使用管道技术执行一个 for 循环所用的时间为 297 毫秒，接下来我们用普通的命令执行此循环，看下程序的执行时间，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipelineExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 记录执行开始时间</span></span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">            jedis.del(<span class="string">&quot;key&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录执行结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (endTime - beginTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行耗时：17276毫秒</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>从上面的结果可以看出，管道的执行时间是 297 毫秒，而普通命令执行时间是 17276 毫秒，管道技术要比普通的执行快了 58 倍。</p><h3 id="7-5-管道技术需要注意的事项"><a href="#7-5-管道技术需要注意的事项" class="headerlink" title="7.5-管道技术需要注意的事项"></a>7.5-管道技术需要注意的事项</h3><p>管道技术虽然有它的优势，但在使用时还需注意以下几个细节：</p><ul><li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li><li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li><li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li></ul><p>使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率，但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p><h2 id="8-内存淘汰机制与算法"><a href="#8-内存淘汰机制与算法" class="headerlink" title="8-内存淘汰机制与算法"></a>8-内存淘汰机制与算法</h2><p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用。</p><p>在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 <code>maxmemory</code> 来限制内存超出期望大小。</p><p>当实际内存超出 <code>maxmemory</code> 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。</p><h3 id="8-1-Redis最大内存"><a href="#8-1-Redis最大内存" class="headerlink" title="8.1-Redis最大内存"></a>8.1-Redis最大内存</h3><p>只有在 Redis 的运行内存达到了某个阀值，才会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><p>内存淘汰执行流程，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><p><strong>查询最大运行内存</strong></p><p>我们可以使用命令 <code>config get maxmemory</code> 来查看设置的最大运行内存，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br><span class="line">1) &quot;maxmemory&quot;</span><br><span class="line">2) &quot;0&quot;</span><br></pre></td></tr></table></figure><p>我们发现此值竟然是 0，这是 64 位操作系统默认的值，当 maxmemory 为 0 时，表示没有内存大小限制。</p><blockquote><p>小贴士：32 位操作系统，默认的最大内存值是 3GB。</p></blockquote><h3 id="8-2-内存淘汰策略"><a href="#8-2-内存淘汰策略" class="headerlink" title="8.2-内存淘汰策略"></a>8.2-内存淘汰策略</h3><h4 id="1-查看-Redis-内存淘汰策略"><a href="#1-查看-Redis-内存淘汰策略" class="headerlink" title="1. 查看 Redis 内存淘汰策略"></a><strong>1. 查看 Redis 内存淘汰策略</strong></h4><p>我们可以使用 <code>config get maxmemory-policy</code> 命令，来查看当前 Redis 的内存淘汰策略，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) &quot;maxmemory-policy&quot;</span><br><span class="line">2) &quot;noeviction&quot;</span><br></pre></td></tr></table></figure><p>可以看出此 Redis 使用的是 noeviction 类型的内存淘汰机制，它表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。</p><h4 id="2-内存淘汰策略分类"><a href="#2-内存淘汰策略分类" class="headerlink" title="2. 内存淘汰策略分类"></a>2. <strong>内存淘汰策略分类</strong></h4><p>早期版本的 Redis 有以下 6 种淘汰策略：</p><ol><li><strong>noeviction</strong>：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>volatile-lru</strong>：淘汰所有设置了过期时间的键值中最久未使用的键值；</li><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li></ol><p>在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p><ol><li><strong>volatile-lfu</strong>：淘汰所有设置了过期时间的键值中，最少使用的键值；</li><li><strong>allkeys-lfu</strong>：淘汰整个键值中最少使用的键值。</li></ol><p>其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p><ul><li><h5 id="修改-Redis-内存淘汰策略"><a href="#修改-Redis-内存淘汰策略" class="headerlink" title="修改 Redis 内存淘汰策略"></a>修改 Redis 内存淘汰策略</h5><h5 id="设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。"><a href="#设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。" class="headerlink" title="设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。"></a>设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。</h5><ul><li><p>方式一：通过“config set maxmemory-policy 策略”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</p></li><li><p>方式二：通过修改 Redis 配置文件修改，设置“maxmemory-policy 策略”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</p></li></ul></li><li><h5 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h5></li></ul><p>从内测淘汰策略分类上，我们可以得知，除了随机删除和不删除之外，主要有两种淘汰算法：LRU 算法和 LFU 算法。</p><h3 id="8-3-LRU-算法"><a href="#8-3-LRU-算法" class="headerlink" title="8.3-LRU 算法"></a>8.3-<strong>LRU 算法</strong></h3><p>LRU 全称是 Least Recently Used 译为最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p><h4 id="1-LRU-算法实现"><a href="#1-LRU-算法实现" class="headerlink" title="1. LRU 算法实现"></a>1. <strong>LRU 算法实现</strong></h4><p>LRU 算法需要基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可。</p><p>现 LRU 算法除了需要 key/value 字典外，还需要附加一个链表，链表中的元素按照一定的顺序进行排列。当空间满的时候，会踢掉链表尾部的元素。当字典的某个元素被访问时，它在链表中的位置会被移动到表头。所以链表的元素排列顺序就是元素最近被访问的时间顺序。</p><p>位于链表尾部的元素就是不被重用的元素，所以会被踢掉。位于表头的元素就是最近刚刚被人用过的元素，所以暂时不会被踢。</p><h4 id="2-近-LRU-算法"><a href="#2-近-LRU-算法" class="headerlink" title="2. 近 LRU 算法"></a>2. <strong>近 LRU 算法</strong></h4><p>Redis 使用的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的最后一次访问时间，Redis 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p><p>Redis 使用的是一种近似 LRU 算法，它跟 LRU 算法还不太一样。之所以不使用 LRU 算法，是因为需要消耗大量的额外的内存，需要对现有的数据结构进行较大的改造。近似 LRU 算法则很简单，在现有数据结构的基础上使用随机采样法来淘汰元素，能达到和 LRU 算法非常近似的效果。Redis 为实现近似 LRU 算法，它给每个 key 增加了一个额外的小字段，这个字段的长度是 24 个 bit，也就是最后一次被访问的时间戳。</p><h4 id="3-LRU-算法缺点"><a href="#3-LRU-算法缺点" class="headerlink" title="3. LRU 算法缺点"></a>3. <strong>LRU 算法缺点</strong></h4><p>LRU 算法有一个缺点，比如说很久没有使用的一个键值，如果最近被访问了一次，那么它就不会被淘汰，即使它是使用次数最少的缓存，那它也不会被淘汰，因此在 Redis 4.0 之后引入了 LFU 算法。</p><h4 id="4-LFU-算法"><a href="#4-LFU-算法" class="headerlink" title="4. LFU 算法"></a>4. <strong>LFU 算法</strong></h4><p>LFU 全称是 Least Frequently Used 翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>LFU 解决了偶尔被访问一次之后，数据就不会被淘汰的问题，相比于 LRU 算法也更合理一些。</p><p>在 Redis 中每个对象头中记录着 LFU 的信息，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>在 Redis 中 LFU 存储分为两部分，16 bit 的 ldt（last decrement time）和 8 bit 的 logc（logistic counter）。</p><ol><li>logc 是用来存储访问频次，8 bit 能表示的最大整数值为 255，它的值越小表示使用频率越低，越容易淘汰；</li><li>ldt 是用来存储上一次 logc 的更新时间。</li></ol><h2 id="9-查询附近的人—GeoHash"><a href="#9-查询附近的人—GeoHash" class="headerlink" title="9-查询附近的人—GeoHash"></a>9-查询附近的人—GeoHash</h2><p>我们所处的任何位置都可以用经度和纬度来标识，经度的范围 -180 到 180，纬度的范围为 -90 到 90。纬度以赤道为界，赤道以南为负数，赤道以北为正数；经度以本初子午线（英国格林尼治天文台）为界，东边为正数，西边为负数。</p><p>Redis 在 3.2 版本中增加了 GEO 类型用于存储和查询地理位置，关于 GEO 的命令不多，主要包含以下 6 个：</p><ol><li>geoadd：添加地理位置</li><li>geopos：查询位置信息</li><li>geodist：距离统计</li><li>georadius：查询某位置内的其他成员信息</li><li>geohash：查询位置的哈希值</li><li>zrem：删除地理位置</li></ol><h3 id="9-1-用数据库来算附近的人"><a href="#9-1-用数据库来算附近的人" class="headerlink" title="9.1-用数据库来算附近的人"></a>9.1-用数据库来算附近的人</h3><p>地图元素的位置数据使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，纬度正负以赤道为界，北正南负，经度正负以本初子午线 (英国格林尼治天文台) 为界，东正西负。比如掘金办公室在望京 SOHO，它的经纬度坐标是 (116.48105,39.996794)，都是正数，因为中国位于东北半球。</p><p>当两个元素的距离不是很远时，可以直接使用勾股定理就能算得元素之间的距离。我们平时使用的「附近的人」的功能，元素距离都不是很大，勾股定理算距离足矣。不过需要注意的是，经纬度坐标的密度不一样 (地球是一个椭圆)，勾股定律计算平方差时之后再求和时，需要按一定的系数比加权求和，如果不求精确的话，也可以不必加权。</p><p>问题：经度总共360度，维度总共只有180度，为什么距离密度不是2:1？</p><p>现在，如果要计算「附近的人」，也就是给定一个元素的坐标，然后计算这个坐标附近的其它元素，按照距离进行排序，该如何下手？</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%BB%8F%E7%BA%AC%E5%BA%A6.png"></p><p>如果现在元素的经纬度坐标使用关系数据库 (元素 id, 经度 x, 纬度 y) 存储，你该如何计算？</p><p>首先，你不可能通过遍历来计算所有的元素和目标元素的距离然后再进行排序，这个计算量太大了，性能指标肯定无法满足。一般的方法都是通过矩形区域来限定元素的数量，然后对区域内的元素进行全量距离计算再排序。这样可以明显减少计算量。如何划分矩形区域呢？可以指定一个半径 r，使用一条 SQL 就可以圈出来。当用户对筛出来的结果不满意，那就扩大半径继续筛选。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id from positions where x0-r &lt; x &lt; x0+r and y0-r &lt; y &lt; y0+r</span><br></pre></td></tr></table></figure><p>为了满足高性能的矩形区域算法，数据表需要在经纬度坐标加上双向复合索引 (x, y)，这样可以最大优化查询性能。</p><p>但是数据库查询性能毕竟有限，如果「附近的人」查询请求非常多，在高并发场合，这可能并不是一个很好的方案。</p><h3 id="9-2-GeoHash-算法"><a href="#9-2-GeoHash-算法" class="headerlink" title="9.2-GeoHash 算法"></a>9.2-GeoHash 算法</h3><p>业界比较通用的地理位置距离排序算法是 GeoHash 算法，Redis 也使用 GeoHash 算法。GeoHash 算法将二维的经纬度数据映射到一维的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。当我们想要计算「附近的人时」，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行了。</p><p>那这个映射算法具体是怎样的呢？它将整个地球看成一个二维平面，然后划分成了一系列正方形的方格，就好比围棋棋盘。所有的地图元素坐标都将放置于唯一的方格中。方格越小，坐标越精确。然后对这些方格进行整数编码，越是靠近的方格编码越是接近。那如何编码呢？一个最简单的方案就是切蛋糕法。设想一个正方形的蛋糕摆在你面前，二刀下去均分分成四块小正方形，这四个小正方形可以分别标记为 00,01,10,11 四个二进制整数。然后对每一个小正方形继续用二刀法切割一下，这时每个小小正方形就可以使用 4bit 的二进制整数予以表示。然后继续切下去，正方形就会越来越小，二进制整数也会越来越长，精确度就会越来越高。</p><p>编码之后，每个地图元素的坐标都将变成一个整数，通过这个整数可以还原出元素的坐标，整数越长，还原出来的坐标值的损失程度就越小。对于「附近的人」这个功能而言，损失的一点精确度可以忽略不计。</p><p>GeoHash 算法会继续对这个整数做一次 base32 编码 (0-9,a-z 去掉 a,i,l,o 四个字母) 变成一个字符串。在 Redis 里面，经纬度使用 52 位的整数进行编码，放进了 zset 里面，zset 的 value 是元素的 key，score 是 GeoHash 的 52 位整数值。zset 的 score 虽然是浮点数，但是对于 52 位的整数值，它可以无损存储。</p><p>在使用 Redis 进行 Geo 查询时，我们要时刻想到它的内部结构实际上只是一个 zset(skiplist)。通过 zset 的 score 排序就可以得到坐标附近的其它元素 (实际情况要复杂一些，不过这样理解足够了)，通过将 score 还原成坐标值就可以得到元素的原始坐标。</p><h3 id="9-3-Redis的GEO的使用"><a href="#9-3-Redis的GEO的使用" class="headerlink" title="9.3-Redis的GEO的使用"></a>9.3-Redis的GEO的使用</h3><h4 id="1-添加地理位置"><a href="#1-添加地理位置" class="headerlink" title="1. 添加地理位置"></a>1. <strong>添加地理位置</strong></h4><p>我们先用百度地图提供的经纬度查询工具，地址：</p><blockquote><p><a target="_blank" rel="noopener" href="http://api.map.baidu.com/lbsapi/getpoint/index.html">http://api.map.baidu.com/lbsapi/getpoint/index.html</a></p></blockquote><p>如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%BB%8F%E7%BA%AC%E5%BA%A6%E6%9F%A5%E8%AF%A2.png"></p><p>找了以下 4 个地点，添加到 Redis 中：</p><ol><li>天安门：116.404269,39.913164</li><li>月坛公园：116.36,39.922461</li><li>北京欢乐谷：116.499705,39.874635</li><li>香山公园：116.193275,39.996348</li></ol><p>代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd site 116.404269 39.913164 tianan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.36 39.922461 yuetan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.499705 39.874635 huanle</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd site 116.193275 39.996348 xiangshan</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure><p>重点参数说明如下：</p><ul><li>longitude 表示经度</li><li>latitude 表示纬度</li><li>member 是为此经纬度起的名字</li></ul><p>此命令支持一次添加一个或多个位置信息。</p><h4 id="2-查询位置信息"><a href="#2-查询位置信息" class="headerlink" title="2. 查询位置信息"></a>2. <strong>查询位置信息</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos site tianan</span><br><span class="line">1) 1) &quot;116.40541702508926392&quot;</span><br><span class="line">   2) &quot;39.91316289865137179&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure><p>此命令支持查看一个或多个位置信息。</p><h4 id="3-距离统计"><a href="#3-距离统计" class="headerlink" title="3. 距离统计"></a>3. <strong>距离统计</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist site tianan yuetan km</span><br><span class="line">&quot;3.9153&quot;</span><br></pre></td></tr></table></figure><p>可以看出天安门距离月坛公园的直线距离大概是 3.9 km，我们打开地图使用工具测试一下咱们的统计结果是否准确，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%B7%9D%E7%A6%BB%E7%BB%9F%E8%AE%A1.png"></p><p>可以看出 Redis 的统计和使用地图工具统计的距离是完全吻合的。</p><blockquote><p>注意：此命令统计的距离为两个位置的直线距离。</p></blockquote><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure><p>unit 参数表示统计单位，它可以设置以下值：</p><ul><li>m：以米为单位，默认单位；</li><li>km：以千米为单位；</li><li>mi：以英里为单位；</li><li>ft：以英尺为单位。</li></ul><h4 id="4-查询某位置内的其他成员信息"><a href="#4-查询某位置内的其他成员信息" class="headerlink" title="4. 查询某位置内的其他成员信息"></a>4. <strong>查询某位置内的其他成员信息</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>此命令的意思是查询天安门（116.405419,39.913164）附近 5 公里范围内的成员列表。</p><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]</span><br></pre></td></tr></table></figure><p>可选参数说明如下。</p><p><strong>1. WITHCOORD</strong></p><p>说明：返回满足条件位置的经纬度信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withcoord</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) 1) &quot;116.40426903963088989&quot;</span><br><span class="line">      2) &quot;39.91316289865137179&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) 1) &quot;116.36000186204910278&quot;</span><br><span class="line">      2) &quot;39.92246025586381819&quot;</span><br></pre></td></tr></table></figure><p><strong>2. WITHDIST</strong></p><p>说明：返回满足条件位置与查询位置的直线距离。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br></pre></td></tr></table></figure><p><strong>3. WITHHASH</strong></p><p>说明：返回满足条件位置的哈希信息。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withhash</span><br><span class="line">1) 1) &quot;tianan&quot;</span><br><span class="line">   2) (integer) 4069885552230465</span><br><span class="line">2) 1) &quot;yuetan&quot;</span><br><span class="line">   2) (integer) 4069879797297521</span><br></pre></td></tr></table></figure><p><strong>4. COUNT count</strong></p><p>说明：指定返回满足条件位置的个数。</p><p>例如，指定返回一条满足条件的信息，代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km count 1</span><br><span class="line">1) &quot;tianan&quot;</span><br></pre></td></tr></table></figure><p><strong>5. ASC|DESC</strong></p><p>说明：从近到远|从远到近排序返回。</p><p>示例代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km desc</span><br><span class="line">1) &quot;yuetan&quot;</span><br><span class="line">2) &quot;tianan&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km asc</span><br><span class="line">1) &quot;tianan&quot;</span><br><span class="line">2) &quot;yuetan&quot;</span><br></pre></td></tr></table></figure><p>当然以上这些可选参数也可以一起使用，例如以下代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius site 116.405419 39.913164 5 km withdist desc</span><br><span class="line">1) 1) &quot;yuetan&quot;</span><br><span class="line">   2) &quot;4.0100&quot;</span><br><span class="line">2) 1) &quot;tianan&quot;</span><br><span class="line">   2) &quot;0.0981&quot;</span><br></pre></td></tr></table></figure><p><strong>5. 查询哈希值</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash site tianan</span><br><span class="line">1) &quot;wx4g0cgp000&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure><p>此命令支持查询一个或多个地址的哈希值。</p><p><strong>6. 删除地理位置</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem site xiaoming</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个位置信息。</p><h3 id="9-4-代码实战"><a href="#9-4-代码实战" class="headerlink" title="9.4-代码实战"></a>9.4-代码实战</h3><p>下面我们用 Java 代码，来实现查询附近的人，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoCoordinate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoRadiusResponse;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.GeoUnit;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoHashExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        Map&lt;String, GeoCoordinate&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加小明的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoming&quot;</span>, <span class="keyword">new</span> GeoCoordinate(<span class="number">116.404269</span>, <span class="number">39.913164</span>));</span><br><span class="line">        <span class="comment">// 添加小红的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaohong&quot;</span>, <span class="keyword">new</span> GeoCoordinate(<span class="number">116.36</span>, <span class="number">39.922461</span>));</span><br><span class="line">        <span class="comment">// 添加小美的位置</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaomei&quot;</span>, <span class="keyword">new</span> GeoCoordinate(<span class="number">116.499705</span>, <span class="number">39.874635</span>));</span><br><span class="line">        <span class="comment">// 添加小二</span></span><br><span class="line">        map.put(<span class="string">&quot;xiaoer&quot;</span>, <span class="keyword">new</span> GeoCoordinate(<span class="number">116.193275</span>, <span class="number">39.996348</span>));</span><br><span class="line">        jedis.geoadd(<span class="string">&quot;person&quot;</span>, map);</span><br><span class="line">        <span class="comment">// 查询小明和小红的直线距离</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小明和小红相距：&quot;</span> + jedis.geodist(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="string">&quot;xiaohong&quot;</span>, GeoUnit.KM) + <span class="string">&quot; KM&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询小明附近 5 公里的人</span></span><br><span class="line">        List&lt;GeoRadiusResponse&gt; res = jedis.georadiusByMemberReadonly(<span class="string">&quot;person&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, GeoUnit.KM);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小明附近的人：&quot;</span> + res.get(i).getMemberByString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小明和小红相距：3.9153 KM</span><br><span class="line">小明附近的人：xiaohong</span><br></pre></td></tr></table></figure><h3 id="9-5-应用场景"><a href="#9-5-应用场景" class="headerlink" title="9.5-应用场景"></a>9.5-应用场景</h3><p>Redis 中的 GEO 经典使用场景如下：</p><ol><li>查询附近的人、附近的地点等；</li><li>计算相关的距离信息。</li></ol><h2 id="10-游标迭代器（过滤器）—Scan"><a href="#10-游标迭代器（过滤器）—Scan" class="headerlink" title="10-游标迭代器（过滤器）—Scan"></a>10-游标迭代器（过滤器）—Scan</h2><h3 id="10-1-为什么需要Scan？"><a href="#10-1-为什么需要Scan？" class="headerlink" title="10.1-为什么需要Scan？"></a>10.1-为什么需要Scan？</h3><p>在平时线上 Redis 维护工作中，有时候需要从 Redis 实例成千上万的 key 中找出特定前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问题，如何从海量的 key 中找出满足特定前缀的 key 列表来？</p><p>Redis 提供了一个简单暴力的指令 <code>keys</code> 用来列出所有满足特定正则字符串规则的 key。</p><p>但这个命令存在两个缺点：</p><ol><li>此命令没有分页功能，我们只能一次性查询出所有符合条件的 key 值，如果查询结果非常巨大，那么得到的输出信息也会非常多；</li><li>keys 命令是遍历查询，因此它的查询时间复杂度是 o(n)，所以数据量越大查询时间就越长。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set codehole1 a</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set codehole2 b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set codehole3 c</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set code1hole a</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set code2hole b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set code3hole b</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;codehole1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;code3hole&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;codehole3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;code2hole&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;codehole2&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;code1hole&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys codehole*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;codehole1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;codehole3&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;codehole2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys code*hole</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;code3hole&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;code2hole&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;code1hole&quot;</span></span><br></pre></td></tr></table></figure><p>这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个<strong>缺点</strong>。</p><ol><li>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，当你看到满屏的字符串刷的没有尽头时，你就知道难受了。</li><li>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</li></ol><p>面对这两个显著的缺点该怎么办呢？</p><p>Redis 为了解决这个问题，它在 2.8 版本中加入了大海捞针的指令——<code>scan</code>。<code>scan</code> 相比 <code>keys</code> 具备有以下特点:</p><ol><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;</li><li>提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的结果可多可少;</li><li>同 keys 一样，它也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li><li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li><li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</li></ol><h3 id="10-2-Scan-命令使用"><a href="#10-2-Scan-命令使用" class="headerlink" title="10.2-Scan 命令使用"></a>10.2-Scan 命令使用</h3><p>我们先来模拟海量数据，使用 Pipeline 添加 10w 条数据，Java 代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加 10w 条数据</span></span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Jedis jedis = JedisUtils.getJedis();</span><br><span class="line">        Pipeline pipe = jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100001</span>; i++) &#123;</span><br><span class="line">            pipe.set(<span class="string">&quot;user_token_&quot;</span> + i, <span class="string">&quot;id&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        pipe.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据插入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来查询用户 id 为 9999* 的数据，Scan 命令使用如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match user_token_9999* count 10000</span><br><span class="line">1) &quot;127064&quot;</span><br><span class="line">2) 1) &quot;user_token_99997&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 127064 match user_token_9999* count 10000</span><br><span class="line">1) &quot;1740&quot;</span><br><span class="line">2) 1) &quot;user_token_9999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 1740 match user_token_9999* count 10000</span><br><span class="line">1) &quot;21298&quot;</span><br><span class="line">2) 1) &quot;user_token_99996&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 21298 match user_token_9999* count 10000</span><br><span class="line">1) &quot;65382&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 65382 match user_token_9999* count 10000</span><br><span class="line">1) &quot;78081&quot;</span><br><span class="line">2) 1) &quot;user_token_99998&quot;</span><br><span class="line">   2) &quot;user_token_99992&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 78081 match user_token_9999* count 10000</span><br><span class="line">1) &quot;3993&quot;</span><br><span class="line">2) 1) &quot;user_token_99994&quot;</span><br><span class="line">   2) &quot;user_token_99993&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3993 match user_token_9999* count 10000</span><br><span class="line">1) &quot;13773&quot;</span><br><span class="line">2) 1) &quot;user_token_99995&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 13773 match user_token_9999* count 10000</span><br><span class="line">1) &quot;47923&quot;</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; scan 47923 match user_token_9999* count 10000</span><br><span class="line">1) &quot;59751&quot;</span><br><span class="line">2) 1) &quot;user_token_99990&quot;</span><br><span class="line">   2) &quot;user_token_99991&quot;</span><br><span class="line">   3) &quot;user_token_99999&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 59751 match user_token_9999* count 10000</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) (empty list or set)</span><br></pre></td></tr></table></figure><p>从以上的执行结果，我们看出两个问题：</p><ol><li>查询的结果为空，但游标值不为 0，表示遍历还没结束；</li><li>设置的是 count 10000，但每次返回的数量都不是 10000，且不固定，这是因为 count 只是限定服务器单次遍历的字典槽位数量（约等于），而不是规定返回结果的 count 值。</li></ol><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scan cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>cursor：光标位置，整数值，从 0 开始，到 0 结束，查询结果是空，但游标值不为 0，表示遍历还没结束；</li><li>match pattern：正则匹配字段；</li><li>count：限定服务器单次遍历的字典槽位数量（约等于），只是对增量式迭代命令的一种提示（hint），并不是查询结果返回的最大数量，它的默认值是 10。</li></ul><h3 id="10-3-代码实战"><a href="#10-3-代码实战" class="headerlink" title="10.3-代码实战"></a>10.3-代码实战</h3><p>本文我们使用 Java 代码来实现 Scan 的查询功能，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanParams;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 定义 match 和 count 参数</span></span><br><span class="line">        ScanParams params = <span class="keyword">new</span> ScanParams();</span><br><span class="line">        params.count(<span class="number">10000</span>);</span><br><span class="line">        params.match(<span class="string">&quot;user_token_9999*&quot;</span>);</span><br><span class="line">        <span class="comment">// 游标</span></span><br><span class="line">        String cursor = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ScanResult&lt;String&gt; res = jedis.scan(cursor, params);</span><br><span class="line">            <span class="keyword">if</span> (res.getCursor().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 表示最后一条</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = res.getCursor(); <span class="comment">// 设置游标</span></span><br><span class="line">            <span class="keyword">for</span> (String item : res.getResult()) &#123;</span><br><span class="line">                <span class="comment">// 打印查询结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;查询结果：&quot;</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询结果：user_token_99997</span><br><span class="line">查询结果：user_token_9999</span><br><span class="line">查询结果：user_token_99996</span><br><span class="line">查询结果：user_token_99998</span><br><span class="line">查询结果：user_token_99992</span><br><span class="line">查询结果：user_token_99994</span><br><span class="line">查询结果：user_token_99993</span><br><span class="line">查询结果：user_token_99995</span><br><span class="line">查询结果：user_token_99990</span><br><span class="line">查询结果：user_token_99991</span><br><span class="line">查询结果：user_token_99999</span><br></pre></td></tr></table></figure><h3 id="10-4-Scan-相关命令"><a href="#10-4-Scan-相关命令" class="headerlink" title="10.4-Scan 相关命令"></a>10.4-Scan 相关命令</h3><p>Scan 是一个系列指令，除了 Scan 之外，还有以下 3 个命令：</p><ol><li>HScan 遍历字典游标迭代器</li><li>SScan 遍历集合的游标迭代器</li><li>ZScan 遍历有序集合的游标迭代器</li></ol><p>来看这些命令的具体使用。</p><h4 id="1-HScan-使用"><a href="#1-HScan-使用" class="headerlink" title="1. HScan 使用"></a><strong>1. HScan 使用</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hscan myhash 0 match k2* count 10</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;k2&quot;</span><br><span class="line">   2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hscan key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h4 id="2-SScan-使用"><a href="#2-SScan-使用" class="headerlink" title="2.SScan 使用"></a><strong>2.SScan 使用</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sscan myset 0 match v2* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sscan key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h4 id="3-ZScan-使用"><a href="#3-ZScan-使用" class="headerlink" title="3. ZScan 使用"></a><strong>3. ZScan 使用</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscan zset 0 match red* count 20</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;redis&quot;</span><br><span class="line">   2) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zscan key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><h4 id="5-Scan-说明"><a href="#5-Scan-说明" class="headerlink" title="5. Scan 说明"></a>5. Scan 说明</h4><p>官方对 Scan 命令的描述信息如下。</p><p><strong>Scan guarantees</strong></p><blockquote><p>The SCAN command, and the other commands in the SCAN family, are able to provide to the user a set of guarantees associated to full iterations.</p><ul><li>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point SCANreturned it to the user.</li><li>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, SCAN ensures that this element will never be returned.</li></ul><p>However because SCAN has very little state associated (just the cursor) it has the following drawbacks:</p><ul><li>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</li><li>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</li></ul></blockquote><p>官方文档地址：</p><blockquote><p><a target="_blank" rel="noopener" href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p></blockquote><p>翻译为中文的含义是：Scan 及它的相关命令可以保证以下查询规则。</p><ul><li>它可以完整返回开始到结束检索集合中出现的所有元素，也就是在整个查询过程中如果这些元素没有被删除，且符合检索条件，则一定会被查询出来；</li><li>它可以保证不会查询出，在开始检索之前删除的那些元素。</li></ul><p>然后，Scan 命令包含以下缺点：</p><ul><li>一个元素可能被返回多次，需要客户端来实现去重；</li><li>在迭代过程中如果有元素被修改，那么修改的元素能不能被遍历到不确定。</li></ul><h3 id="10-5-小结"><a href="#10-5-小结" class="headerlink" title="10.5-小结"></a>10.5-小结</h3><p>通过本文我们可以知道 Scan 包含以下四个指令：</p><ol><li>Scan：用于检索当前数据库中所有数据；</li><li>HScan：用于检索哈希类型的数据；</li><li>SScan：用于检索集合类型中的数据；</li><li>ZScan：由于检索有序集合中的数据。</li></ol><p>Scan 具备以下几个特点：</p><ol><li>Scan 可以实现 keys 的匹配功能；</li><li>Scan 是通过游标进行查询的不会导致 Redis 假死；</li><li>Scan 提供了 count 参数，可以规定遍历的数量；</li><li>Scan 会把游标返回给客户端，用户客户端继续遍历查询；</li><li>Scan 返回的结果可能会有重复数据，需要客户端去重；</li><li>单次返回空值且游标不为 0，说明遍历还没结束；</li><li>Scan 可以保证在开始检索之前，被删除的元素一定不会被查询出来；</li><li>在迭代过程中如果有元素被修改， Scan 不保证能查询出相关的元素。</li></ol><h2 id="11-优秀的基数统计算法—HyperLogLog"><a href="#11-优秀的基数统计算法—HyperLogLog" class="headerlink" title="11-优秀的基数统计算法—HyperLogLog"></a>11-优秀的基数统计算法—HyperLogLog</h2><h3 id="11-1-为什么要使用-HyperLogLog？"><a href="#11-1-为什么要使用-HyperLogLog？" class="headerlink" title="11.1-为什么要使用 HyperLogLog？"></a>11.1-为什么要使用 HyperLogLog？</h3><p>在我们实际开发的过程中，可能会遇到这样一个问题，当我们需要统计一个大型网站的独立访问次数时，该用什么的类型来统计？</p><p>如果我们使用 Redis 中的集合来统计，当它每天有数千万级别的访问时，将会是一个巨大的问题。因为这些访问量不能被清空，我们运营人员可能会随时查看这些信息，那么随着时间的推移，这些统计数据所占用的空间会越来越大，逐渐超出我们能承载最大空间。</p><p>例如，我们用 IP 来作为独立访问的判断依据，那么我们就要把每个独立 IP 进行存储，以 IP4 来计算，IP4 最多需要 15 个字节来存储信息，例如：110.110.110.110。当有一千万个独立 IP 时，所占用的空间就是 15 bit*10000000 约定于 143MB，但这只是一个页面的统计信息，假如我们有 1 万个这样的页面，那我们就需要 1T 以上的空间来存储这些数据，而且随着 IP6 的普及，这个存储数字会越来越大，那我们就不能用集合的方式来存储了，这个时候我们需要开发新的数据类型 HyperLogLog 来做这件事了。</p><h3 id="11-2-HyperLogLog-介绍"><a href="#11-2-HyperLogLog-介绍" class="headerlink" title="11.2-HyperLogLog 介绍"></a>11.2-HyperLogLog 介绍</h3><p>HyperLogLog（下文简称为 HLL）是 Redis 2.8.9 版本添加的数据结构，它用于高性能的基数（去重）统计功能，它的缺点就是存在极低的误差率。</p><p>HLL 具有以下几个特点：</p><ul><li>能够使用极少的内存来统计巨量的数据，它只需要 12K 空间就能统计 2^64 的数据；</li><li>统计存在一定的误差，误差率整体较低，标准误差为 0.81%；</li><li>误差可以被设置辅助计算因子进行降低。</li></ul><p>HyperLogLog算法是一种非常巧妙的近似统计海量去重元素数量的算法。它内部维护了 16384 个桶（bucket）来记录各自桶的元素数量。当一个元素到来时，它会散列到其中一个桶，以一定的概率影响这个桶的计数值。因为是概率算法，所以单个桶的计数值并不准确，但是将所有的桶计数值进行调合均值累加起来，结果就会非常接近真实的计数值。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/HyperLogLog.png"></p><h3 id="11-3-基础使用"><a href="#11-3-基础使用" class="headerlink" title="11.3-基础使用"></a>11.3-基础使用</h3><p>HLL 的命令只有 3 个，但都非常的实用，下面分别来看。</p><h4 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a><strong>1. 添加元素</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure><p>此命令支持添加一个或多个元素至 HLL 结构中。</p><h4 id="2-统计不重复的元素"><a href="#2-统计不重复的元素" class="headerlink" title="2. 统计不重复的元素"></a><strong>2. 统计不重复的元素</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd key &quot;redis&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount key</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>从 pfcount 的结果可以看出，在 HLL 结构中键值为 key 的元素，有 2 个不重复的值：redis 和 sql，可以看出结果还是挺准的。</p><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure><p>此命令支持统计一个或多个 HLL 结构。</p><h4 id="3-合并一个或多个-HLL-至新结构"><a href="#3-合并一个或多个-HLL-至新结构" class="headerlink" title="3. 合并一个或多个 HLL 至新结构"></a><strong>3. 合并一个或多个 HLL 至新结构</strong></h4><p>新增 k 和 k2 合并至新结构 k3 中，代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd k &quot;java&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd k2 &quot;redis&quot; &quot;sql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge k3 k k2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount k3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><p><strong>pfmerge 使用场景</strong></p><p>当我们需要合并两个或多个同类页面的访问数据时，我们可以使用 pfmerge 来操作。</p><h3 id="11-4-代码实战"><a href="#11-4-代码实战" class="headerlink" title="11.4-代码实战"></a>11.4-代码实战</h3><p>接下来我们使用 Java 代码来实现 HLL 的三个基础功能，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HyperLogLogExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        jedis.pfadd(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">// 统计元素</span></span><br><span class="line">        <span class="keyword">long</span> count = jedis.pfcount(<span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印统计元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k：&quot;</span> + count);</span><br><span class="line">        <span class="comment">// 合并 HLL</span></span><br><span class="line">        jedis.pfmerge(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印新 HLL</span></span><br><span class="line">        System.out.println(<span class="string">&quot;k2：&quot;</span> + jedis.pfcount(<span class="string">&quot;k2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k：2</span><br><span class="line">k2：2</span><br></pre></td></tr></table></figure><h3 id="11-5-HLL-算法原理"><a href="#11-5-HLL-算法原理" class="headerlink" title="11.5-HLL 算法原理"></a>11.5-HLL 算法原理</h3><p>HyperLogLog 算法来源于论文 <a target="_blank" rel="noopener" href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog the analysis of a near-optimal cardinality estimation algorithm</em></a>，想要了解 HLL 的原理，先要从伯努利试验说起，伯努利实验说的是抛硬币的事。一次伯努利实验相当于抛硬币，不管抛多少次只要出现一个正面，就称为一次伯努利实验。</p><p>我们用 k 来表示每次抛硬币的次数，n 表示第几次抛的硬币，用 k_max 来表示抛硬币的最高次数，最终根据估算发现 n 和 k_max 存在的关系是 n=2^(k_max)，但同时我们也发现了另一个问题当试验次数很小的时候，这种估算方法的误差会很大，例如我们进行以下 3 次实验：</p><ul><li>第 1 次试验：抛 3 次出现正面，此时 k=3，n=1；</li><li>第 2 次试验：抛 2 次出现正面，此时 k=2，n=2；</li><li>第 3 次试验：抛 6 次出现正面，此时 k=6，n=3。</li></ul><p>对于这三组实验来说，k_max=6，n=3，但放入估算公式明显 3≠2^6。为了解决这个问题 HLL 引入了分桶算法和调和平均数来使这个算法更接近真实情况。</p><p>分桶算法是指把原来的数据平均分为 m 份，在每段中求平均数在乘以 m，以此来消减因偶然性带来的误差，提高预估的准确性，简单来说就是把一份数据分为多份，把一轮计算，分为多轮计算。</p><p>而调和平均数指的是使用平均数的优化算法，而非直接使用平均数。</p><blockquote><p>例如小明的月工资是 1000 元，而小王的月工资是 100000 元，如果直接取平均数，那小明的平均工资就变成了 (1000+100000)/2=50500‬ 元，这显然是不准确的，而使用调和平均数算法计算的结果是 2/(1/1000+1/100000)≈1998 元，显然此算法更符合实际平均数。</p></blockquote><p>所以综合以上情况，在 Redis 中使用 HLL 插入数据，相当于把存储的值经过 hash 之后，再将 hash 值转换为二进制，存入到不同的桶中，这样就可以用很小的空间存储很多的数据，统计时再去相应的位置进行对比很快就能得出结论，这就是 HLL 算法的基本原理，想要更深入的了解算法及其推理过程，可以看去原版的论文，</p><p>链接地址-论文 <a target="_blank" rel="noopener" href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"><em>HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm</em></a>。</p><h3 id="11-6-小结"><a href="#11-6-小结" class="headerlink" title="11.6-小结"></a>11.6-小结</h3><p>当需要做大量数据统计时，普通的集合类型已经不能满足我们的需求了，这个时候我们可以借助 Redis 2.8.9 中提供的 HyperLogLog 来统计，它的优点是只需要使用 12k 的空间就能统计 2^64 的数据，但它的缺点是存在 0.81% 的误差，HyperLogLog 提供了三个操作方法 pfadd 添加元素、pfcount 统计元素和 pfmerge 合并元素。</p><h2 id="12-Redis消息队列"><a href="#12-Redis消息队列" class="headerlink" title="12-Redis消息队列"></a>12-Redis消息队列</h2><h3 id="12-1-发布订阅模式"><a href="#12-1-发布订阅模式" class="headerlink" title="12.1-发布订阅模式"></a>12.1-发布订阅模式</h3><p>在 Redis 中提供了专门的类型：Publisher（发布者）和 Subscriber（订阅者）来实现消息队列。</p><p>在文章开始之前，先来介绍消息队列中有几个基础概念，以便大家更好的理解本文的内容。</p><p>首先，发布消息的叫做发布方或发布者，也就是消息的生产者，而接收消息的叫做消息的订阅方或订阅者，也就是消费者，用来处理生产者发布的消息。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85.png"></p><p>除了发布和和订阅者，在消息队列中还有一个重要的概念：channel 意为频道或通道，可以理解为某个消息队列的名称，首先消费者先要订阅某个 channel，然后当生产者把消息发送到这个 channel 中时，消费者就可以正常接收到消息了，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png"></p><h4 id="1-普通订阅与发布"><a href="#1-普通订阅与发布" class="headerlink" title="1. 普通订阅与发布"></a>1. 普通订阅与发布</h4><p>消息队列有两个重要的角色，一个是发送者，另一个就是订阅者，对应的命令如下：</p><ul><li>发布消息：publish channel “message”</li><li>订阅消息：subscribe channel</li></ul><p>下面我们来看具体的命令实现。</p><h5 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a><strong>订阅消息</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel #订阅消息channel</span><br><span class="line">Reading messages...</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscribe channel [channel ...]</span><br></pre></td></tr></table></figure><p>此命令支持订阅一个或多个频道的命令，也就是说一个订阅者可以订阅多个频道。例如，某个客户端订阅了两个频道 channel 和 channel2，当两个发布者分别推送消息后，订阅者的信息输出如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel channel2 #订阅 channel 和 channel2</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel2&quot;</span><br><span class="line">3) (integer) 2</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel&quot; # 收到 channel 消息</span><br><span class="line">3) &quot;message 1.&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel2&quot; # 收到 channel2 消息</span><br><span class="line">3) &quot;message 2.&quot;</span><br></pre></td></tr></table></figure><p>可以看出此订阅者可以收到来自两个频道的消息推送。</p><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a><strong>发送消息</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel &quot;hello,redis.&quot; #发布消息</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure><p>最后的返回值表示成功发送给几个订阅方，1 表示成功发给了一个订阅者，这个数字可以是 0~n，这是由订阅者的数量决定的。</p><p>例如，当有两个订阅者时，推送的结果为 2，如下代码所示。</p><p>订阅者一：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>订阅者二：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>发送消息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel &quot;message&quot;</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>可以看出，此消息已成功发给两个订阅者，结果也变成 2 了。</p><h4 id="2-主题订阅"><a href="#2-主题订阅" class="headerlink" title="2. 主题订阅"></a>2. 主题订阅</h4><p>上面介绍了普通的订阅与发布模式，但如果我要订阅某一个类型的消息就不适用了，例如我要订阅日志类的消息队列，它们的命名都是 logXXX，这个时候就需要使用 Redis 提供的另一个功能 Pattern Subscribe 主题订阅，这种方式可以使用 <code>*</code> 来匹配多个频道，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E4%B8%BB%E9%A2%98%E8%AE%A2%E9%98%85.png"></p><p>主题模式的具体实现代码如下，订阅者：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe log_* #主题订阅 log_*</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_user&quot; #接收到频道 log_user 的消息推送</span><br><span class="line">4) &quot;user message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_sys&quot; #接收到频道 log_sys 的消息推送</span><br><span class="line">4) &quot;sys message.&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;log_*&quot;</span><br><span class="line">3) &quot;log_db&quot; #接收到频道 log_db 的消息推送</span><br><span class="line">4) &quot;db message&quot;</span><br></pre></td></tr></table></figure><p>从上面的运行结果，可以看出使用命令 <code>psubscribe log_*</code> 可以接收到所有频道包含 log_XXX 的消息。</p><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psubscribe pattern [pattern ...]</span><br></pre></td></tr></table></figure><p>生产者的代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish log_user &quot;user message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_sys &quot;sys message.&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish log_db &quot;db message&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h4 id="3-代码实战-1"><a href="#3-代码实战-1" class="headerlink" title="3. 代码实战"></a>3. 代码实战</h4><p>下面我们使用 Jedis 实现普通的发布订阅模式和主题订阅的功能。</p><h5 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a><strong>普通模式</strong></h5><p>消费者代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 接收并处理消息</span></span><br><span class="line">    jedis.subscribe(<span class="keyword">new</span> JedisPubSub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 推送消息</span></span><br><span class="line">    jedis.publish(<span class="string">&quot;channel&quot;</span>, <span class="string">&quot;Hello, channel.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布者和订阅者模式运行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新线程作为消费者</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; consumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure><h5 id="主题订阅模式"><a href="#主题订阅模式" class="headerlink" title="主题订阅模式"></a><strong>主题订阅模式</strong></h5><p>主题订阅模式的生产者的代码是一样，只有消费者的代码是不同的，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题订阅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    jedis.psubscribe(<span class="keyword">new</span> JedisPubSub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 接收消息，业务处理</span></span><br><span class="line">            System.out.println(pattern + <span class="string">&quot; 主题 | 频道 &quot;</span> + channel + <span class="string">&quot; 收到消息：&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;channel*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题模式运行代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 主题订阅</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; pConsumer()).start();</span><br><span class="line">    <span class="comment">// 暂停 0.5s 等待消费者初始化</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 生产者发送消息</span></span><br><span class="line">    producer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel* 主题 | 频道 channel 收到消息：Hello, channel.</span><br></pre></td></tr></table></figure><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h4><p>发布订阅模式存在以下两个缺点：</p><ol><li>无法持久化保存消息，如果 Redis 服务器宕机或重启，那么所有的消息将会丢失；</li><li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li></ol><p>然而这些缺点在 Redis 5.0 添加了 Stream 类型之后会被彻底的解决。</p><p>除了以上缺点外，发布订阅模式还有另一个需要注意问题：当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</p><h3 id="12-2-消息队列的其他实现方式"><a href="#12-2-消息队列的其他实现方式" class="headerlink" title="12.2-消息队列的其他实现方式"></a>12.2-消息队列的其他实现方式</h3><p>在 Redis 5.0 之前消息队列的实现方式有很多种，比较常见的除了我们上文介绍的发布订阅模式，还有两种：List 和 ZSet 的实现方式。</p><p>List 和 ZSet 的方式解决了发布订阅模式不能持久化的问题，但这两种方式也有自己的缺点，接下来我们一起来了解一下，先从 List 实现消息队列的方式说起。</p><h4 id="1-List-版消息队列"><a href="#1-List-版消息队列" class="headerlink" title="1. List 版消息队列"></a>1. List 版消息队列</h4><p>List 方式是实现消息队列最简单和最直接的方式，它主要是通过 lpush 和 rpop 存入和读取实现消息队列的，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/List%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png"></p><p>List 使用命令的方式实现消息队列：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mq &quot;hello&quot; #推送消息 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush mq &quot;msg&quot; #推送消息 msg</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 hello</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop mq #接收到消息 msg</span><br><span class="line">&quot;mq&quot;</span><br></pre></td></tr></table></figure><p>其中，mq 就相当于频道名称 channel，而 lpush 用于生产消息， rpop 拉取消息。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h5><p>接下来我们用 Java 代码的方式来实现 List 形式的消息队列，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMQExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息</span></span><br><span class="line">            String msg = jedis.rpop(<span class="string">&quot;mq&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收到了消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收到消息：Hello, List.</span><br></pre></td></tr></table></figure><p>我们使用无限循环来获取队列中的数据，这样就可以实时地获取相关信息了，但这样会带来另一个新的问题，当队列中如果没有数据的情况下，无限循环会一直消耗系统的资源，这时候我们可以使用 brpop 替代 rpop 来完美解决这个问题。</p><p>b 是 blocking 的缩写，表示阻塞读，也就是当队列没有数据时，它会进入休眠状态，当有数据进入队列之后，它才会“苏醒”过来执行读取任务，这样就可以解决 while 循环一直执行消耗系统资源的问题了，改良版代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListMQExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 消费者 改良版</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; bConsumer()).start();</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;Hello, List.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 2.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;mq&quot;</span>, <span class="string">&quot;message 3.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者（阻塞版）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞读</span></span><br><span class="line">            <span class="keyword">for</span> (String item : jedis.brpop(<span class="number">0</span>,<span class="string">&quot;mq&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 读取到相关数据，进行业务处理</span></span><br><span class="line">                System.out.println(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，brpop() 方法的第一个参数是设置超时时间的，设置 0 表示一直阻塞。</p><h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h5><p>List 优点：</p><ul><li>消息可以被持久化，借助 Redis 本身的持久化（AOF、RDB 或者是混合持久化），可以有效的保存数据；</li><li>消费者可以积压消息，不会因为客户端的消息过多而被强行断开。</li></ul><p>List 缺点：</p><ul><li>消息不能被重复消费，一个消息消费完就会被删除；</li><li>没有主题订阅的功能。</li></ul><h4 id="2-ZSet-版消息队列"><a href="#2-ZSet-版消息队列" class="headerlink" title="2. ZSet 版消息队列"></a>2. ZSet 版消息队列</h4><p>ZSet 版消息队列相比于之前的两种方式，List 和发布订阅方式在实现上要复杂一些，但 ZSet 因为多了一个 score（分值）属性，从而使它具备更多的功能，例如我们可以用它来存储时间戳，以此来实现延迟消息队列等。</p><p>它的实现思路和 List 相同也是利用 zadd 和 zrangebyscore 来实现存入和读取，这里就不重复叙述了，读者可以根据 List 的实现方式来实践一下，看能不能实现相应的功能，如果写不出来也没关系，本课程的后面章节，介绍延迟队列的时候会用 ZSet 来实现。</p><h5 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h5><p>ZSet 优点：</p><ul><li>支持消息持久化；</li><li>相比于 List 查询更方便，ZSet 可以利用 score 属性很方便的完成检索，而 List 则需要遍历整个元素才能检索到某个值。</li></ul><p>ZSet 缺点：</p><ul><li>ZSet 不能存储相同元素的值，也就是如果有消息是重复的，那么只能插入一条信息在有序集合中；</li><li>ZSet 是根据 score 值排序的，不能像 List 一样，按照插入顺序来排序；</li><li>ZSet 没有向 List 的 brpop 那样的阻塞弹出的功能。</li></ul><h3 id="12-3-消息队列终极解决方案—Stream"><a href="#12-3-消息队列终极解决方案—Stream" class="headerlink" title="12.3-消息队列终极解决方案—Stream"></a>12.3-消息队列终极解决方案—Stream</h3><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式 PubSub，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>列表实现消息队列的方式不能重复消费，一个消息消费完就会被删除；</li><li>有序集合消息队列的实现方式不能存储相同 value 的消息，并且不能阻塞读取消息。</li></ul><p>并且以上三种方式在实现消息队列时，只能存储单 value 值，也就是如果你要存储一个对象的情况下，必须先序列化成 JSON 字符串，在读取之后还要反序列化成对象才行，这也给用户的使用带来的不便，基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它借鉴了 Kafka 的设计思路，它支持消息的持久化和消息轨迹的消费，支持 ack 确认消息的模式，让消息队列更加的稳定和可靠。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Stream%E7%BB%93%E6%9E%84.png"></p><p>Redis Stream 的结构如上图所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。消息是持久化的，Redis 重启后，内容还在。</p><p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用<code>xadd</code>指令追加消息时自动创建。</p><p>每个 Stream 都可以挂多个消费组，每个消费组会有个游标<code>last_delivered_id</code>在 Stream 数组之上往前移动，表示当前消费组已经消费到哪条消息了。每个消费组都有一个 Stream 内唯一的名称，消费组不会自动创建，它需要单独的指令<code>xgroup create</code>进行创建，需要指定从 Stream 的某个消息 ID 开始消费，这个 ID 用来初始化<code>last_delivered_id</code>变量。</p><p>每个消费组 (Consumer Group) 的状态都是独立的，相互不受影响。也就是说同一份 Stream 内部的消息会被每个消费组都消费到。</p><p>同一个消费组 (Consumer Group) 可以挂接多个消费者 (Consumer)，这些消费者之间是竞争关系，任意一个消费者读取了消息都会使游标<code>last_delivered_id</code>往前移动。每个消费者有一个组内唯一名称。</p><p>消费者 (Consumer) 内部会有个状态变量<code>pending_ids</code>，它记录了当前已经被客户端读取的消息，但是还没有 ack。如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack，它就开始减少。这个 pending_ids 变量在 Redis 官方被称之为<code>PEL</code>，也就是<code>Pending Entries List</code>，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</p><h4 id="1-消息-ID"><a href="#1-消息-ID" class="headerlink" title="1. 消息 ID"></a>1. <strong>消息 ID</strong></h4><p>消息 ID 的形式是<code>timestampInMillis-sequence</code>，例如<code>1527846880572-5</code>，它表示当前的消息在毫米时间戳<code>1527846880572</code>时产生，并且是该毫秒内产生的第 5 条消息。消息 ID 可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是<code>整数-整数</code>，而且必须是后面加入的消息的 ID 要大于前面的消息 ID。</p><h4 id="2-消息内容"><a href="#2-消息内容" class="headerlink" title="2. 消息内容"></a>2. <strong>消息内容</strong></h4><p>消息内容就是键值对，形如 hash 结构的键值对，这没什么特别之处。</p><h4 id="3-基础使用"><a href="#3-基础使用" class="headerlink" title="3. 基础使用"></a>3. 基础使用</h4><p>Stream 既然是一个数据类型，那么和其他数据类型相似，它也有一些自己的操作方法，例如：</p><ul><li>xadd 添加消息；</li><li>xlen 查询消息长度；</li><li>xdel 根据消息 ID 删除消息；</li><li>del 删除整个 Stream；</li><li>xrange 读取区间消息</li><li>xread 读取某个消息之后的消息。</li></ul><p>具体使用如下所述。</p><h5 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a><strong>添加消息</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis age 10</span><br><span class="line">&quot;1580880750844-0&quot; #结果返回的是消息 id</span><br></pre></td></tr></table></figure><p>其中 <code>*</code> 表示使用 Redis 的规则：时间戳 + 序号的方式自动生成 ID，用户也可以自己指定 ID。</p><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xadd key ID field string [field string ...]</span><br></pre></td></tr></table></figure><h5 id="查询消息的长度"><a href="#查询消息的长度" class="headerlink" title="查询消息的长度"></a><strong>查询消息的长度</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xlen key</span><br></pre></td></tr></table></figure><h5 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a><strong>删除消息</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd key * name redis</span><br><span class="line">&quot;1580881585129-0&quot; #消息 ID</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xdel key 1580881585129-0 #删除消息，根据 ID</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdel key ID [ID ...]</span><br></pre></td></tr></table></figure><p>此命令支持删除一条或多条消息，根据消息 ID。</p><h5 id="删除整个-Stream"><a href="#删除整个-Stream" class="headerlink" title="删除整个 Stream"></a><strong>删除整个 Stream</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key #删除整个 Stream</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xlen key</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del key [key ...]</span><br></pre></td></tr></table></figure><p>此命令支持删除一个或多个 Stream。</p><h5 id="查询区间消息"><a href="#查询区间消息" class="headerlink" title="查询区间消息"></a><strong>查询区间消息</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xrange mq - +</span><br><span class="line">1) 1) &quot;1580882060464-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;redis&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;10&quot;</span><br><span class="line">2) 1) &quot;1580882071524-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;java&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>其中：<code>-</code> 表示第一条消息，<code>+</code> 表示最后一条消息。</p><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xrange key start end [COUNT count]</span><br></pre></td></tr></table></figure><h5 id="查询某个消息之后的消息"><a href="#查询某个消息之后的消息" class="headerlink" title="查询某个消息之后的消息"></a><strong>查询某个消息之后的消息</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 streams mq 1580882060464-0</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580882071524-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;java&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>在名称为 mq 的 Stream 中，从消息 ID 为 1580882060464-0 的，往后查询一条消息。</p><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xread [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><p>此命令提供了阻塞读的参数 block，我们可以使用它读取从当前数据以后新增数据，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br></pre></td></tr></table></figure><p>其中 <code>block 0</code> 表示一直阻塞，<code>$</code> 表示从最后开始读取，这个时候新开一个命令行插入一条数据，此命令展示的结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd mq * name sql age 20 #新窗口添加数据</span><br><span class="line">&quot;1580890737890-0&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">阻塞读取到的新数据</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 block 0 streams mq $</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580890737890-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;sql&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">(36.37s)</span><br></pre></td></tr></table></figure><h4 id="4-基础版消息队列"><a href="#4-基础版消息队列" class="headerlink" title="4. 基础版消息队列"></a>4. 基础版消息队列</h4><p>使用 Stream 消费分组实现消息队列的功能和列表方式的消息队列比较相似，使用 xadd 命令和 xread 循环读取就可以实现基础版的消息队列，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; consumer()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 推送消息</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加消息</span></span><br><span class="line">        StreamEntryID id = jedis.xadd(<span class="string">&quot;mq&quot;</span>, <span class="keyword">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，new StreamEntryID().LAST_ENTRY 标识获取当前时间以后的新增消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(<span class="string">&quot;mq&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> StreamEntryID().LAST_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xread(<span class="number">1</span>, <span class="number">120</span> * <span class="number">1000</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID());</span><br><span class="line">                <span class="comment">// 使用 Gson 来打印 JSON 格式的消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内容：&quot;</span> + <span class="keyword">new</span> Gson().toJson(list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息添加成功 ID：1580895735148-0</span><br><span class="line">读取到消息 ID：1580895735148-0</span><br><span class="line">内容：&#123;&quot;name&quot;:&quot;redis&quot;,&quot;age&quot;:&quot;10&quot;&#125;</span><br></pre></td></tr></table></figure><p>以上代码需要特殊说明的是，我们使用 <code>new StreamEntryID().LAST_ENTRY</code> 来实现读取当前时间以后新增的消息，如果要从头读取历史消息把这行代码中的 <code>.LAST_ENTRY</code> 去掉即可。</p><p>还有一点需要注意，在 Jedis 框架中如果使用 jedis.xread() 方法来阻塞读取消息队列，第二个参数 long block 必须设置大于 0，如果设置小于 0，此阻塞条件就无效了，我查看了 jedis 的源码发现，它只有判断在大于 0 的时候才会设置阻塞属性，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (block &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    params[streamsIndex++] = Keyword.BLOCK.raw;</span><br><span class="line">    params[streamsIndex++] = Protocol.toByteArray(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 block 属性我们可以设置一个比较大的值来阻塞读取消息。</p><blockquote><p>所谓的阻塞读取消息指的是当队列中没有数据时会进入休眠模式，等有数据之后才会唤醒继续执行。</p></blockquote><h4 id="5-创建消费组"><a href="#5-创建消费组" class="headerlink" title="5. 创建消费组"></a>5. <strong>创建消费组</strong></h4><p>在开始使用消息分组之前，我们必须手动创建分组才行，以下是几个和 Stream 分组有关的命令，我们先来学习一下它的使用。</p><h5 id="消息分组命令"><a href="#消息分组命令" class="headerlink" title="消息分组命令"></a>消息分组命令</h5><h6 id="创建消费者群组"><a href="#创建消费者群组" class="headerlink" title="创建消费者群组"></a><strong>创建消费者群组</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create mq group1 0-0 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xgroup create stream-key group-key ID</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>mq 为 Stream 的 key；</li><li>group1 为分组的名称；</li><li>0-0 表示从第一条消息开始读取。</li></ul><p>如果要从当前最后一条消息向后读取，使用 <code>$</code> 即可，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create mq group2 $</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h6 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a><strong>读取消息</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 streams mq &gt;</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580959593553-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;redis&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;10&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xreadgroup group group-key consumer-key streams stream-key</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&gt;</code> 表示读取下一条消息；</li><li>group1 表示分组名称；</li><li>c1 表示 consumer（消费者）名称。</li></ul><p>xreadgroup 命令和 xread 使用类似，也可以设置阻塞读取，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c2 streams mq &gt;</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580959606181-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;java&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c2 streams mq &gt;</span><br><span class="line">(nil) #队列中的消息已经被读取完</span><br><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 block 0 streams mq &gt; #阻塞读取</span><br></pre></td></tr></table></figure><p>此时打开另一个命令行创建使用 xadd 添加一条消息，阻塞命令执行结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 c1 count 1 block 0 streams mq &gt;</span><br><span class="line">1) 1) &quot;mq&quot;</span><br><span class="line">   2) 1) 1) &quot;1580961475368-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;sql&quot;</span><br><span class="line">            3) &quot;age&quot;</span><br><span class="line">            4) &quot;20&quot;</span><br><span class="line">(86.14s)</span><br></pre></td></tr></table></figure><h6 id="消息消费确认"><a href="#消息消费确认" class="headerlink" title="消息消费确认"></a><strong>消息消费确认</strong></h6><p>接收到消息之后，我们要手动确认一下（ack），命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xack mq group1 1580959593553-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xack key group-key ID [ID ...]</span><br></pre></td></tr></table></figure><p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 ack 确认消息已经被消费完成，整个流程的执行如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B6%88%E8%B4%B9%E7%A1%AE%E8%AE%A4.png"></p><h6 id="查询未确认的消费队列"><a href="#查询未确认的消费队列" class="headerlink" title="查询未确认的消费队列"></a><strong>查询未确认的消费队列</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xpending mq group1</span><br><span class="line">1) (integer) 1 #未确认（ack）的消息数量为 1 条</span><br><span class="line">2) &quot;1580994063971-0&quot;</span><br><span class="line">3) &quot;1580994063971-0&quot;</span><br><span class="line">4) 1) 1) &quot;c1&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; xack  mq group1 1580994063971-0 #消费确认</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; xpending mq group1</span><br><span class="line">1) (integer) 0 #没有未确认的消息</span><br><span class="line">2) (nil)</span><br><span class="line">3) (nil)</span><br><span class="line">4) (nil)</span><br></pre></td></tr></table></figure><h5 id="xinfo-查询相关命令"><a href="#xinfo-查询相关命令" class="headerlink" title="xinfo 查询相关命令"></a><strong>xinfo 查询相关命令</strong></h5><h6 id="1-查询流信息"><a href="#1-查询流信息" class="headerlink" title="1. 查询流信息"></a><strong>1. 查询流信息</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo stream mq</span><br><span class="line"> 1) &quot;length&quot;</span><br><span class="line"> 2) (integer) 2 #队列中有两个消息</span><br><span class="line"> 3) &quot;radix-tree-keys&quot;</span><br><span class="line"> 4) (integer) 1</span><br><span class="line"> 5) &quot;radix-tree-nodes&quot;</span><br><span class="line"> 6) (integer) 2</span><br><span class="line"> 7) &quot;groups&quot;</span><br><span class="line"> 8) (integer) 1 #一个消费分组</span><br><span class="line"> 9) &quot;last-generated-id&quot;</span><br><span class="line">10) &quot;1580959606181-0&quot;</span><br><span class="line">11) &quot;first-entry&quot;</span><br><span class="line">12) 1) &quot;1580959593553-0&quot;</span><br><span class="line">    2) 1) &quot;name&quot;</span><br><span class="line">       2) &quot;redis&quot;</span><br><span class="line">       3) &quot;age&quot;</span><br><span class="line">       4) &quot;10&quot;</span><br><span class="line">13) &quot;last-entry&quot;</span><br><span class="line">14) 1) &quot;1580959606181-0&quot;</span><br><span class="line">    2) 1) &quot;name&quot;</span><br><span class="line">       2) &quot;java&quot;</span><br><span class="line">       3) &quot;age&quot;</span><br><span class="line">       4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xinfo stream stream-key</span><br></pre></td></tr></table></figure><h6 id="2-查询消费组消息"><a href="#2-查询消费组消息" class="headerlink" title="2. 查询消费组消息"></a><strong>2. 查询消费组消息</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo groups mq</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;group1&quot; #消息分组名称</span><br><span class="line">   3) &quot;consumers&quot;</span><br><span class="line">   4) (integer) 1 #一个消费者客户端</span><br><span class="line">   5) &quot;pending&quot;</span><br><span class="line">   6) (integer) 1 #一个未确认消息</span><br><span class="line">   7) &quot;last-delivered-id&quot;</span><br><span class="line">   8) &quot;1580959593553-0&quot; #读取的最后一条消息 ID</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xinfo groups stream-key</span><br></pre></td></tr></table></figure><h6 id="3-查看消费者组成员信息"><a href="#3-查看消费者组成员信息" class="headerlink" title="3. 查看消费者组成员信息"></a><strong>3. 查看消费者组成员信息</strong></h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xinfo consumers mq group1</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;c1&quot; #消费者名称</span><br><span class="line">   3) &quot;pending&quot;</span><br><span class="line">   4) (integer) 0 #未确认消息</span><br><span class="line">   5) &quot;idle&quot;</span><br><span class="line">   6) (integer) 481855</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xinfo consumers stream group-key</span><br></pre></td></tr></table></figure><h5 id="删除消费者"><a href="#删除消费者" class="headerlink" title="删除消费者"></a><strong>删除消费者</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup delconsumer mq group1 c1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xgroup delconsumer stream-key group-key consumer-key</span><br></pre></td></tr></table></figure><h5 id="删除消费组"><a href="#删除消费组" class="headerlink" title="删除消费组"></a><strong>删除消费组</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup destroy mq group1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>相关语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xgroup destroy stream-key group-key</span><br></pre></td></tr></table></figure><h4 id="6-进阶版消费队列"><a href="#6-进阶版消费队列" class="headerlink" title="6. 进阶版消费队列"></a>6. 进阶版消费队列</h4><p>接下来我们使用 Jedis 来实现 Stream 分组消息队列，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamGroupExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _STREAM_KEY = <span class="string">&quot;mq&quot;</span>; <span class="comment">// 流 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _GROUP_NAME = <span class="string">&quot;g1&quot;</span>; <span class="comment">// 分组名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _CONSUMER_NAME = <span class="string">&quot;c1&quot;</span>; <span class="comment">// 消费者 1 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _CONSUMER2_NAME = <span class="string">&quot;c2&quot;</span>; <span class="comment">// 消费者 2 的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        producer();</span><br><span class="line">        <span class="comment">// 创建消费组</span></span><br><span class="line">        createGroup(_STREAM_KEY, _GROUP_NAME);</span><br><span class="line">        <span class="comment">// 消费者 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; consumer()).start();</span><br><span class="line">        <span class="comment">// 消费者 2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; consumer2()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建消费分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stream    流 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 分组名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createGroup</span><span class="params">(String stream, String groupName)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = JedisUtils.getJedis();</span><br><span class="line">        jedis.xgroupCreate(stream, groupName, <span class="keyword">new</span> StreamEntryID(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 添加消息 1</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        StreamEntryID id = jedis.xadd(_STREAM_KEY, <span class="keyword">null</span>, map);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id);</span><br><span class="line">        <span class="comment">// 添加消息 2</span></span><br><span class="line">        Map&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        StreamEntryID id2 = jedis.xadd(_STREAM_KEY, <span class="keyword">null</span>, map2);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息添加成功 ID：&quot;</span> + id2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> StreamEntryID().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="keyword">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 1 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> Gson().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取消息</span></span><br><span class="line">            Map.Entry&lt;String, StreamEntryID&gt; entry = <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(_STREAM_KEY,</span><br><span class="line">                    <span class="keyword">new</span> StreamEntryID().UNRECEIVED_ENTRY);</span><br><span class="line">            <span class="comment">// 阻塞读取一条消息（最大阻塞时间120s）</span></span><br><span class="line">            List&lt;Map.Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; list = jedis.xreadGroup(_GROUP_NAME, _CONSUMER2_NAME, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">120</span> * <span class="number">1000</span>, <span class="keyword">true</span>, entry);</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取到消息</span></span><br><span class="line">                Map&lt;String, String&gt; content = list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getFields(); <span class="comment">// 消息内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer 2 读取到消息 ID：&quot;</span> + list.get(<span class="number">0</span>).getValue().get(<span class="number">0</span>).getID() +</span><br><span class="line">                        <span class="string">&quot; 内容：&quot;</span> + <span class="keyword">new</span> Gson().toJson(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息添加成功 ID：1580971482344-0</span><br><span class="line">消息添加成功 ID：1580971482415-0</span><br><span class="line">Consumer 1 读取到消息 ID：1580971482344-0 内容：&#123;&quot;data&quot;:&quot;redis&quot;&#125;</span><br><span class="line">Consumer 2 读取到消息 ID：1580971482415-0 内容：&#123;&quot;data&quot;:&quot;java&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中，jedis.xreadGroup() 方法的第五个参数 noAck 表示是否自动确认消息，如果设置 true 收到消息会自动确认（ack）消息，否则则需要手动确认。</p><blockquote><p>注意：Jedis 框架要使用最新版，低版本 block 设置大于 0 时，会有 bug 抛连接超时异常。</p></blockquote><p>可以看出，同一个分组内的多个 consumer 会读取到不同消息，不同的 consumer 不会读取到分组内的同一条消息。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/05/05/Redis%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://lemon-cs.github.io/2020/05/05/Redis%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05/07/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2021/12/a560e450dd631e8f.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一致性Hash算法</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/01/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"><img class="next-cover" src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java浅拷贝和深拷贝</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">Redis学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1-概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Redis%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1-Redis简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Redis%E7%89%B9%E6%80%A7"><span class="toc-text">1.2-Redis特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redis"><span class="toc-text">1.3-为什么使用Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%EF%BC%88%E7%BC%93%E5%AD%98%E5%BF%AB%E9%80%9F%E5%93%8D%E5%BA%94%EF%BC%89"><span class="toc-text">1. 性能（缓存快速响应）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%EF%BC%88%E5%87%8F%E5%B0%91%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="toc-text">2. 并发（减少了数据库请求）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis-%E8%80%8C%E4%B8%8D%E7%94%A8-map-guava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-text">1.4-为什么要用 redis 而不用 map&#x2F;guava 做缓存?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Redis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-text">1.5-Redis是如何执行的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 命令执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93"><span class="toc-text">2. 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2-Redis的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Redis%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">2.1-Redis的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81"><span class="toc-text">1. 多种数据类型支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84"><span class="toc-text">2. 功能完善</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-text">3. 高性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B9%BF%E6%B3%9B%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81"><span class="toc-text">4. 广泛的编程语言支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95"><span class="toc-text">5. 使用简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B4%BB%E8%B7%83%E6%80%A7%E9%AB%98-%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3%E5%BF%AB"><span class="toc-text">6. 活跃性高&#x2F;版本迭代快</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">7. I&#x2F;O 多路复用模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Redis-%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-text">2.2-Redis 发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Redis%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">2.3-Redis的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85"><span class="toc-text">1. 源码安装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E5%8C%85"><span class="toc-text">① 下载源码包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E8%A7%A3%E5%8E%8B%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-text">② 解压安装包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%88%87%E6%8D%A2%E5%88%B0-Redis-%E7%9B%AE%E5%BD%95"><span class="toc-text">③ 切换到 Redis 目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-text">④ 编译安装</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Docker-%E5%AE%89%E8%A3%85"><span class="toc-text">2. Docker 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%8B%89%E5%8F%96-Reids-%E9%95%9C%E5%83%8F"><span class="toc-text">① 拉取 Reids 镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E8%BF%90%E8%A1%8C-Redis-%E5%AE%B9%E5%99%A8"><span class="toc-text">② 运行 Redis 容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">③ 执行命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Redis%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2.4-Redis的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8-Redis"><span class="toc-text">1. 启动 Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C-Redis"><span class="toc-text">2. 使用可视化工具操作 Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-redis-cli-%E6%93%8D%E4%BD%9C-Redis"><span class="toc-text">3. 使用 redis-cli 操作 Redis</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3-Redis的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">3.1-字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. 字符串类型能做什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98"><span class="toc-text">页面数据缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%BB%9F%E8%AE%A1"><span class="toc-text">数字计算与统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-Session-%E4%BF%A1%E6%81%AF"><span class="toc-text">共享 Session 信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">2. 字符串如何使用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">1）命令行操作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-%E5%8D%95%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">① 单个键值对操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">获取键值对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%99%E5%85%83%E7%B4%A0%E8%BF%BD%E5%8A%A0%E5%80%BC"><span class="toc-text">给元素追加值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">查询字符串的长度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">② 多个键值对操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">创建一个或多个键值对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">查询一个或多个元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2-%E6%95%B0%E5%AD%97%E7%BB%9F%E8%AE%A1"><span class="toc-text">③ 数字统计</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%99%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%8A%A0-1"><span class="toc-text">给整数类型的值加 1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%99%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%87%8F-1"><span class="toc-text">给整数类型的值减 1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-key-%E5%87%8F%E5%8E%BB%E6%8C%87%E5%AE%9A%E7%9A%84%E5%80%BC"><span class="toc-text">根据 key 减去指定的值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-key-%E5%8A%A0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0%E5%80%BC"><span class="toc-text">根据 key 加指定的整数值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-key-%E5%8A%A0%E4%B8%8A%E6%8C%87%E5%AE%9A%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">根据 key 加上指定的浮点数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">2）代码操作方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">3. 代码实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">4. 字符串的内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1）源码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2）数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-int-%E7%B1%BB%E5%9E%8B"><span class="toc-text">① int 类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-embstr-%E7%B1%BB%E5%9E%8B"><span class="toc-text">② embstr 类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2-raw-%E7%B1%BB%E5%9E%8B"><span class="toc-text">③ raw 类型</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-44-%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">3）为什么是 44 字节？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9B%B4%E5%A4%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">5. 更多字符串操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%94%AE%E5%80%BC%E5%AF%B9%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">1) 键值对过期操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">添加键值对并设置过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-%E5%8D%95%E4%BD%8D-%E7%A7%92"><span class="toc-text">赋值字符串，并设置过期时间(单位&#x2F;秒)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-%E5%8D%95%E4%BD%8D-%E6%AF%AB%E7%A7%92"><span class="toc-text">赋值字符串，并设置过期时间(单位&#x2F;毫秒)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E8%BF%9B%E9%98%B6"><span class="toc-text">2) 字符串操作进阶</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">根据指定的范围截取字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B0%E5%80%BC%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%97%A7%E5%80%BC"><span class="toc-text">设置字符串新值并返回旧值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC-%E5%88%9B%E5%BB%BA-%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%BD%93-key-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6"><span class="toc-text">赋值(创建)键值对，当 key 不存在时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%94%AE%E5%80%BC%EF%BC%8C%E5%BD%93%E6%89%80%E6%9C%89%E9%94%AE%E5%80%BC%E9%83%BD%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6"><span class="toc-text">设置一个或多个键值，当所有键值都不存在时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E8%B5%8B%E5%80%BC"><span class="toc-text">截取字符串并赋值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AD%97%E5%85%B8%E7%B1%BB%E5%9E%8B%EF%BC%88Hash%EF%BC%89"><span class="toc-text">3.2-字典类型（Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">1. 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%8F%92%E5%85%A5%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1）插入单个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%BD%93%E6%9F%90%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%EF%BC%8C%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">2）当某键不存在时，插入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">3）查询单个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E5%88%A0%E9%99%A4-key-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">4）删除 key 中的一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89%E6%9F%90%E4%B8%AA%E6%95%B4%E6%95%B0%E5%80%BC%E7%B4%AF%E5%8A%A0%E8%AE%A1%E7%AE%97"><span class="toc-text">5）某个整数值累加计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">2. 代码实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-text">4. 哈希冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-text">5. 渐进式rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%89%A9%E5%AE%B9"><span class="toc-text">1) 扩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BC%A9%E5%AE%B9"><span class="toc-text">2) 缩容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%B5%81%E7%A8%8B"><span class="toc-text">3) 渐进式rehash流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6. 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9B%B4%E5%A4%9A%E5%AD%97%E5%85%B8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">7. 更多字典操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">插入一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0-1"><span class="toc-text">查询一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA-key-%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5"><span class="toc-text">查询某个 key 的所有字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA-key-%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC"><span class="toc-text">查询某个 key 的所有值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA-key-%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E5%92%8C%E5%80%BC"><span class="toc-text">查询某个 key 的所有字段和值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E6%B5%AE%E7%82%B9%E5%80%BC%E7%B4%AF%E5%8A%A0%E8%AE%A1%E7%AE%97"><span class="toc-text">某个浮点值累加计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">查询元素是否存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-text">查询元素个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-text">3.3-列表（List）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-1"><span class="toc-text">1. 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%99%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">给列表添加一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%99%E5%88%97%E8%A1%A8%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">给列表尾部添加一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">返回列表指定区间内的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">获取并删除列表的第一个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">获取并删除列表的最后一个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">根据下标获取对应的元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-1"><span class="toc-text">2. 代码实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">4. 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1) 添加功能源码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2) 删除功能源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-text">① 单一元素删除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-%E5%8C%BA%E9%97%B4%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4"><span class="toc-text">② 区间元素删除</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9B%B4%E5%A4%9A%E6%BA%90%E7%A0%81"><span class="toc-text">3) 更多源码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9B%B4%E5%A4%9A%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">6. 更多列表操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E6%9F%90%E5%80%BC%E4%B9%8B%E5%89%8D-%E4%B9%8B%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">在某值之前&#x2F;之后添加某个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0"><span class="toc-text">根据下标修改元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">根据下标删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%97%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">查询列表的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">删除指定个数的元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-Set"><span class="toc-text">3.4-集合类型 (Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-2"><span class="toc-text">1. 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">1）添加一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="toc-text">2）查询集合所有元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E7%9A%84%E6%88%90%E5%91%98%E6%95%B0%E9%87%8F"><span class="toc-text">3）查询集合的成员数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">4）查询集合中是否包含某个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%AD%E7%A7%BB%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88"><span class="toc-text">5）从一个集合中移动一个元素到另一个集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%89%E7%A7%BB%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">6）移除集合中一个或多个元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-2"><span class="toc-text">2. 代码实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">3. 内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-text">4. 源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-text">5. 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9B%B4%E5%A4%9A%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">6. 更多集合操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%B9%B6%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="toc-text">移除并返回集合中的一个随机元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8"><span class="toc-text">随机返回集合中指定数量的元素列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">返回一个集合或多个集合的交集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%8A%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86%E5%A4%8D%E5%88%B6%E5%88%B0%E6%96%B0%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-text">把集合的交集复制到新的集合中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86"><span class="toc-text">查询一个或多个集合的并集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86%E5%A4%8D%E5%88%B6%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-text">把一个或多个集合的并集复制到新集合中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E9%94%99%E9%9B%86"><span class="toc-text">查询一个或多个集合的错集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E9%94%99%E9%9B%86%E5%A4%8D%E5%88%B6%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88"><span class="toc-text">把一个或多个集合的错集复制到新集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-Sorted-Set"><span class="toc-text">3.5-有序集合类型 (Sorted Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-3"><span class="toc-text">1. 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0-1"><span class="toc-text">1）添加一个或多个元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8"><span class="toc-text">2）查询所有元素列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0-%E6%A0%B9%E6%8D%AE%E5%85%83%E7%B4%A0%E5%80%BC"><span class="toc-text">3）删除一个或多个元素(根据元素值)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84-score-%E5%80%BC"><span class="toc-text">4）查询某元素的 score 值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%EF%BC%89%E6%9F%A5%E8%AF%A2-score-%E5%8C%BA%E9%97%B4%E5%86%85%E5%85%83%E7%B4%A0"><span class="toc-text">5）查询 score 区间内元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%85%83%E7%B4%A0%E6%8E%92%E5%90%8D"><span class="toc-text">6）查询某元素排名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-3"><span class="toc-text">2. 代码实战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">3. 内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89ziplist"><span class="toc-text">1）ziplist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89skiplist"><span class="toc-text">2）skiplist</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">① 跳跃表实现原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%9F%E8%80%8C%E9%9D%9E%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-text">② 为什么是跳跃表？而非红黑树？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4. 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%9B%B4%E5%A4%9A%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">6. 更多有序集合操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E6%80%BB%E4%B8%AA%E6%95%B0"><span class="toc-text">查询有序集合的总个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-score-%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-text">查询 score 区间内的元素个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84-score-%E5%80%BC"><span class="toc-text">累加元素的 score 值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%85%83%E7%B4%A0%E5%80%92%E5%BA%8F%E6%8E%92%E5%90%8D"><span class="toc-text">查询某元素倒序排名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">根据排名删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-score-%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">删除 score 区间内的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%A4%E9%9B%86%E5%85%83%E7%B4%A0%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88"><span class="toc-text">复制交集元素到新集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%B9%B6%E9%9B%86%E5%85%83%E7%B4%A0%E5%88%B0%E6%96%B0%E9%9B%86%E5%90%88"><span class="toc-text">复制并集元素到新集合</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">4-Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-RDB"><span class="toc-text">4.1-RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%81%E4%B9%85%E5%8C%96%E8%A7%A6%E5%8F%91"><span class="toc-text">1. 持久化触发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">1）手动触发</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-save-%E5%91%BD%E4%BB%A4"><span class="toc-text">① save 命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-bgsave-%E5%91%BD%E4%BB%A4"><span class="toc-text">② bgsave 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">2）自动触发</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-save-m-n"><span class="toc-text">① save m n</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-flushall"><span class="toc-text">② flushall</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E8%A7%A6%E5%8F%91"><span class="toc-text">③ 主从同步触发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">2. 配置说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E6%9F%A5%E8%AF%A2"><span class="toc-text">3. 配置查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">4. 配置设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-RDB-%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D"><span class="toc-text">5. RDB 文件恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-RDB%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">6. RDB的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89RDB-%E4%BC%98%E7%82%B9"><span class="toc-text">1）RDB 优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89RDB-%E7%BC%BA%E7%82%B9"><span class="toc-text">2）RDB 缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%A6%81%E7%94%A8%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">7. 禁用持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-AOF"><span class="toc-text">4.2-AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%AE%BE%E7%BD%AE"><span class="toc-text">2. 持久化查询和设置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%9F%A5%E8%AF%A2-AOF-%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81"><span class="toc-text">1）查询 AOF 启动状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%BC%80%E5%90%AF-AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2）开启 AOF 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8-AOF"><span class="toc-text">① 命令行启动 AOF</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8-AOF"><span class="toc-text">② 配置文件启动 AOF</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%A6%E5%8F%91%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3. 触发持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">1）自动触发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-text">2) 手动触发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-AOF-%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99"><span class="toc-text">4. AOF 文件重写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF-AOF-%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-text">1）什么是 AOF 重写？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89AOF-%E9%87%8D%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-text">2）AOF 重写实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89AOF-%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-text">3）AOF 重写流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">5. 配置说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">6. 数据恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%AD%A3%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">1）正常数据恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E7%AE%80%E5%8D%95%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">2）简单异常数据恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%A4%8D%E6%9D%82%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-text">3）复杂异常数据恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">7. 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-AOF-%E4%BC%98%E7%82%B9"><span class="toc-text">1) AOF 优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-AOF-%E7%BC%BA%E7%82%B9"><span class="toc-text">2) AOF 缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">4.3-混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AF%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">1. 开启混合持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AF"><span class="toc-text">1）通过命令行开启</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9-Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BC%80%E5%90%AF"><span class="toc-text">2）通过修改 Redis 配置文件开启</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">2. 实例运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">3. 数据恢复和源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">1）混合持久化的加载流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">2）源码解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">混合持久化优点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">混合持久化缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">5. 持久化最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%8E%A7%E5%88%B6%E6%8C%81%E4%B9%85%E5%8C%96%E5%BC%80%E5%85%B3"><span class="toc-text">1）控制持久化开关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BB%E4%BB%8E%E9%83%A8%E7%BD%B2"><span class="toc-text">2）主从部署</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E4%BD%BF%E7%94%A8%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3）使用混合持久化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%9B%B4%E9%AB%98%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="toc-text">4）使用配置更高的机器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Redis-%E4%BA%8B%E5%8A%A1"><span class="toc-text">5-Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">5.1-事务基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">5.2-开启事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%91%BD%E4%BB%A4%E5%85%A5%E5%88%97"><span class="toc-text">5.3-命令入列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1-%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1"><span class="toc-text">5.4-执行事务&#x2F;放弃事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%BA%8B%E5%8A%A1%E9%94%99%E8%AF%AF-amp-%E5%9B%9E%E6%BB%9A"><span class="toc-text">5.5-事务错误&amp;回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF"><span class="toc-text">1. 执行时错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F"><span class="toc-text">2. 入列错误不会导致事务结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%A5%E5%88%97%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F"><span class="toc-text">3. 入列错误导致事务结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="toc-text">4. 为什么不支持事务回滚？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E7%9B%91%E6%8E%A7"><span class="toc-text">5.6- 监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">5.7-代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E5%B0%8F%E7%BB%93"><span class="toc-text">5.8-小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Redis%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F"><span class="toc-text">6-Redis键值过期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">6.1-Redis过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%87%E6%9C%9F%E7%9A%84-key-%E9%9B%86%E5%90%88"><span class="toc-text">1. 过期的 key 集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E6%97%B6%E6%89%AB%E6%8F%8F%E7%AD%96%E7%95%A5"><span class="toc-text">2. 定时扫描策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8E%E5%BA%93%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">3. 从库的过期策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Redis-%E9%94%AE%E5%80%BC%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">6.2-Redis 键值过期操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%87%E6%9C%9F%E8%AE%BE%E7%BD%AE"><span class="toc-text">1. 过期设置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#expire%EF%BC%9AN-%E7%A7%92%E5%90%8E%E8%BF%87%E6%9C%9F"><span class="toc-text">expire：N 秒后过期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pexpire%EF%BC%9AN-%E6%AF%AB%E7%A7%92%E5%90%8E%E8%BF%87%E6%9C%9F"><span class="toc-text">pexpire：N 毫秒后过期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#expireat%EF%BC%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E7%A1%AE%E5%88%B0%E7%A7%92"><span class="toc-text">expireat：过期时间戳精确到秒</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pexpireat%EF%BC%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%B2%BE%E7%A1%AE%E5%88%B0%E6%AF%AB%E7%A7%92"><span class="toc-text">pexpireat：过期时间戳精确到毫秒</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">字符串中的过期操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-set-key-value-ex-seconds"><span class="toc-text">1. set key value ex seconds</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-set-key-value-ex-milliseconds"><span class="toc-text">2. set key value ex milliseconds</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-setex-key-seconds-valule"><span class="toc-text">3. setex key seconds valule</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A7%BB%E9%99%A4%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">2. 移除过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java%E5%AE%9E%E7%8E%B0%E8%BF%87%E6%9C%9F%E6%93%8D%E4%BD%9C"><span class="toc-text">3. Java实现过期操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">4. 持久化中的过期键</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB-%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">RDB 中的过期键</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-RDB-%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90"><span class="toc-text">1. RDB 文件生成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-RDB-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-text">2. RDB 文件加载</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E4%B8%AD%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">AOF 中的过期键</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-AOF-%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-text">1. AOF 文件写入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-AOF-%E9%87%8D%E5%86%99"><span class="toc-text">2. AOF 重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%BB%E4%BB%8E%E5%BA%93%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE"><span class="toc-text">5. 主从库的过期键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B0%8F%E7%BB%93"><span class="toc-text">6. 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">6.3-Redis 过期策略与源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%87%E6%9C%9F%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 过期键执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%87%E6%9C%9F%E9%94%AE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2. 过期键源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">3. 过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-text">定期删除</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 定期删除流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">2. 源码解析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-text">Redis 使用的过期策略</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Redis-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E2%80%94Pipeline"><span class="toc-text">7-Redis 管道技术—Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">7.1-管道技术的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">7.2-管道技术的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.3-管道技术的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF-VS-%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4"><span class="toc-text">7.4-管道技术 VS 普通命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E7%AE%A1%E9%81%93%E6%8A%80%E6%9C%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-text">7.5-管道技术需要注意的事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-text">8-内存淘汰机制与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Redis%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98"><span class="toc-text">8.1-Redis最大内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">8.2-内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">1. 查看 Redis 内存淘汰策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%88%86%E7%B1%BB"><span class="toc-text">2. 内存淘汰策略分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">修改 Redis 内存淘汰策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E5%90%84%E6%9C%89%E5%88%A9%E5%BC%8A%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E8%80%85%E8%87%AA%E5%B7%B1%E5%8E%BB%E6%9D%83%E8%A1%A1%E3%80%82"><span class="toc-text">设置内存淘汰策略有两种方法，这两种方法各有利弊，需要使用者自己去权衡。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-text">内存淘汰算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">8.3-LRU 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-LRU-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">1. LRU 算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%91-LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">2. 近 LRU 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-LRU-%E7%AE%97%E6%B3%95%E7%BC%BA%E7%82%B9"><span class="toc-text">3. LRU 算法缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-LFU-%E7%AE%97%E6%B3%95"><span class="toc-text">4. LFU 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9F%A5%E8%AF%A2%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E2%80%94GeoHash"><span class="toc-text">9-查询附近的人—GeoHash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E7%AE%97%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA"><span class="toc-text">9.1-用数据库来算附近的人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-GeoHash-%E7%AE%97%E6%B3%95"><span class="toc-text">9.2-GeoHash 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Redis%E7%9A%84GEO%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">9.3-Redis的GEO的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-text">1. 添加地理位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-text">2. 查询位置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B7%9D%E7%A6%BB%E7%BB%9F%E8%AE%A1"><span class="toc-text">3. 距离统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%BD%8D%E7%BD%AE%E5%86%85%E7%9A%84%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98%E4%BF%A1%E6%81%AF"><span class="toc-text">4. 查询某位置内的其他成员信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">9.4-代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">9.5-应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B8%B8%E6%A0%87%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89%E2%80%94Scan"><span class="toc-text">10-游标迭代器（过滤器）—Scan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Scan%EF%BC%9F"><span class="toc-text">10.1-为什么需要Scan？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Scan-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="toc-text">10.2-Scan 命令使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">10.3-代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-Scan-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">10.4-Scan 相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HScan-%E4%BD%BF%E7%94%A8"><span class="toc-text">1. HScan 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SScan-%E4%BD%BF%E7%94%A8"><span class="toc-text">2.SScan 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ZScan-%E4%BD%BF%E7%94%A8"><span class="toc-text">3. ZScan 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Scan-%E8%AF%B4%E6%98%8E"><span class="toc-text">5. Scan 说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">10.5-小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BC%98%E7%A7%80%E7%9A%84%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E2%80%94HyperLogLog"><span class="toc-text">11-优秀的基数统计算法—HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-HyperLogLog%EF%BC%9F"><span class="toc-text">11.1-为什么要使用 HyperLogLog？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-HyperLogLog-%E4%BB%8B%E7%BB%8D"><span class="toc-text">11.2-HyperLogLog 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">11.3-基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">1. 添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">2. 统计不重复的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%88%E5%B9%B6%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA-HLL-%E8%87%B3%E6%96%B0%E7%BB%93%E6%9E%84"><span class="toc-text">3. 合并一个或多个 HLL 至新结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-text">11.4-代码实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-HLL-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">11.5-HLL 算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E5%B0%8F%E7%BB%93"><span class="toc-text">11.6-小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">12-Redis消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">12.1-发布订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-text">1. 普通订阅与发布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF"><span class="toc-text">订阅消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">发送消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BB%E9%A2%98%E8%AE%A2%E9%98%85"><span class="toc-text">2. 主题订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-1"><span class="toc-text">3. 代码实战</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F"><span class="toc-text">普通模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%A2%98%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">主题订阅模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">12.2-消息队列的其他实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-List-%E7%89%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">1. List 版消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ZSet-%E7%89%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">2. ZSet 版消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-1"><span class="toc-text">优缺点分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94Stream"><span class="toc-text">12.3-消息队列终极解决方案—Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF-ID"><span class="toc-text">1. 消息 ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9"><span class="toc-text">2. 消息内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">3. 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B6%88%E6%81%AF"><span class="toc-text">添加消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">查询消息的长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF"><span class="toc-text">删除消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B4%E4%B8%AA-Stream"><span class="toc-text">删除整个 Stream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E6%B6%88%E6%81%AF"><span class="toc-text">查询区间消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%B6%88%E6%81%AF%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-text">查询某个消息之后的消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9F%BA%E7%A1%80%E7%89%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">4. 基础版消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E6%B6%88%E8%B4%B9%E7%BB%84"><span class="toc-text">5. 创建消费组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E7%BB%84%E5%91%BD%E4%BB%A4"><span class="toc-text">消息分组命令</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4%E7%BB%84"><span class="toc-text">创建消费者群组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B6%88%E6%81%AF"><span class="toc-text">读取消息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%A1%AE%E8%AE%A4"><span class="toc-text">消息消费确认</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%AA%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97"><span class="toc-text">查询未确认的消费队列</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#xinfo-%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">xinfo 查询相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%9F%A5%E8%AF%A2%E6%B5%81%E4%BF%A1%E6%81%AF"><span class="toc-text">1. 查询流信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E6%B6%88%E8%B4%B9%E7%BB%84%E6%B6%88%E6%81%AF"><span class="toc-text">2. 查询消费组消息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8B%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%88%90%E5%91%98%E4%BF%A1%E6%81%AF"><span class="toc-text">3. 查看消费者组成员信息</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">删除消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B6%88%E8%B4%B9%E7%BB%84"><span class="toc-text">删除消费组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%BF%9B%E9%98%B6%E7%89%88%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97"><span class="toc-text">6. 进阶版消费队列</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s4.ax1x.com/2022/02/15/HRSa9J.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2021/12/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2021-12-03T14:09:50.000Z" title="发表于 2021-12-03 22:09:50">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/16/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB"><img src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go操作MongoDB"></a><div class="content"><a class="title" href="/2021/11/16/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB">Go操作MongoDB</a><time datetime="2021-11-16T14:09:50.000Z" title="发表于 2021-11-16 22:09:50">2021-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/03/Spring%E4%B9%8BIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Spring之IOC源码分析"><img src="https://static01.imgkr.com/temp/fa403895570e4cafb459adbcdca97dbe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring之IOC源码分析"></a><div class="content"><a class="title" href="/2020/08/03/Spring%E4%B9%8BIOC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Spring之IOC源码分析">Spring之IOC源码分析</a><time datetime="2020-08-03T06:32:50.000Z" title="发表于 2020-08-03 14:32:50">2020-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/31/Spring%E4%B9%8B%E5%AE%9E%E7%8E%B0IOC%E5%92%8CAOP/" title="Spring之实现IOC和AOP"><img src="https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring之实现IOC和AOP"></a><div class="content"><a class="title" href="/2020/07/31/Spring%E4%B9%8B%E5%AE%9E%E7%8E%B0IOC%E5%92%8CAOP/" title="Spring之实现IOC和AOP">Spring之实现IOC和AOP</a><time datetime="2020-07-31T06:32:50.000Z" title="发表于 2020-07-31 14:32:50">2020-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/31/Spring%E4%B9%8BIOC%E7%9A%84%E5%BA%94%E7%94%A8/" title="Spring之IOC的应用-4"><img src="https://s3.bmp.ovh/imgs/2022/01/759f29a6471f2f3b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Spring之IOC的应用-4"></a><div class="content"><a class="title" href="/2020/07/31/Spring%E4%B9%8BIOC%E7%9A%84%E5%BA%94%E7%94%A8/" title="Spring之IOC的应用-4">Spring之IOC的应用-4</a><time datetime="2020-07-31T06:32:50.000Z" title="发表于 2020-07-31 14:32:50">2020-07-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>