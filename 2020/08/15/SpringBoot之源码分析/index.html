<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SpringBoot之源码分析-2 | Lemon-CS</title><meta name="keywords" content="SpringBoot"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringBoot之源码分析，依赖管理，自动配置，启动过程"><meta property="og:type" content="article"><meta property="og:title" content="SpringBoot之源码分析-2"><meta property="og:url" content="https://lemon-cs.github.io/2020/08/15/SpringBoot%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="SpringBoot之源码分析，依赖管理，自动配置，启动过程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s4.ax1x.com/2022/02/15/HRSzD0.jpg"><meta property="article:published_time" content="2020-08-15T14:09:50.000Z"><meta property="article:modified_time" content="2022-01-02T07:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="SpringBoot"><meta property="article:tag" content="Spring"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s4.ax1x.com/2022/02/15/HRSzD0.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/08/15/SpringBoot%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:1e3},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"SpringBoot之源码分析-2",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-02 15:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s4.ax1x.com/2022/02/15/HRSzD0.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot之源码分析-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-15T14:09:50.000Z" title="发表于 2020-08-15 22:09:50">2020-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-02T07:37:35.000Z" title="更新于 2022-01-02 15:37:35">2022-01-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="SpringBoot之源码分析-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="2-SpringBoot源码分析"><a href="#2-SpringBoot源码分析" class="headerlink" title="2. SpringBoot源码分析"></a>2. SpringBoot源码分析</h1><h2 id="2-1-源码分析-依赖管理"><a href="#2-1-源码分析-依赖管理" class="headerlink" title="2.1 源码分析-依赖管理"></a>2.1 源码分析-依赖管理</h2><h3 id="1-问题一：springboot为什么不需要指定版本？"><a href="#1-问题一：springboot为什么不需要指定版本？" class="headerlink" title="1. 问题一：springboot为什么不需要指定版本？"></a>1. 问题一：springboot为什么不需要指定版本？</h3><p>SpringBoot项目pom.xml中有两个核心依赖：spring-boot-starter-parent和spring-boot-starter-web。</p><p>spring-boot-starter-parent</p><p>在chapter01项目中的pom.xml文件中找到spring-boot-starter-parent依赖，示例代码如下:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot父项目依赖管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，将spring-boot-starter-parent依赖作为Spring Boot项目的统一父项目依赖管理，并将项目版本号统一为2.2.9.RELEASE，该版本号根据实际开发需求是可以修改的</p><p>使用“Ctrl+鼠标左键”进入并查看spring-boot-starter-parent底层源文件，先看spring-boot-starter-parent做了哪些事 首先看spring-boot-starter-parent 的properties 节点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../../..<span class="tag">&lt;/<span class="name">main.basedir</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resource.delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">resource.delimiter</span>&gt;</span> <span class="comment">&lt;!-- delimiter that doesn&#x27;t clash with Spring $&#123;&#125; placeholders --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里spring-boot-starter-parent 定义了：</p><ol><li>工程的Java版本为1.8 。</li><li>工程代码的编译源文件编码格式为UTF-8</li><li>工程编译后的文件编码格式为UTF-8</li><li>Maven打包编译的版本</li></ol><p>再来看spring-boot-starter-parent 的「build」节点 接下来看POM的build 节点，分别定义了resources 资源和pluginManagement</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们详细看一下resources 节点，里面定义了资源过滤，针对application 的yml 、properties 格式进行了过滤，可以支持不同环境的配置，比如application-dev.yml 、application-test.yml 等等。</p><p>pluginManagement 则是引入了相应的插件和对应的版本依赖</p><p>最后来看spring-boot-starter-parent的父依赖spring-boot-dependencies的properties节点</p><p>我们看定义POM，这个才是SpringBoot项目的真正管理依赖的项目，里面定义了SpringBoot相关的版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main.basedir</span>&gt;</span>$&#123;basedir&#125;/../..<span class="tag">&lt;/<span class="name">main.basedir</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Dependency versions --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.13<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.81<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.13.2<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">awaitility.version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">awaitility.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bitronix.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">bitronix.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.10.13<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caffeine.version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">caffeine.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cassandra-driver.version</span>&gt;</span>3.7.2<span class="tag">&lt;/<span class="name">cassandra-driver.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">classmate.version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">classmate.version</span>&gt;</span></span><br><span class="line">  .......</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-dependencies的dependencyManagement节点在这里，dependencies定义了SpringBoot版本的依赖的组件以及相应版本。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;revision&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;revision&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;revision&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;revision&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;revision&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-starter-parent 通过继承spring-boot-dependencies 从而实现了SpringBoot的版本依赖管理,所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了,这也就是在 Spring Boot 项目中部分依赖不需要写版本号的原因</p><h3 id="2-spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运行依赖的JAR包是从何而来的？"><a href="#2-spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运行依赖的JAR包是从何而来的？" class="headerlink" title="2. spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运行依赖的JAR包是从何而来的？"></a>2. spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运行依赖的JAR包是从何而来的？</h3><p>spring-boot-starter-web</p><p>查看spring-boot-starter-web依赖文件源码，核心代码具体如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上述代码可以发现，spring-boot-starter-web依赖启动器的主要作用是打包了Web开发场景所需的底层所有依赖（基于依赖传递，当前项目也存在对应的依赖jar包） 正是如此，在pom.xml中引入spring-boot-starter-web依赖启动器时，就可以实现Web场景开发，而不需要额外导入Tomcat服务器以及其他Web依赖文件等。 当然，这些引入的依赖文件的版本号还是由spring-boot-starter-parent父依赖进行的统一管理。</p><p>Spring Boot除了提供有上述介绍的Web依赖启动器外，还提供了其他许多开发场景的相关依赖，我们可以打开Spring Boot官方文档，搜索“Starters”关键字查询场景依赖启动器。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224225955.png"></p><p>列出了Spring Boot官方提供的部分场景依赖启动器，这些依赖启动器适用于不同的场景开发，使用时只需要在pom.xml文件中导入对应的依赖启动器即可。</p><p>需要说明的是，Spring Boot官方并不是针对所有场景开发的技术框架都提供了场景启动器，例如阿里巴巴的Druid数据源等，Spring Boot官方就没有提供对应的依赖启动器。为了充分利用Spring Boot框架的优势，在Spring Boot官方没有整合这些技术框架的情况下，Druid等技术框架所在的开发团队主动与Spring Boot框架进行了整合，实现了各自的依赖启动器，例如druid-spring-boot-starter等。我们在pom.xml文件中引入这些第三方的依赖启动器时，切记要配置对应的版本号。</p><h2 id="2-2-源码分析-自动配置"><a href="#2-2-源码分析-自动配置" class="headerlink" title="2.2 源码分析-自动配置"></a>2.2 源码分析-自动配置</h2><p>自动配置：根据我们添加的jar包依赖，会自动将一些配置类的bean注册进ioc容器，我们可以需要的地方使用@autowired或者@resource等注解来使用它。</p><p><strong>问题</strong>：Spring Boot到底是如何进行自动配置的，都把哪些组件进行了自动配置？</p><p>Spring Boot应用的启动入口是@SpringBootApplication注解标注类中的main()方法，</p><p><code>@SpringBootApplication</code> ： SpringBoot 应用标注在某个类上说明这个类是SpringBoot 的主配置类， SpringBoot 就应该运行这个类的main() 方法启动SpringBoot 应用。</p><h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. @SpringBootApplication</h3><p>下面，查看@SpringBootApplication内部源码进行分析 ，核心代码具体如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span> <span class="comment">//注解的适用范围,Type表示注解可以描述在类、接口、注解或枚举中</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//表示注解的生命周期，Runtime运行时</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">//表示注解可以记录在javadoc中</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//表示可以被子类继承该注解</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">// 标明该类为配置类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 启动自动配置功能</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">                                 @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// 根据class来排除特定的类，使其不能加入spring容器，传入参数value类型是class类型。</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 根据classname 来排除特定的类，使其不能加入spring容器，传入参数value类型是class的全类名字符串数组。</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定扫描包，参数是包名的字符串数组。</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 扫描特定的包，参数类似是Class类型数组。</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，@SpringBootApplication注解是一个组合注解，前面 4 个是注解的元数据信息， 我们主要看后面 3 个注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个核心注解，关于这三个核心注解的相关说明具体如下:</p><h3 id="2-SpringBootConfiguration"><a href="#2-SpringBootConfiguration" class="headerlink" title="2. @SpringBootConfiguration"></a>2. @SpringBootConfiguration</h3><p>@SpringBootConfiguration ： SpringBoot 的配置类，标注在某个类上，表示这是一个SpringBoot的配置类。</p><p>查看@SpringBootConfiguration注解源码，核心代码具体如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类的作用等同于配置文件，配置类也是容器中的一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，@SpringBootConfiguration注解内部有一个核心注解@Configuration，该注解是Spring框架提供的，表示当前类为一个配置类（XML配置文件的注解表现形式），并可以被组件扫描器扫描。由此可见，@SpringBootConfiguration注解的作用与@Configuration注解相同，都是标识一个可以被组件扫描器扫描的配置类，只不过@SpringBootConfiguration是被Spring Boot进行了重新封装命名而已。</p><h3 id="3-EnableAutoConfiguration"><a href="#3-EnableAutoConfiguration" class="headerlink" title="3. @EnableAutoConfiguration"></a>3. @EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"><span class="comment">// 自动配置包</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="comment">// Spring的底层注解@Import，给容器中导入一个组件</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="comment">// 告诉SpringBoot开启自动配置功能，这样自动配置才能生效。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">    <span class="comment">// 返回不会被导入到 Spring 容器中的类</span></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 返回不会被导入到 Spring 容器中的类名</span></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 中有很多以Enable 开头的注解，其作用就是借助@Import 来收集并注册特定场景相关的Bean ，并加载到IOC 容器。 @EnableAutoConfiguration就是借助@Import来收集所有符合自动配置条件的bean定义，并加载到IoC容器。</p><h3 id="4-AutoConfigurationPackage"><a href="#4-AutoConfigurationPackage" class="headerlink" title="4. @AutoConfigurationPackage"></a>4. @AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"><span class="comment">// Spring的底层注解@Import，给容器中导入一个组件</span></span><br><span class="line"><span class="comment">// 导入的组件是AutoConfigurationPackages.Registrar.class</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span> <span class="comment">// 导入Registrar中注册的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@AutoConfigurationPackage</code> ：自动配置包，它也是一个组合注解，其中最重要的注解是<code>@Import(AutoConfigurationPackages.Registrar.class)</code>，它是Spring 框架的底层注解，它的作用就是给容器中导入某个组件类，例如<code>@Import(AutoConfigurationPackages.Registrar.class)</code> ，它就是将<code>Registrar</code> 这个组件类导入到容器中，可查看Registrar 类中<code>registerBeanDefinitions</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将注解标注的元信息传入，获取到相应的包名</span></span><br><span class="line">    register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对new PackageImport(metadata).getPackageName() 进行检索，看看其结果是什么？</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224230646.png"></p><p>再看register方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里参数 packageNames 缺省情况下就是一个字符串，是使用了注解</span></span><br><span class="line">    <span class="comment">// @SpringBootApplication 的 Spring Boot 应用程序入口类所在的包</span></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;</span><br><span class="line">        <span class="comment">// 如果该bean已经注册，则将要注册包名称添加进去</span></span><br><span class="line">        BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN);</span><br><span class="line">        ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues();</span><br><span class="line">        constructorArguments.addIndexedArgumentValue(<span class="number">0</span>, addBasePackages(constructorArguments, packageNames));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果该bean尚未注册，则注册该bean，参数中提供的包名称会被设置到bean定义中去</span></span><br><span class="line">        GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClass(BasePackages.class);</span><br><span class="line">        beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>,packageNames);</span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        registry.registerBeanDefinition(BEAN, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                                     </span><br></pre></td></tr></table></figure><p>AutoConfigurationPackages.Registrar这个类就干一个事，注册一个Bean ，这个Bean 就是org.springframework.boot.autoconfigure.AutoConfigurationPackages.BasePackages ，它有一个参数，这个参数是使用了@AutoConfigurationPackage 这个注解的类所在的包路径,保存自动配置类以供之后的使用，比如给JPA entity 扫描器用来扫描开发人员通过注解@Entity 定义的entity类。</p><h3 id="5-Import-AutoConfigurationImportSelector-class"><a href="#5-Import-AutoConfigurationImportSelector-class" class="headerlink" title="5. @Import(AutoConfigurationImportSelector.class)"></a>5. @Import(AutoConfigurationImportSelector.class)</h3><p><code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code> ：将AutoConfigurationImportSelector 这个类导入到Spring 容器中，AutoConfigurationImportSelector 可以帮助Springboot 应用将所有符合条件的@Configuration配置都加载到当前SpringBoot 创建并使用的IOC 容器( ApplicationContext )中。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224230828.png"></p><p>可以看到AutoConfigurationImportSelector 重点是实现了DeferredImportSelector 接口和各种 Aware 接口，然后DeferredImportSelector 接口又继承了ImportSelector 接口。</p><p>其不光实现了ImportSelector 接口，还实现了很多其它的Aware 接口，分别表示在某个时机会被回调。</p><p><strong>确定自动配置实现逻辑的入口方法</strong>：</p><p>跟自动配置逻辑相关的入口方法在DeferredImportSelectorGrouping 类的getImports 方法处，因此我们就从DeferredImportSelectorGrouping 类的getImports 方法来开始分析SpringBoot的自动配置源码好了。</p><p>先看一下getImports 方法代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassParser.java</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">    <span class="comment">// 遍历DeferredImportSelectorHolder对象集合deferredImports，</span></span><br><span class="line">    <span class="comment">// deferredImports集合装了各种ImportSelector，当然这里装的是AutoConfigurationImportSelector</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="keyword">this</span>.deferredImports) &#123;</span><br><span class="line">        <span class="comment">// 【1】，利用AutoConfigurationGroup的process方法来处理自动配置的相关逻辑，</span></span><br><span class="line">        <span class="comment">// 		 决定导入哪些配置类（这个是我们分析的重点，自动配置的逻辑全在这了）</span></span><br><span class="line">            <span class="keyword">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">                               deferredImport.getImportSelector());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【2】，经过上面的处理后，然后再进行选择导入哪些配置类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.group.selectImports();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标【1】处的的代码是我们分析的重中之重，自动配置的相关的绝大部分逻辑全在这里了。那么this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()) ；主要做的事情就是在this.group 即 AutoConfigurationGroup 对象的process 方法中，传入的AutoConfigurationImportSelector 对象来选择一些符合条件的自动配置类，过滤掉一些不符合条件的自动配置类，就是这么个事情。</p><blockquote><p>注：<br><code>AutoConfigurationGroup</code>：是AutoConfigurationImportSelector的内部类，主要用来处理自动配置相关的逻辑，拥有process和selectImports方法，然后拥有entries和autoConfigurationEntries集合属性，这两个集合分别存储被处理后的符合条件的自动配置类，我们知道这些就足够了；<br><code>AutoConfigurationImportSelector</code>：承担自动配置的绝大部分逻辑，负责选择一些符合条件的自动配置类；<br><code>metadata</code>：标注在SpringBoot启动类上的@SpringBootApplication注解元数据<br>标【2】的this.group.selectImports的方法主要是针对前面的process方法处理后的自动配置类再进一步有选择的选择导入</p></blockquote><p>再进入到AutoConfigurationImportSelector$AutoConfigurationGroup的process方法：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224231135.png"></p><p>通过图中我们可以看到，跟自动配置逻辑相关的入口方法在process方法中。</p><p><strong>分析自动配置的主要逻辑</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector$AutoConfigurationGroup.java</span></span><br><span class="line"><span class="comment">// 这里用来处理自动配置类，比如过滤掉不符合匹配条件的自动配置类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                    DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">    Assert.state(</span><br><span class="line">        deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">        () -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">                            AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">                            deferredImportSelector.getClass().getName()));</span><br><span class="line">    <span class="comment">// 【1】,调用getAutoConfigurationEntry方法得到自动配置类放入autoConfigurationEntry对象中</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry =</span><br><span class="line">        ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">        .getAutoConfigurationEntry(getAutoConfigurationMetadata(),</span><br><span class="line">                                   annotationMetadata);</span><br><span class="line">    <span class="comment">// 【2】，又将封装了自动配置类的autoConfigurationEntry对象装进autoConfigurationEntries集合</span></span><br><span class="line">    <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">    <span class="comment">// 【3】，遍历刚获取的自动配置类</span></span><br><span class="line">    <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">        <span class="comment">// 这里符合条件的自动配置类作为key，annotationMetadata作为值放进entries集合</span></span><br><span class="line">        <span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中我们再来看标【1】的方法getAutoConfigurationEntry ，这个方法主要是用来获取自动配置类有关，承担了自动配置的主要逻辑。直接上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"><span class="comment">// 获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="params"><span class="function">    AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取是否有配置spring.boot.enableautoconfiguration属性，默认返回true</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得@Congiguration标注的Configuration类即被审视introspectedClass的注解数据，</span></span><br><span class="line">    <span class="comment">// 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)</span></span><br><span class="line">    <span class="comment">// 将会获取到exclude = FreeMarkerAutoConfiguration.class和excludeName=&quot;&quot;的注解数据</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 【1】得到spring.factories文件配置的所有自动配置类</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                                                             attributes);</span><br><span class="line">    <span class="comment">// 利用LinkedHashSet移除重复的配置类</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 得到要排除的自动配置类，比如注解属性exclude的配置类</span></span><br><span class="line">    <span class="comment">// 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)</span></span><br><span class="line">    <span class="comment">// 将会获取到exclude = FreeMarkerAutoConfiguration.class的注解数据</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 检查要被排除的配置类，因为有些不是自动配置类，故要抛出异常</span></span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 【2】将要排除的配置类移除</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 【3】因为从spring.factories文件获取的自动配置类太多，如果有些不必要的自动配置类都加载进内存，会造成内存浪费，因此这里需要进行过滤</span></span><br><span class="line">    <span class="comment">// 注意这里会调用AutoConfigurationImportFilter的match方法来判断是否符合</span></span><br><span class="line">    <span class="comment">// @ConditionalOnBean,@ConditionalOnClass或@ConditionalOnWebApplication，后面会重点分析一下</span></span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    <span class="comment">// 【4】获取了符合条件的自动配置类后，此时触发AutoConfigurationImportEvent事件，</span></span><br><span class="line">    <span class="comment">// 目的是告诉ConditionEvaluationReport条件评估报告器对象来记录符合条件的自动配置类</span></span><br><span class="line">    <span class="comment">// 该事件什么时候会被触发？--&gt; 在刷新容器时调用invokeBeanFactoryPostProcessors后置处理器时触发</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 【5】将符合条件和要排除的自动配置类封装进AutoConfigurationEntry对象，并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**深入 getCandidateConfigurations 方法 **</p><p>这个方法中有一个重要方法loadFactoryNames ，这个方法是让SpringFactoryLoader 去加载一些组件的名字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                  AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个方法需要传入两个参数getSpringFactoriesLoaderFactoryClass()和getBeanClassLoader()</span></span><br><span class="line">    <span class="comment">// getSpringFactoriesLoaderFactoryClass()这个方法返回的是EnableAutoConfiguration.class</span></span><br><span class="line">    <span class="comment">// getBeanClassLoader()这个方法返回的是beanClassLoader（类加载器）</span></span><br><span class="line">    List&lt;String&gt; configurations =</span><br><span class="line">        SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                               getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">                    + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br></pre></td></tr></table></figure><p>继续点开loadFactory 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取出入的键</span></span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName,</span><br><span class="line">                                                               Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果类加载器不为null，则加载类路径下spring.factories文件，将其中设置的配置类的全路径信息封装为Enumeration类对象</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line">            <span class="comment">//循环Enumeration类对象，根据相应的节点信息生成Properties对象，通过传入的键获取值，</span></span><br><span class="line">            <span class="comment">//在将值切割为一个个小的字符串转化为Array，放在result集合中</span></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以知道，在这个方法中会遍历整个ClassLoader中所有jar包下的spring.factories文件。</p><p>spring.factories里面保存着springboot的默认提供的自动配置类。</p><p><strong>META-INF/spring.factories</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224231422.png"></p><p>AutoConfigurationEntry 方法主要做的事情就是获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费。我们下面总结下AutoConfigurationEntry 方法主要做的事情：<br>【1】从spring.factories 配置文件中加载EnableAutoConfiguration 自动配置类）,获取的自动配置类如图所示。<br>【2】若@EnableAutoConfiguration 等注解标有要exclude 的自动配置类，那么再将这个自动配置类排除掉；<br>【3】排除掉要exclude 的自动配置类后，然后再调用filter 方法进行进一步的过滤，再次排除一些不符合条件的自动配置类；<br>【4】经过重重过滤后，此时再触发AutoConfigurationImportEvent 事件，告诉ConditionEvaluationReport 条件评估报告器对象来记录符合条件的自动配置类；<br>【5】 最后再将符合条件的自动配置类返回。</p><p>总结了AutoConfigurationEntry 方法主要的逻辑后，我们再来细看一下 AutoConfigurationImportSelector 的filter 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="params"><span class="function">                            AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    <span class="comment">// 将从spring.factories中获取的自动配置类转出字符串数组</span></span><br><span class="line">    String[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line">    <span class="comment">// 定义skip数组，是否需要跳过。注意skip数组与candidates数组顺序一一对应</span></span><br><span class="line">    <span class="keyword">boolean</span>[] skip = <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length];</span><br><span class="line">    <span class="keyword">boolean</span> skipped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// getAutoConfigurationImportFilters方法：拿到OnBeanCondition，OnClassCondition和OnWebApplicationCondition</span></span><br><span class="line">        <span class="comment">// 然后遍历这三个条件类去过滤从spring.factories加载的大量配置类</span></span><br><span class="line">        <span class="keyword">for</span> (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123;</span><br><span class="line">            <span class="comment">// 调用各种aware方法，将beanClassLoader,beanFactory等注入到filter对象中，</span></span><br><span class="line">            <span class="comment">// 这里的filter对象即OnBeanCondition，OnClassCondition或OnWebApplicationCondition</span></span><br><span class="line">            invokeAwareMethods(filter);</span><br><span class="line">            <span class="comment">// 判断各种filter来判断每个candidate（这里实质要通过candidate(自动配置类)拿到其标注的</span></span><br><span class="line">            <span class="comment">// @ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication里面的注解值）是否匹配，</span></span><br><span class="line">            <span class="comment">// 注意candidates数组与match数组一一对应</span></span><br><span class="line">            <span class="comment">/**********************【主线，重点关注】********************************/</span></span><br><span class="line">            <span class="keyword">boolean</span>[] match = filter.match(candidates, autoConfigurationMetadata);</span><br><span class="line">            <span class="comment">// 遍历match数组，注意match顺序跟candidates的自动配置类一一对应</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; match.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 若有不匹配的话</span></span><br><span class="line">                <span class="keyword">if</span> (!match[i]) &#123;</span><br><span class="line">                    <span class="comment">// 不匹配的将记录在skip数组，标志skip[i]为true，也与candidates数组一一对应</span></span><br><span class="line">                    skip[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 因为不匹配，将相应的自动配置类置空</span></span><br><span class="line">                    candidates[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 标注skipped为true</span></span><br><span class="line">                    skipped = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 这里表示若所有自动配置类经过OnBeanCondition，OnClassCondition和OnWebApplicationCondition过滤后，全部都匹配的话，则全部原样返回</span></span><br><span class="line">    <span class="keyword">if</span> (!skipped) &#123;</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立result集合来装匹配的自动配置类</span></span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若skip[i]为false，则说明是符合条件的自动配置类，此时添加到result集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!skip[i]) &#123;</span><br><span class="line">            result.add(candidates[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">int</span> numberFiltered = configurations.size() - result.size();</span><br><span class="line">        logger.trace(<span class="string">&quot;Filtered &quot;</span> + numberFiltered + <span class="string">&quot; auto configuration class in &quot;</span></span><br><span class="line">                     + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)</span><br><span class="line">                     + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回符合条件的自动配置类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoConfigurationImportSelector 的filter 方法主要做的事情就是调用AutoConfigurationImportFilter 接口的match 方法来判断每一个自动配置类上的条件注解（若有的话） @ConditionalOnClass , @ConditionalOnBean 或@ConditionalOnWebApplication 是否满足条件，若满足，则返回true，说明匹配，若不满足，则返回false说明不匹配。</p><p>我们现在知道AutoConfigurationImportSelector 的filter 方法主要做了什么事情就行了，现在先不用研究的过深。</p><p><strong>关于条件注解的讲解</strong>：</p><p>@Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。</p><ul><li>@ConditionalOnBean：仅仅在当前上下文中存在某个对象时，才会实例化一个Bean。</li><li>@ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。</li><li>@ConditionalOnExpression：当表达式为true的时候，才会实例化一个Bean。基于SpEL表达式的条件判断。</li><li>@ConditionalOnMissingBean：仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean。</li><li>@ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。</li><li>@ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。</li><li>@ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。</li><li>@ConditionalOnProperty：当指定的属性有指定的值时进行实例化。</li><li>@ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。</li><li>@ConditionalOnResource：当类路径下有指定的资源时触发实例化。</li><li>@ConditionalOnJndi：在JNDI存在的条件下触发实例化。</li><li>@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li></ul><p>**有选择的导入自动配置类 **</p><p>this.group.selectImports 方法是如何进一步有选择的导入自动配置类的。直接看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector$AutoConfigurationGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Entry&gt; <span class="title">selectImports</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.autoConfigurationEntries.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里得到所有要排除的自动配置类的set集合</span></span><br><span class="line">    Set&lt;String&gt; allExclusions = <span class="keyword">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">        .map(AutoConfigurationEntry::getExclusions)</span><br><span class="line">        .flatMap(Collection::stream).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">// 这里得到经过滤后所有符合条件的自动配置类的set集合</span></span><br><span class="line">    Set&lt;String&gt; processedConfigurations = <span class="keyword">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">        .map(AutoConfigurationEntry::getConfigurations)</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">// 移除掉要排除的自动配置类</span></span><br><span class="line">    processedConfigurations.removeAll(allExclusions);</span><br><span class="line">    <span class="comment">// 对标注有@Order注解的自动配置类进行排序，</span></span><br><span class="line">    <span class="keyword">return</span> sortAutoConfigurations(processedConfigurations,</span><br><span class="line">                                  getAutoConfigurationMetadata())</span><br><span class="line">        .stream()</span><br><span class="line">        .map((importClassName) -&gt; <span class="keyword">new</span> Entry(</span><br><span class="line">            <span class="keyword">this</span>.entries.get(importClassName), importClassName))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， selectImports 方法主要是针对经过排除掉exclude 的和被AutoConfigurationImportFilter 接口过滤后的满足条件的自动配置类再进一步排除exclude 的自动配置类，然后再排序。</p><p>最后，我们再总结下SpringBoot自动配置的原理，主要做了以下事情：</p><ol><li>从spring.factories配置文件中加载自动配置类；</li><li>加载的自动配置类中排除掉@EnableAutoConfiguration 注解的exclude 属性指定的自动配置类；</li><li>然后再用AutoConfigurationImportFilter 接口去过滤自动配置类是否符合其标注注解（若有标注的话）@ConditionalOnClass , @ConditionalOnBean 和 @ConditionalOnWebApplication 的条件，若都符合的话则返回匹配结果；</li><li>然后触发AutoConfigurationImportEvent 事件，告诉ConditionEvaluationReport 条件评估报告器对象来分别记录符合条件和exclude 的自动配置类。</li><li>最后spring再将最后筛选后的自动配置类导入IOC容器中。</li></ol><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224231827.png"></p><p>以HttpEncodingAutoConfiguration （ Http 编码自动配置）为例解释自动配置原理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)</span></span><br><span class="line"><span class="comment">// 判断当前应用是否是web应用，如果是，当前配置类生效。并把HttpEncodingProperties加入到 ioc 容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="comment">// Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效。</span></span><br><span class="line"><span class="comment">// 判断当前项目有没有这个CharacterEncodingFilter ： SpringMVC中进行乱码解决的过滤器</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span></span><br><span class="line"><span class="comment">// 判断配置文件中是否存在某个配置 spring.http.encoding.enabled 如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">// matchIfMissing = true 表示即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.http.encoding&quot;,</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 它已经和SpringBoot配置文件中的值进行映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">    <span class="comment">// 只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加一个组件，这个组件中的某些值需要从properties中获取</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;CharacterEncodingFilter.class&#125;)</span> <span class="comment">//判断容器中没有这个组件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效。 一旦这个配置类生效，这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 我们能配置的属性都是来源于这个功能的properties类</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line">spring.http.encoding.charset=utf-8</span><br><span class="line">spring.http.encoding.force=true</span><br></pre></td></tr></table></figure><p>所有在配置文件中能配置的属性都是在 xxxProperties 类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>**精髓 **：</p><ol><li>SpringBoot 启动会加载大量的自动配置类</li><li>我们看我们需要实现的功能有没有SpringBoot 默认写好的自动配置类</li><li>我们再来看这个自动配置类中到底配置了哪些组件；（只要我们有我们要用的组件，我们就不需要再来配置了）</li><li>给容器中自动配置类添加组件的时候，会从properties 类中获取某些属性，我们就可以在配置文件中指定这些属性的值。</li><li>xxxAutoConfiguration ：自动配置类，用于给容器中添加组件从而代替之前我们手动完成大量繁琐的配置。</li><li>xxxProperties : 封装了对应自动配置类的默认属性值，如果我们需要自定义属性值，只需要根据 xxxProperties 寻找相关属性在配置文件设值即可。</li></ol><h3 id="6-ComponentScan"><a href="#6-ComponentScan" class="headerlink" title="6. @ComponentScan"></a>6. @ComponentScan</h3><p>主要是从定义的扫描路径中，找出标识了需要装配的类自动装配到spring 的bean容器中。</p><p><strong>常用属性如下</strong>：</p><ul><li>basePackages、value：指定扫描路径，如果为空则以@ComponentScan注解的类所在的包为基本的扫描路径</li><li>basePackageClasses：指定具体扫描的类</li><li>includeFilters：指定满足Filter条件的类</li><li>excludeFilters：指定排除Filter条件的类</li><li>includeFilters和excludeFilters 的FilterType可选：ANNOTATION=注解类型 默认、ASSIGNABLE_TYPE(指定固定类)、ASPECTJ(ASPECTJ类型)、REGEX(正则表达式)、CUSTOM(自定义类型)，自定义的Filter需要实现TypeFilter接口</li></ul><p>@ComponentScan的配置如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes =</span></span><br><span class="line"><span class="meta">                                          TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">                                 @Filter(type = FilterType.CUSTOM, classes =</span></span><br><span class="line"><span class="meta">                                         AutoConfigurationExcludeFilter.class) &#125;)</span></span><br></pre></td></tr></table></figure><p>借助excludeFilters将TypeExcludeFillter及FilterType这两个类进行排除 当前@ComponentScan注解没有标注basePackages及value，所以扫描路径默认为@ComponentScan注解的类所在的包为基本的扫描路径（也就是标注了@SpringBootApplication注解的项目启动类所在的路径）</p><p><strong>抛出疑问</strong>：<br>@EnableAutoConfiguration注解是通过@Import注解加载了自动配置固定的bean<br>@ComponentScan注解自动进行注解扫描</p><p>那么真正根据包扫描，把组件类生成实例对象存到IOC容器中，又是怎么来完成的？</p><h2 id="2-3-源码分析-Run方法执行流程"><a href="#2-3-源码分析-Run方法执行流程" class="headerlink" title="2.3 源码分析-Run方法执行流程"></a>2.3 源码分析-Run方法执行流程</h2><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224224030.png"></p><h3 id="1-SpringBoot项目的mian函数"><a href="#1-SpringBoot项目的mian函数" class="headerlink" title="1. SpringBoot项目的mian函数"></a>1. SpringBoot项目的mian函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestMVCApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyTestMVCApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用重载方法</span></span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两件事：1.初始化SpringApplication 2.执行run方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SpringApplication-构造方法"><a href="#2-SpringApplication-构造方法" class="headerlink" title="2. SpringApplication() 构造方法"></a>2. SpringApplication() 构造方法</h3><p><strong>继续查看源码， SpringApplication 实例化过程，首先是进入带参数的构造方法，最终回来到两个参数的构造方法。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置资源加载器为null</span></span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">//断言加载资源类不能为null</span></span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">//将primarySources数组转换为List，最后放到LinkedHashSet集合中</span></span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1.1 推断应用类型，后面会根据类型初始化对应的环境。常用的一般都是servlet环境 】</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1.2 初始化classpath下 META-INF/spring.factories中已配置的 ApplicationContextInitializer 】</span></span><br><span class="line">    setInitializers((Collection)getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1.3 初始化classpath下所有已配置的 ApplicationListener 】</span></span><br><span class="line">    setListeners((Collection)getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1.4 根据调用栈，推断出 main 方法的类名 】</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deduceWebApplicationType"><a href="#deduceWebApplicationType" class="headerlink" title="deduceWebApplicationType();"></a>deduceWebApplicationType();</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = </span><br><span class="line">&#123; <span class="string">&quot;javax.servlet.Servlet&quot;</span>, <span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBMVC_INDICATOR_CLASS = </span><br><span class="line">    <span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBFLUX_INDICATOR_CLASS = </span><br><span class="line">    <span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JERSEY_INDICATOR_CLASS = </span><br><span class="line">    <span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_APPLICATION_CONTEXT_CLASS = </span><br><span class="line">    <span class="string">&quot;org.springframework.web.context.WebApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REACTIVE_APPLICATION_CONTEXT_CLASS = </span><br><span class="line">    <span class="string">&quot;org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断 应用的类型</span></span><br><span class="line"><span class="comment">* NONE: 应用程序不是web应用，也不应该用web服务器去启动</span></span><br><span class="line"><span class="comment">* SERVLET: 应用程序应作为基于 servlet 的web应用程序运行，并应启动嵌入式 servlet web（tomcat）服务器。</span></span><br><span class="line"><span class="comment">* REACTIVE: 应用程序应作为 reactive 的web应用程序运行，并应启动嵌入式 reactive web服务器。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//classpath下必须存在org.springframework.web.reactive.DispatcherHandler</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">        <span class="comment">//classpath环境下不存在javax.servlet.Servlet或者org.springframework.web.context.ConfigurableWebApplicationContext</span></span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回类型是WebApplicationType的枚举类型， WebApplicationType 有三个枚举，三个枚举的解释如</p><p>其中注释</p><p>具体的判断逻辑如下：</p><ul><li><p>WebApplicationType.REACTIVE classpath下存在org.springframework.web.reactive.DispatcherHandler</p></li><li><p>WebApplicationType.SERVLET classpath下存在javax.servlet.Servlet或者org.springframework.web.context.ConfigurableWebApplicationContext</p></li><li><p>WebApplicationType.NONE 不满足以上条件。</p></li></ul><h4 id="setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class"><a href="#setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class" class="headerlink" title="setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));"></a>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</h4><p>初始化classpath下 META-INF/spring.factories中已配置的ApplicationContextInitializer，<strong>实例化后存入内部属性</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> getSpringFactoriesInstances 通过指定的classloader 从META-INF/spring.factories获取指定的Spring的工厂实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterTypes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.Collection&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">	ClassLoader classLoader = getClassLoader();</span><br><span class="line">	<span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">	<span class="comment">//通过指定的classLoader从 META-INF/spring.factories 的资源文件中，</span></span><br><span class="line">	<span class="comment">//读取 key 为 type.getName() 的 value</span></span><br><span class="line">	Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">	<span class="comment">//创建Spring工厂实例</span></span><br><span class="line">	List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">	<span class="comment">//对Spring工厂实例排序（org.springframework.core.annotation.Order注解指定的顺序）</span></span><br><span class="line">	AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">		ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">	List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">	<span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">			Assert.isAssignable(type, instanceClass);</span><br><span class="line">			Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">			T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">			instances.add(instance);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 getSpringFactoriesInstances 都干了什么，看源码，有一个方法很重要 loadFactoryNames()这个方法很重要，这个方法是spring-core中提供的从META-INF/spring.factories中获取指定的类（key）的同一入口方法。</p><p>在这里，获取的是key为 org.springframework.context.ApplicationContextInitializer 的类。</p><p>debug看看都获取到了哪些：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224232745.png"></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224232757.png"></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224232813.png"></p><p>找到配置的<code>ApplicationContextInitializer</code>类后对对其进行实例化</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224232833.png"></p><p>发现在上图所示的两个工程中找到了debug中看到的结果。</p><p>ApplicationContextInitializer 是Spring框架的类, 这个类的主要目的就是在ConfigurableApplicationContext 调用refresh()方法之前，回调这个类的initialize方法。通过 ConfigurableApplicationContext 的实例获取容器的环境Environment，从而实现对配置文件的修改完善等工作。</p><h4 id="setListeners-Collection-getSpringFactoriesInstances-ApplicationListener-class"><a href="#setListeners-Collection-getSpringFactoriesInstances-ApplicationListener-class" class="headerlink" title="setListeners((Collection)getSpringFactoriesInstances(ApplicationListener.class));"></a>setListeners((Collection)getSpringFactoriesInstances(ApplicationListener.class));</h4><p>初始化classpath下 META-INF/spring.factories中已配置的 ApplicationListener。</p><p>ApplicationListener 的加载过程和上面的 ApplicationContextInitializer 类的加载过程是一样的。不多说了，至于 ApplicationListener 是spring的事件监听器，典型的观察者模式，通过ApplicationEvent 类和 ApplicationListener 接口，可以实现对spring容器全生命周期的监听，当然也可以自定义监听事件。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224232921.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>关于 SpringApplication 类的构造过程，到这里我们就梳理完了。纵观 SpringApplication 类的实例化过程，我们可以看到，合理的利用该类，我们能在spring容器创建之前做一些预备工作，和定制化的需求。</p><p>比如，自定义SpringBoot的Banner，比如自定义事件监听器，再比如在容器refresh之前通过自定义ApplicationContextInitializer 修改配置一些配置或者获取指定的bean都是可以的。</p><h3 id="3-run-args"><a href="#3-run-args" class="headerlink" title="3. run(args)"></a>3. run(args)</h3><p>上一小节我们查看了SpringApplication 类的实例化过程，这一小节总结SpringBoot启动流程最重要的部分：run方法。<br>通过run方法梳理出SpringBoot启动的流程。 经过深入分析后，大家会发现SpringBoot也就是给Spring包了一层皮，事先替我们准备好Spring所需要的环境及一些基础。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args the application arguments (usually passed from a Java mainmethod)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 运行spring应用，并刷新一个新的 ApplicationContext（Spring的上下文）</span></span><br><span class="line"><span class="comment">* ConfigurableApplicationContext 是 ApplicationContext 接口的子接口。在ApplicationContext</span></span><br><span class="line"><span class="comment">* 基础上增加了配置上下文的工具。 ConfigurableApplicationContext是容器的高级接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//StopWatch主要是用来统计每项任务执行时长，例如Spring Boot启动占用总时长。</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">// ConfigurableApplicationContext Spring 的上下文</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">//第一步：获取并启动监听器 通过加载META-INF/spring.factories 完成了SpringApplicationRunListener实例化工作</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">//实际上是调用了EventPublishingRunListener类的starting()方法</span></span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">//第二步：构造容器环境，简而言之就是加载系统变量，环境变量，配置文件</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="comment">//设置需要忽略的bean</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">//打印banner</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">//第三步：创建容器</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		<span class="comment">//第四步：实例化SpringBootExceptionReporter.class，用来支持报告关于启动的错误</span></span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">            SpringBootExceptionReporter.class,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        <span class="comment">//第五步：准备容器 这一步主要是在容器刷新之前的准备动作。包含一个非常关键的操作：</span></span><br><span class="line">        <span class="comment">//将启动类注入容器，为后续开启自动化配置奠定基础。</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">//第六步：刷新容器 springBoot相关的处理工作已经结束，接下的工作就交给了spring。内部会调用spring的refresh方法，</span></span><br><span class="line">		<span class="comment">// refresh方法在spring整个源码体系中举足轻重，是实现 ioc 和 aop的关键。</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">//第七步：刷新容器后的扩展接口 设计模式中的模板方法，默认为空实现。如果有自定义需求，可以重写该方法。</span></span><br><span class="line">        <span class="comment">//比如打印一些启动结束log，或者一些其它后置处理。</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">//时间记录停止</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发布容器启动完成事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">//遍历所有注册的ApplicationRunner和CommandLineRunner，并执行其run()方法。</span></span><br><span class="line">		<span class="comment">//我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对SpringBoot的启动过程进行扩展。</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//应用已经启动完成的监听事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，启动过程中的重要步骤共分为六步</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步：获取并启动监听器</span><br><span class="line">第二步：构造应用上下文环境</span><br><span class="line">第三步：初始化应用上下文</span><br><span class="line">第四步：刷新应用上下文前的准备阶段</span><br><span class="line">第五步：刷新应用上下文</span><br><span class="line">第六步：刷新应用上下文后的扩展接口</span><br></pre></td></tr></table></figure><h4 id="第一步：获取并启动监听器"><a href="#第一步：获取并启动监听器" class="headerlink" title="第一步：获取并启动监听器"></a>第一步：获取并启动监听器</h4><p>事件机制在Spring是很重要的一部分内容，通过事件机制我们可以监听Spring容器中正在发生的一些事件，同样也可以自定义监听事件。Spring的事件为Bean和Bean之间的消息传递提供支持。当一个对象处理完某种任务后，通知另外的对象进行某些处理，常用的场景有进行某些操作后发送通知，消息、邮件等情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">	<span class="comment">// SpringApplicationRunListener负责在springboot启动的不同阶段</span></span><br><span class="line">	<span class="comment">// 广播出不同的消息，传递给ApplicationListener监听器实现类</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger,</span><br><span class="line">			getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面看到一个熟悉的方法：getSpringFactoriesInstances()，可以看下面的注释，前面已经详细介绍过该方法是怎么一步步的获取到META-INF/spring.factories中的指定的key的value，获取到以后怎么实例化类的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> getSpringFactoriesInstances 通过指定的classloader 从META-INF/spring.factories获取指定的Spring的工厂实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterTypes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.Collection&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">	ClassLoader classLoader = getClassLoader();</span><br><span class="line">	<span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">	<span class="comment">//通过指定的classLoader从 META-INF/spring.factories 的资源文件中，</span></span><br><span class="line">	<span class="comment">//读取 key 为 type.getName() 的 value</span></span><br><span class="line">	Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">	<span class="comment">//创建Spring工厂实例</span></span><br><span class="line">	List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">	<span class="comment">//对Spring工厂实例排序（org.springframework.core.annotation.Order注解指定的顺序）</span></span><br><span class="line">	AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224233656.png"></p><p>回到run方法，debug这个代码 SpringApplicationRunListeners listeners = getRunListeners(args); 看一下获取的是哪个监听器：</p><p>EventPublishingRunListener监听器是Spring容器的启动监听器。listeners.starting(); 开启了监听事件</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224233721.png"></p><h4 id="第二步：构造应用上下文环境"><a href="#第二步：构造应用上下文环境" class="headerlink" title="第二步：构造应用上下文环境"></a>第二步：构造应用上下文环境</h4><p>应用上下文环境包括什么呢？包括计算机的环境，Java环境，Spring的运行环境，Spring项目的配置（在SpringBoot中就是那个熟悉的application.properties/yml）等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">		ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Create and configure the environment</span></span><br><span class="line">	<span class="comment">//创建并配置相应的环境</span></span><br><span class="line">	ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">	<span class="comment">//根据用户配置，配置 environment系统环境</span></span><br><span class="line">	configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">	ConfigurationPropertySources.attach(environment);</span><br><span class="line">	<span class="comment">// 启动相应的监听器，其中一个重要的监听器 ConfigFileApplicationListener 就是加载项目配置文件的监听器。</span></span><br><span class="line">	listeners.environmentPrepared(environment);</span><br><span class="line">	bindToSpringApplication(environment);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">		environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">				deduceEnvironmentClass());</span><br><span class="line">	&#125;</span><br><span class="line">	ConfigurationPropertySources.attach(environment);</span><br><span class="line">	<span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中主要完成的工作，首先是创建并按照相应的应用类型配置相应的环境，然后根据用户的配置，配置系统环境，然后启动监听器，并加载系统配置文件。</p><h5 id="ConfigurableEnvironment-environment-getOrCreateEnvironment"><a href="#ConfigurableEnvironment-environment-getOrCreateEnvironment" class="headerlink" title="ConfigurableEnvironment environment = getOrCreateEnvironment()"></a>ConfigurableEnvironment environment = getOrCreateEnvironment()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 通过SpringApplication实例化时返回的webApplicationType判断当前应用的类型</span></span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">	<span class="keyword">case</span> SERVLET:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">	<span class="keyword">case</span> REACTIVE:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StandardReactiveWebEnvironment();</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224233958.png"></p><p>从上面的继承关系可以看出，StandardServletEnvironment是StandardEnvironment的子类。这两个对象也没什么好讲的，当是web项目的时候，环境上会多一些关于web环境的配置。</p><h5 id="configureEnvironment-environment-applicationArguments-getSourceArgs"><a href="#configureEnvironment-environment-applicationArguments-getSourceArgs" class="headerlink" title="configureEnvironment(environment, applicationArguments.getSourceArgs());"></a>configureEnvironment(environment, applicationArguments.getSourceArgs());</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.addConversionService) &#123;</span><br><span class="line">		ConversionService conversionService = ApplicationConversionService.getSharedInstance();</span><br><span class="line">		environment.setConversionService((ConfigurableConversionService) conversionService);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将main 函数的args封装成 SimpleCommandLinePropertySource 加入环境中。</span></span><br><span class="line">	configurePropertySources(environment, args);</span><br><span class="line">	<span class="comment">// 激活相应的配置文件</span></span><br><span class="line">	configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234038.png"></p><p>如下图所示，在spring的启动参数中指定了参数：–spring.profiles.active=prod</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234104.png"></p><p>在<code>**configurePropertySources(environment, args)**</code>;中将args封装成了<code>**SimpleCommandLinePropertySource**</code>并加入到了<code>**environment**</code>中。</p><p><code>**configureProfiles(environment, args);**</code>根据启动参数激活了相应的配置文件。</p><h5 id="listeners-environmentPrepared-environment"><a href="#listeners-environmentPrepared-environment" class="headerlink" title="listeners.environmentPrepared(environment);"></a>listeners.environmentPrepared(environment);</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">		Executor executor = getTaskExecutor();</span><br><span class="line">		<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				invokeListener(listener, event);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234154.png"></p><p>查看getApplicationListeners(event, type)执行结果，发现一个重要的监听器ConfigFileApplicationListener。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnvironmentPostProcessor&#125; that configures the context environment by loading</span></span><br><span class="line"><span class="comment"> * properties from well known file locations. By default properties will be loaded from</span></span><br><span class="line"><span class="comment"> * &#x27;application.properties&#x27; and/or &#x27;application.yml&#x27; files in the following locations:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;file:./config/&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;file:./&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;classpath:config/&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;classpath:&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * The list is ordered by precedence (properties defined in locations higher in the list</span></span><br><span class="line"><span class="comment"> * override those defined in lower locations).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Alternative search locations and names can be specified using</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setSearchLocations(String)&#125; and &#123;<span class="doctag">@link</span> #setSearchNames(String)&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Additional files will also be loaded based on active profiles. For example if a &#x27;web&#x27;</span></span><br><span class="line"><span class="comment"> * profile is active &#x27;application-web.properties&#x27; and &#x27;application-web.yml&#x27; will be</span></span><br><span class="line"><span class="comment"> * considered.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The &#x27;spring.config.name&#x27; property can be used to specify an alternative name to load</span></span><br><span class="line"><span class="comment"> * and the &#x27;spring.config.location&#x27; property can be used to specify alternative search</span></span><br><span class="line"><span class="comment"> * locations or specific files.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这个监听器默认的从注释中标签所示的几个位置加载配置文件，并将其加入 上下文的 environment变量中。当然也可以通过配置指定。</p><p>debug跳过 listeners.environmentPrepared(environment); 这一行，查看environment属性，果真如上面所说的，配置文件的配置信息已经添加上来了。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234230.png"></p><h4 id="第三步：初始化应用上下文"><a href="#第三步：初始化应用上下文" class="headerlink" title="第三步：初始化应用上下文"></a>第三步：初始化应用上下文</h4><p>在SpringBoot工程中，应用类型分为三种，如下代码所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">WebApplicationType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The application should not run as a web application and should not start an</span></span><br><span class="line"><span class="comment">	 * embedded web server.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NONE,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The application should run as a servlet-based web application and should start an</span></span><br><span class="line"><span class="comment">	 * embedded servlet web server.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SERVLET,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The application should run as a reactive web application and should start an</span></span><br><span class="line"><span class="comment">	 * embedded reactive web server.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应三种应用类型，SpringBoot项目有三种对应的应用上下文，我们以web工程为例，即其上下文为<code>**AnnotationConfigServletWebServerApplicationContext**</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for non-web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">&quot;org.springframework.context.&quot;</span></span><br><span class="line">		+ <span class="string">&quot;annotation.AnnotationConfigApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class="string">&quot;org.springframework.boot.&quot;</span></span><br><span class="line">		+ <span class="string">&quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for reactive web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class="string">&quot;org.springframework.&quot;</span></span><br><span class="line">		+ <span class="string">&quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">	<span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下AnnotationConfigServletWebServerApplicationContext的设计：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234402.png"></p><p>应用上下文可以理解成IoC容器的高级表现形式，应用上下文确实是在IoC容器的基础上丰富了一些高级功能。</p><p>应用上下文对IoC容器是持有的关系。他的一个属性beanFactory就是IoC容器（DefaultListableBeanFactory）。所以他们之间是持有，和扩展的关系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234430.png"></p><p>beanFactory正是在<code>AnnotationConfigServletWebServerApplicationContext</code>实现的接口<code>GenericApplicationContext</code>中定义的。在上面<code>createApplicationContext()</code>方法中的，<code>BeanUtils.instantiateClass(contextClass)</code> 这个方法中，不但初始化了<code>AnnotationConfigServletWebServerApplicationContext</code>类，也就是我们的上下文context，同样也触发了<code>GenericApplicationContext</code>类的构造函数，从而IoC容器也创建了。</p><p>仔细看他的构造函数，有没有发现一个很熟悉的类<code>DefaultListableBeanFactory</code>，没错，DefaultListableBeanFactory就是IoC容器真实面目了。在后面的refresh()方法分析中，DefaultListableBeanFactory是无处不在的存在感。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234452.png"></p><p>如上图所示，context就是我们熟悉的上下文（也有人称之为容器，都可以，看个人爱好和理解），beanFactory就是我们所说的IoC容器的真实面孔了。细细感受下上下文和容器的联系和区别，对于我们理解源码有很大的帮助。在我们学习过程中，我们也是将上下文和容器严格区分开来的。</p><h4 id="第四步：刷新应用上下文前的准备阶段"><a href="#第四步：刷新应用上下文前的准备阶段" class="headerlink" title="第四步：刷新应用上下文前的准备阶段"></a>第四步：刷新应用上下文前的准备阶段</h4><h5 id="prepareContext-方法"><a href="#prepareContext-方法" class="headerlink" title="prepareContext()方法"></a>prepareContext()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="params"><span class="function">		SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置容器环境</span></span><br><span class="line">	context.setEnvironment(environment);</span><br><span class="line">	<span class="comment">//执行容器后置处理</span></span><br><span class="line">	postProcessApplicationContext(context);</span><br><span class="line">	<span class="comment">//执行容器中的 ApplicationContextInitializer 包括spring.factories和通过三种方式自定义的</span></span><br><span class="line">	applyInitializers(context);</span><br><span class="line">	<span class="comment">//向各个监听器发送容器已经准备好的事件</span></span><br><span class="line">	listeners.contextPrepared(context);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">		logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">		logStartupProfileInfo(context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">	<span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">	<span class="comment">//将main函数中的args参数封装成单例Bean，注册进容器</span></span><br><span class="line">	beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">	<span class="comment">//将 printedBanner 也封装成单例，注册进容器</span></span><br><span class="line">	<span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">		beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">		((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">				.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">		context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Load the sources</span></span><br><span class="line">	Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">	Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">	<span class="comment">//加载我们的启动类，将启动类注入容器</span></span><br><span class="line">	load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">	<span class="comment">//发布容器已加载事件</span></span><br><span class="line">	listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看这行 Set sources = getAllSources(); 在getAllSources()中拿到了我们的启动类。重点在这行 load(context, sources.toArray(new Object[0])); ，其他的方法请参阅注释。</p><p>跟进load()方法，看源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建 BeanDefinitionLoader</span></span><br><span class="line">	BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">		loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">		loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">		loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">	&#125;</span><br><span class="line">	loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getBeanDefinitionRegistry"><a href="#getBeanDefinitionRegistry" class="headerlink" title="getBeanDefinitionRegistry()"></a>getBeanDefinitionRegistry()</h5><p>继续看getBeanDefinitionRegistry()方法的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionRegistry <span class="title">getBeanDefinitionRegistry</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (context <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">		<span class="keyword">return</span> (BeanDefinitionRegistry) context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (context <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">		<span class="keyword">return</span> (BeanDefinitionRegistry) ((AbstractApplicationContext) context).getBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Could not locate BeanDefinitionRegistry&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将我们前文创建的上下文强转为BeanDefinitionRegistry，他们之间是有继承关系的。BeanDefinitionRegistry定义了很重要的方法registerBeanDefinition()，该方法将BeanDefinition注册进DefaultListableBeanFactory容器的beanDefinitionMap中。</p><h5 id="createBeanDefinitionLoader"><a href="#createBeanDefinitionLoader" class="headerlink" title="createBeanDefinitionLoader()"></a>createBeanDefinitionLoader()</h5><p>继续看createBeanDefinitionLoader()方法，最终进入了BeanDefinitionLoader类的构造方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) &#123;</span><br><span class="line">	Assert.notNull(registry, <span class="string">&quot;Registry must not be null&quot;</span>);</span><br><span class="line">	Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">	<span class="keyword">this</span>.sources = sources;</span><br><span class="line">	<span class="comment">//注解形式的Bean定义读取器 比如：@Configuration @Bean @Component @Controller@Service等等</span></span><br><span class="line">	<span class="keyword">this</span>.annotatedReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(registry);</span><br><span class="line">	<span class="comment">//XML形式的Bean定义读取器</span></span><br><span class="line">	<span class="keyword">this</span>.xmlReader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);</span><br><span class="line">	<span class="keyword">if</span> (isGroovyPresent()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.groovyReader = <span class="keyword">new</span> GroovyBeanDefinitionReader(registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//类路径扫描器</span></span><br><span class="line">	<span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(registry);</span><br><span class="line">	<span class="comment">//扫描器添加排除过滤器</span></span><br><span class="line">	<span class="keyword">this</span>.scanner.addExcludeFilter(<span class="keyword">new</span> ClassExcludeFilter(sources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234712.png"></p><p>先记住上面的三个属性，上面三个属性在，BeanDefinition的Resource定位，和BeanDefinition的注册中起到了很重要的作用。</p><h5 id="loader-load"><a href="#loader-load" class="headerlink" title="loader.load();"></a>loader.load();</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line">		<span class="comment">// 从Class加载</span></span><br><span class="line">		<span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">			<span class="keyword">return</span> load((Class&lt;?&gt;) source);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从Resource加载</span></span><br><span class="line">		<span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) &#123;</span><br><span class="line">			<span class="keyword">return</span> load((Resource) source);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从Package加载</span></span><br><span class="line">		<span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) &#123;</span><br><span class="line">			<span class="keyword">return</span> load((Package) source);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从 CharSequence 加载 ？？？</span></span><br><span class="line">		<span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">			<span class="keyword">return</span> load((CharSequence) source);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid source type &quot;</span> + source.getClass());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;</span><br><span class="line">			<span class="comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span></span><br><span class="line">			GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">			load(loader);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isComponent(source)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.annotatedReader.register(source);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>当前我们的主类会按Class加载</p><p>isComponent(source)判断主类是不是存在@Component注解，主类@SpringBootApplication是一个组合注解，包含@Component。<br>this.annotatedReader.register(source);跟进register()方法，最终进到AnnotatedBeanDefinitionReader类的doRegisterBean()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将指定的类 封装为AnnotatedGenericBeanDefinition	</span></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line">    	<span class="comment">// 获取该类的 scope 属性</span></span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">		<span class="comment">// 将该BeanDefinition注册到IoC容器的beanDefinitionMap中</span></span><br><span class="line">    	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>在该方法中将主类封装成AnnotatedGenericBeanDefinition</p><p>BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);方法将BeanDefinition注册进beanDefinitionMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">	String beanName = definitionHolder.getBeanName();</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">	String[] aliases = definitionHolder.getAliases();</span><br><span class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 最后一次校验了</span></span><br><span class="line">			<span class="comment">// 对bean的Overrides进行校验，还不知道会在哪处理这些overrides</span></span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断是否存在重复名字的bean，之后看允不允许override</span></span><br><span class="line">	<span class="comment">// 以前使用synchronized实现互斥访问，现在采用ConcurrentHashMap</span></span><br><span class="line">	BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果该类不允许 Overriding 直接抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">//注册进beanDefinitionMap</span></span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">               <span class="comment">//如果仍处于启动注册阶段，注册进beanDefinitionMap</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234836.png"></p><p>最终来到DefaultListableBeanFactory类的registerBeanDefinition()方法，DefaultListableBeanFactory类还熟悉吗？相信大家一定非常熟悉这个类了。</p><p>DefaultListableBeanFactory是IoC容器的具体产品。</p><p>仔细看这个方法registerBeanDefinition()，首先会检查是否已经存在，如果存在并且不允许被覆盖则直接抛出异常。不存在的话就直接注册进beanDefinitionMap中。</p><p>debug跳过prepareContext()方法，可以看到，启动类的BeanDefinition已经注册进来了。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224234908.png"></p><h4 id="第五步：刷新应用上下文（IOC容器的初始化过程）"><a href="#第五步：刷新应用上下文（IOC容器的初始化过程）" class="headerlink" title="第五步：刷新应用上下文（IOC容器的初始化过程）"></a>第五步：刷新应用上下文（IOC容器的初始化过程）</h4><p>IOC容器的初始化过程，主要分下面三步</p><ol><li>BeanDefinition的Resource定位</li><li>BeanDefinition的载入</li><li>向IoC容器注册BeanDefinition</li></ol><p>主要从refresh()方法中总结IoC容器的初始化过程。</p><p>从run方法的，refreshContext()方法一路跟下去，最终来到AbstractApplicationContext类的refresh()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            <span class="comment">//刷新上下文环境</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            <span class="comment">//这里是在子类中启动 refreshBeanFactory() 的地方</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            <span class="comment">//准备bean工厂，以便在此上下文中使用</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                <span class="comment">//设置 beanFactory 的后置处理</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                <span class="comment">//调用 BeanFactory 的后处理器，这些处理器是在Bean 定义中向容器注册的</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                /注册Bean的后处理器，在Bean创建过程中调用</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                <span class="comment">//对上下文中的消息源进行初始化</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                <span class="comment">//初始化上下文中的事件机制</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                <span class="comment">//初始化其他特殊的Bean</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                <span class="comment">//检查监听Bean并且将这些监听Bean向容器注册</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                <span class="comment">//实例化所有的（non-lazy-init）单件</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                <span class="comment">//发布容器事件，结束Refresh过程</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h5 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory();"></a>obtainFreshBeanFactory();</h5><p>在启动流程的第三步：初始化应用上下文。中我们创建了应用的上下文，并触发了GenericApplicationContext类的构造方法如下所示，创建了beanFactory，也就是创建了DefaultListableBeanFactory类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new GenericApplicationContext.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refresh</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		refreshBeanFactory();</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可知，在该方法中主要做了三个工作，刷新beanFactory，获取beanFactory，返回beanFactory。</p><p>首先看一下refreshBeanFactory()方法，跟下去来到GenericApplicationContext类的refreshBeanFactory()发现也没做什么。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do nothing: We hold a single internal BeanFactory and rely on callers</span></span><br><span class="line"><span class="comment"> * to register beans through our public methods (or the BeanFactory&#x27;s).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #registerBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TIPS:<br>1，AbstractApplicationContext类有两个子类实现了refreshBeanFactory()，但是在前面第三步初始化上下文的时候，实例化了GenericApplicationContext类，所以没有进入AbstractRefreshableApplicationContext中的refreshBeanFactory()方法。<br>2，this.refreshed.compareAndSet(false, true)这行代码在这里表示：GenericApplicationContext只允许刷新一次这行代码，很重要，不是在Spring中很重要，而是这行代码本身。首先看一下this.refreshed<br>属性：<br>private final AtomicBoolean refreshed = new AtomicBoolean();<br>java J.U.C并发包中很重要的一个原子类AtomicBoolean。通过该类的compareAndSet()方法<br>可以实现一段代码绝对只实现一次的功能。</p></blockquote><h5 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a>prepareBeanFactory(beanFactory)</h5><p>准备BeanFactory</p><h5 id="postProcessBeanFactory-beanFactory"><a href="#postProcessBeanFactory-beanFactory" class="headerlink" title="postProcessBeanFactory(beanFactory);"></a>postProcessBeanFactory(beanFactory);</h5><p>postProcessBeanFactory()方法向上下文中添加了一系列的Bean的后置处理器。后置处理器工作的时机是在所有的beanDenifition加载完成之后，bean实例化之前执行。简单来说Bean的后置处理器可以修改BeanDefinition的属性信息。</p><h5 id="invokeBeanFactoryPostProcessors-beanFactory-（重点）"><a href="#invokeBeanFactoryPostProcessors-beanFactory-（重点）" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory);（重点）"></a>invokeBeanFactoryPostProcessors(beanFactory);（重点）</h5><p>IoC容器的初始化过程包括三个步骤，在invokeBeanFactoryPostProcessors()方法中完成了IoC容器初始化过程的三个步骤</p><ol><li>第一步：Resource定位</li></ol><p>在SpringBoot中，我们都知道他的包扫描是从主类所在的包开始扫描的，prepareContext()方法中，会先将主类解析成BeanDefinition，然后在refresh()方法的invokeBeanFactoryPostProcessors()方法中解析主类的BeanDefinition获取basePackage的路径。这样就完成了定位的过程。其次SpringBoot的各种starter是通过SPI扩展机制实现的自动装配，SpringBoot的自动装配同样也是在invokeBeanFactoryPostProcessors()方法中实现的。还有一种情况，在SpringBoot中有很多的@EnableXXX注解，细心点进去看的应该就知道其底层是@Import注解，在invokeBeanFactoryPostProcessors()方法中也实现了对该注解指定的配置类的定位加载</p><p>常规的在SpringBoot中有三种实现定位，第一个是主类所在包的，第二个是SPI扩展机制实现的自动装配（比如各种starter），第三种就是@Import注解指定的类。（对于非常规的不说了）</p><ol start="2"><li>第二步：BeanDefinition的载入</li></ol><p>在第一步中说了三种Resource的定位情况，定位后紧接着就是BeanDefinition的分别载入。所谓的载入就是通过上面的定位得到的basePackage，SpringBoot会将该路径拼接成：</p><p>classpath:com/lagou/**/.class这样的形式，然后一个叫做xPathMatchingResourcePatternResolver的类会将该路径下所有的.class文件都加载进来，然后遍历判断是不是有@Component注解，如果有的话，就是我们要装载的BeanDefinition。大致过程就是这样的了。</p><blockquote><p>TIPS：<br>@Configuration，@Controller，@Service等注解底层都是@Component注解，只不过包装了一层罢了。</p></blockquote><h5 id="第三个过程：注册BeanDefinition"><a href="#第三个过程：注册BeanDefinition" class="headerlink" title="第三个过程：注册BeanDefinition"></a>第三个过程：注册BeanDefinition</h5><p>这个过程通过调用上文提到的BeanDefinitionRegister接口的实现来完成。这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册。通过上文的分析，我们可以看到，在IoC容器中将BeanDefinition注入到一个ConcurrentHashMap中，IoC容器就是通过这个HashMap来持有这些BeanDefinition数据的。比如DefaultListableBeanFactory 中的beanDefinitionMap属性。</p><p>最终来到ConfigurationClassParser中的<code>parse(Set&lt;BeanDefinitionHolder&gt; configCandidates)</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">		BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果是SpringBoot项目进来的，bd其实就是前面主类封装成的AnnotatedGenericBeanDefinition（AnnotatedBeanDefinition接口的实现类）</span></span><br><span class="line">			<span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">				parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235313.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConfigurationClassParser</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">		<span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">					existingClass.mergeImportedBy(configClass);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">				<span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">				<span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">				<span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">		SourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* 主要在这步处理 */</span></span><br><span class="line">			<span class="comment">//递归地处理配置类及其父类层次结构。</span></span><br><span class="line">			sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正对资源做解析的方法</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">			<span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">			<span class="comment">//首先递归处理内部类，（SpringBoot项目的主类一般没有内部类）</span></span><br><span class="line">			processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">		<span class="comment">// 针对 @PropertySource 注解的属性配置处理</span></span><br><span class="line">		<span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">				sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">				org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">				processPropertySource(propertySource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">						<span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">		<span class="comment">//根据 @ComponentScan 注解，扫描项目中的Bean（SpringBoot 启动类上有该注解）</span></span><br><span class="line">		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">		<span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">				!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">				<span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">				<span class="comment">// 立即执行扫描，（SpringBoot项目为什么是从主类所在的包扫描，这就是关键了）</span></span><br><span class="line">				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">						<span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">				<span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">				<span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">					<span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">						bdCand = holder.getBeanDefinition();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 检查是否是ConfigurationClass（是否有configuration/component两个注解），如果是，递归查找该类相关联的配置类。</span></span><br><span class="line">					<span class="comment">// 所谓相关的配置类，比如@Configuration中的@Bean定义的bean。或者在有@Component注解的类上继续存在@Import注解。</span></span><br><span class="line">					<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">						parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @Import annotations</span></span><br><span class="line">		<span class="comment">//递归处理 @Import 注解（SpringBoot项目中经常用的各种@Enable*** 注解基本都是封装的@Import）</span></span><br><span class="line">		processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">		AnnotationAttributes importResource =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">		<span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">			String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">				String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">				configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process individual @Bean methods</span></span><br><span class="line">		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">		<span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">			configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process default methods on interfaces</span></span><br><span class="line">		processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Process superclass, if any</span></span><br><span class="line">		<span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">			String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">			<span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">					!<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">				<span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">				<span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">				<span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>扫描标注了@ComponentScan 注解，读取注解的内容</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235359.png"></p><blockquote><p>TIPS:<br>在以上代码的parse(bdCand.getBeanClassName(), holder.getBeanName());会进行递归调用，<br>因为当Spring扫描到需要加载的类会进一步判断每一个类是否满足是@Component/@Configuration注解的类，如果满足会递归调用parse()方法，查找其相关的类。<br>同样的processImports(configClass, sourceClass, getImports(sourceClass),true);<br>通过@Import注解查找到的类同样也会递归查找其相关的类。<br>两个递归在debug的时候会很乱，用文字叙述起来更让人难以理解，所以，我们只关注对主类的解析，及其类的扫描过程。</p></blockquote><blockquote><p>上面代码中 for (AnnotationAttributes propertySource :<br>AnnotationConfigUtils.attributesForRepeatable(… 获取主类上的@PropertySource注解），解析该注解并将该注解指定的properties配置文件中的值存储到Spring的 Environment中，<br>Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值。<br>Set componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); 解析主类上的@ComponentScan注解，后面的代码将会解析该注解并进行包扫描。<br>processImports(configClass, sourceClass, getImports(sourceClass), true); 解析主类上的@Import注解，并加载该注解指定的配置类。</p></blockquote><blockquote><p>TIPS:<br>在spring中好多注解都是一层一层封装的，比如@EnableXXX，是对@Import注解的二次封装。<br>@SpringBootApplication注解=@ComponentScan+@EnableAutoConfiguration+@Import+@Configuration+@Component。<br>@Controller，@Service等等是对@Component的二次封装。</p></blockquote><p><code>org.springframework.context.annotation.ComponentScanAnnotationParser#parse</code> 解析@ComponentScan标注的注解内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> </span>&#123;</span><br><span class="line">	ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>.registry,</span><br><span class="line">			componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 根据 declaringClass （如果是SpringBoot项目，则参数为主类的全路径名）</span></span><br><span class="line">	<span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">		basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scanner.addExcludeFilter(<span class="keyword">new</span> AbstractTypeHierarchyTraversingFilter(<span class="keyword">false</span>, <span class="keyword">false</span>) &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 根据basePackages扫描类</span></span><br><span class="line">	<span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235509.png"></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235524.png"></p><blockquote><p>TIPS:<br>为什么只有一个还要用一个集合呢，因为我们也可以用@ComponentScan注解指定扫描路径。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">		<span class="comment">// 从指定的包中扫描需要装载的Bean</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">			ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">			String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">				BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">				definitionHolder =</span><br><span class="line">						AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">				beanDefinitions.add(definitionHolder);</span><br><span class="line">				<span class="comment">//将该 Bean 注册进 IoC容器（beanDefinitionMap）</span></span><br><span class="line">				registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan the class path for candidate components.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePackage the package to check for annotated classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a corresponding Set of autodetected bean definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">		<span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">	Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//拼接扫描路径，比如：classpath*:com/lagou/**/*.class</span></span><br><span class="line">		String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">				resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">		<span class="comment">//从 packageSearchPath 路径中扫描所有的类</span></span><br><span class="line">		Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">		<span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">		<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">		<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">			<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">					<span class="comment">// //判断该类是不是 @Component 注解标注的类，并且不是需要排除掉的类</span></span><br><span class="line">					<span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">						<span class="comment">//将该类封装成ScannedGenericBeanDefinition（BeanDefinition接口的实现类）类</span></span><br><span class="line">						ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">						sbd.setSource(resource);</span><br><span class="line">						<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">							<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">								logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">							&#125;</span><br><span class="line">							candidates.add(sbd);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">								logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">							logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">							<span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Ignored because not readable: &quot;</span> + resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的三个方法经过层级调用，doScan方法第7行 Set candidates =findCandidateComponents(basePackage); 从basePackage中扫描类并解析成BeanDefinition，拿到所有符合条件的类后在第24行 registerBeanDefinition(definitionHolder, this.registry); 将该类注册进IoC容器。也就是说在这个方法中完成了IoC容器初始化过程的第二三步，BeanDefinition的载入，和BeanDefinition的注册。</p><p>scanCandidateComponents行将basePackage拼接成classpath:org/springframework/boot/demo/**/.class，在第16行的getResources(packageSearchPath);方法中扫描到了该路径下的所有的类。然后遍历这些</p><p>Resources，isCandidateComponent判断该类是不是 @Component 注解标注的类，并且不是需要排除掉的类。在第29行将扫描到的类，解析成ScannedGenericBeanDefinition，该类是BeanDefinition接口的实现类。OK，IoC容器的BeanDefinition载入到这里就结束了。</p><p>回到前面的doScan()方法，debug看一下结果（截图中所示的就是定位的需要交给Spring容器管理的类。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235615.png"></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235836.png"></p><h5 id="registerBeanDefinition-definitionHolder-this-registry"><a href="#registerBeanDefinition-definitionHolder-this-registry" class="headerlink" title="registerBeanDefinition(definitionHolder, this.registry);"></a>registerBeanDefinition(definitionHolder, this.registry);</h5><p>查看registerBeanDefinition()方法。是不是有点眼熟，在前面介绍prepareContext()方法时，我们详细介绍了主类的BeanDefinition是怎么一步一步的注册进DefaultListableBeanFactory的beanDefinitionMap中的。完成了BeanDefinition的注册，就完成了IoC容器的初始化过程。此时，在使用的IoC容器DefaultListableFactory中已经建立了整个Bean的配置信息，而这些BeanDefinition已经可以被容器使用了。他们都在BeanbefinitionMap里被检索和使用。容器的作用就是对这些信息进行处理和维护。这些信息是容器简历依赖反转的基础。</p><p>OK，到这里IoC容器的初始化过程的三个步骤就梳理完了。当然这只是针对SpringBoot的包扫描的定位方式的BeanDefinition的定位，加载，和注册过程。前面我们说过，还有两种方式@Import和SPI扩展实现的starter的自动装配。</p><h5 id="Import注解的解析过程"><a href="#Import注解的解析过程" class="headerlink" title="@Import注解的解析过程"></a>@Import注解的解析过程</h5><p>现在大家也应该知道了，各种@EnableXXX注解，很大一部分都是对@Import的二次封装（其实也是为了解耦，比如当@Import导入的类发生变化时，我们的业务系统也不需要改任何代码）。我们又要回到上文中的ConfigurationClassParser类的doProcessConfigurationClass方法的processImports(configClass, sourceClass, getImports(sourceClass), true);，跳跃性比较大。上面解释过，我们只针对主类进行分析，因为这里有递归。processImports(configClass, sourceClass, getImports(sourceClass), true);中configClass和sourceClass参数都是主类相对应的。首先看getImports(sourceClass)；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> <span class="doctag">@Import</span>&#125; class, considering all meta-annotations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;SourceClass&gt; <span class="title">getImports</span><span class="params">(SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	Set&lt;SourceClass&gt; imports = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	Set&lt;SourceClass&gt; visited = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	collectImports(sourceClass, imports, visited);</span><br><span class="line">	<span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/20220224235923.png"></p><p>主类上的@SpringBootApplication中的@Import注解指定的类记下来再回到ConfigurationClassParser类的parse(Set configCandidates)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">		BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">				parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点进process方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="keyword">this</span>.deferredImportSelectors;</span><br><span class="line">    <span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferredImports != <span class="keyword">null</span>) &#123;</span><br><span class="line">            DeferredImportSelectorGroupingHandler handler = <span class="keyword">new</span> DeferredImportSelectorGroupingHandler();</span><br><span class="line">            deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);</span><br><span class="line">            deferredImports.forEach(handler::register);</span><br><span class="line">            <span class="comment">// 继续点击进去</span></span><br><span class="line">            handler.processGroupImports();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续点击handler.processGroupImports();</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processGroupImports</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredImportSelectorGrouping grouping : <span class="keyword">this</span>.groupings.values()) &#123;</span><br><span class="line">        Predicate&lt;String&gt; exclusionFilter = grouping.getCandidateFilter();</span><br><span class="line">        <span class="comment">// 查看调用的getImports</span></span><br><span class="line">        grouping.getImports().forEach(entry -&gt; &#123;</span><br><span class="line">            ConfigurationClass configurationClass = <span class="keyword">this</span>.configurationClasses.get(entry.getMetadata());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processImports(configurationClass,</span><br><span class="line">                               asSourceClass(configurationClass, exclusionFilter),</span><br><span class="line">                               Collections.singleton(asSourceClass(entry.getImportClassName(),</span><br><span class="line">                                                                   exclusionFilter)),</span><br><span class="line">                               exclusionFilter, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">                    configurationClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 是不是很熟悉了</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="keyword">this</span>.deferredImports) &#123;</span><br><span class="line">        <span class="comment">// 调用了process方法</span></span><br><span class="line">        <span class="keyword">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">                           deferredImport.getImportSelector());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.group.selectImports();</span><br><span class="line">&#125;                  </span><br></pre></td></tr></table></figure><p>再次进入org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.AutoConfigurationGroup#process</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                    DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">    Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">                 () -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">                                     AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">                                     deferredImportSelector.getClass().getName()));</span><br><span class="line">    <span class="comment">// 【1】调用getAutoConfigurationEntry方法得到自动配置类放入autoConfigurationEntry对象中</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry =</span><br><span class="line">        ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">        .getAutoConfigurationEntry(getAutoConfigurationMetadata(),</span><br><span class="line">                                   annotationMetadata);</span><br><span class="line">    <span class="comment">// 【2】又将封装了自动配置类的autoConfigurationEntry对象装进autoConfigurationEntries集合</span></span><br><span class="line">    <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">    <span class="comment">// 【3】遍历刚获取的自动配置类</span></span><br><span class="line">    <span class="keyword">for</span> (String importClassName :</span><br><span class="line">         autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">        <span class="comment">// 这里符合条件的自动配置类作为key，annotationMetadata作为值放进entries集合</span></span><br><span class="line">        <span class="keyword">this</span>.entries.putIfAbsent(importClassName,</span><br><span class="line">                                 annotationMetadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第六步：刷新应用上下文后的扩展接口"><a href="#第六步：刷新应用上下文后的扩展接口" class="headerlink" title="第六步：刷新应用上下文后的扩展接口"></a>第六步：刷新应用上下文后的扩展接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展接口，设计模式中的模板方法，默认为空实现。如果有自定义需求，可以重写该方法。比如打印一些启动结束log，或者一些其它后置处理。</p><blockquote><p>参考<br><a target="_blank" rel="noopener" href="https://www.yuque.com/biubiubiu-om1zk/gxdplc/yug8w4">SpirngBoot启动过程分析 · 语雀 (yuque.com)</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/08/15/SpringBoot%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://lemon-cs.github.io/2020/08/15/SpringBoot%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://s4.ax1x.com/2022/02/15/HRSzD0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/16/SpringBoot%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89Starter/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot之自定义Starter-3</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/10/SpringBoot%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2021/12/adda988fb50270fe.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot之基础回顾-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/12/25/SpringBoot-1-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="SpringBoot-1.x学习笔记"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/21be22e888bfda1d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-25</div><div class="title">SpringBoot-1.x学习笔记</div></div></a></div><div><a href="/2020/08/17/SpringBoot%E4%B9%8B%E5%86%85%E5%B5%8CTomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="SpringBoot之内嵌Tomcat源码分析-4"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-17</div><div class="title">SpringBoot之内嵌Tomcat源码分析-4</div></div></a></div><div><a href="/2020/08/10/SpringBoot%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="SpringBoot之基础回顾-1"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/adda988fb50270fe.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="title">SpringBoot之基础回顾-1</div></div></a></div><div><a href="/2019/12/25/SpringBoot-2-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="SpringBoot-2.0学习笔记"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-25</div><div class="title">SpringBoot-2.0学习笔记</div></div></a></div><div><a href="/2020/08/18/SpringBoot%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AESpringMVC/" title="SpringBoot之自动配置SpringMVC-5"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-18</div><div class="title">SpringBoot之自动配置SpringMVC-5</div></div></a></div><div><a href="/2020/08/20/SpringBoot%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/" title="SpringBoot之数据访问-6"><img class="cover" src="https://s4.ax1x.com/2022/02/15/HRptqP.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-20</div><div class="title">SpringBoot之数据访问-6</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2. SpringBoot源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">2.1 源码分析-依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9Aspringboot%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="toc-text">1. 问题一：springboot为什么不需要指定版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-spring-boot-starter-parent%E7%88%B6%E4%BE%9D%E8%B5%96%E5%90%AF%E5%8A%A8%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%EF%BC%8C%E9%82%A3%E4%B9%88%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E4%BE%9D%E8%B5%96%E7%9A%84JAR%E5%8C%85%E6%98%AF%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="toc-text">2. spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运行依赖的JAR包是从何而来的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2.2 源码分析-自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SpringBootApplication"><span class="toc-text">1. @SpringBootApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SpringBootConfiguration"><span class="toc-text">2. @SpringBootConfiguration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-EnableAutoConfiguration"><span class="toc-text">3. @EnableAutoConfiguration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AutoConfigurationPackage"><span class="toc-text">4. @AutoConfigurationPackage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Import-AutoConfigurationImportSelector-class"><span class="toc-text">5. @Import(AutoConfigurationImportSelector.class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ComponentScan"><span class="toc-text">6. @ComponentScan</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Run%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.3 源码分析-Run方法执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84mian%E5%87%BD%E6%95%B0"><span class="toc-text">1. SpringBoot项目的mian函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SpringApplication-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">2. SpringApplication() 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deduceWebApplicationType"><span class="toc-text">deduceWebApplicationType();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setInitializers-Collection-getSpringFactoriesInstances-ApplicationContextInitializer-class"><span class="toc-text">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setListeners-Collection-getSpringFactoriesInstances-ApplicationListener-class"><span class="toc-text">setListeners((Collection)getSpringFactoriesInstances(ApplicationListener.class));</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-run-args"><span class="toc-text">3. run(args)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%90%AF%E5%8A%A8%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">第一步：获取并启动监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%9E%84%E9%80%A0%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83"><span class="toc-text">第二步：构造应用上下文环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConfigurableEnvironment-environment-getOrCreateEnvironment"><span class="toc-text">ConfigurableEnvironment environment &#x3D; getOrCreateEnvironment()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#configureEnvironment-environment-applicationArguments-getSourceArgs"><span class="toc-text">configureEnvironment(environment, applicationArguments.getSourceArgs());</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#listeners-environmentPrepared-environment"><span class="toc-text">listeners.environmentPrepared(environment);</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">第三步：初始化应用上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%88%B7%E6%96%B0%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-text">第四步：刷新应用上下文前的准备阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#prepareContext-%E6%96%B9%E6%B3%95"><span class="toc-text">prepareContext()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getBeanDefinitionRegistry"><span class="toc-text">getBeanDefinitionRegistry()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#createBeanDefinitionLoader"><span class="toc-text">createBeanDefinitionLoader()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#loader-load"><span class="toc-text">loader.load();</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%88%B7%E6%96%B0%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-text">第五步：刷新应用上下文（IOC容器的初始化过程）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#obtainFreshBeanFactory"><span class="toc-text">obtainFreshBeanFactory();</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#prepareBeanFactory-beanFactory"><span class="toc-text">prepareBeanFactory(beanFactory)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#postProcessBeanFactory-beanFactory"><span class="toc-text">postProcessBeanFactory(beanFactory);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#invokeBeanFactoryPostProcessors-beanFactory-%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">invokeBeanFactoryPostProcessors(beanFactory);（重点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%9A%E6%B3%A8%E5%86%8CBeanDefinition"><span class="toc-text">第三个过程：注册BeanDefinition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#registerBeanDefinition-definitionHolder-this-registry"><span class="toc-text">registerBeanDefinition(definitionHolder, this.registry);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">@Import注解的解析过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AD%A5%EF%BC%9A%E5%88%B7%E6%96%B0%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E5%90%8E%E7%9A%84%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-text">第六步：刷新应用上下文后的扩展接口</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现"><img src="https://s3.bmp.ovh/imgs/2021/12/2de6481e0a4697bf.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="跳表原理及实现"></a><div class="content"><a class="title" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="跳表原理及实现">跳表原理及实现</a><time datetime="2022-02-07T13:19:43.000Z" title="发表于 2022-02-07 21:19:43">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2022/01/17/%E5%90%8E%E7%AB%AF-Golang-Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2022-01-17T14:09:50.000Z" title="发表于 2022-01-17 22:09:50">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/08/%E5%90%8E%E7%AB%AF-Golang-Go%E5%AE%9E%E7%8E%B0-Go%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%93%E5%AD%98/" title="Go实现简单的带过期机制的缓存"><img src="https://s3.bmp.ovh/imgs/2021/12/a560e450dd631e8f.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go实现简单的带过期机制的缓存"></a><div class="content"><a class="title" href="/2022/01/08/%E5%90%8E%E7%AB%AF-Golang-Go%E5%AE%9E%E7%8E%B0-Go%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%B8%A6%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%93%E5%AD%98/" title="Go实现简单的带过期机制的缓存">Go实现简单的带过期机制的缓存</a><time datetime="2022-01-08T03:37:35.000Z" title="发表于 2022-01-08 11:37:35">2022-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/" title="Go语言基础之反射"><img src="https://static01.imgkr.com/temp/67e21ea4f0cb464cb52de4d60aad3962.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之反射"></a><div class="content"><a class="title" href="/2022/01/04/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/" title="Go语言基础之反射">Go语言基础之反射</a><time datetime="2022-01-04T03:37:35.000Z" title="发表于 2022-01-04 11:37:35">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/03/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/" title="Go语言基础之包管理"><img src="https://static01.imgkr.com/temp/b3efa980b23a40ad90a8f7739a0574da.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言基础之包管理"></a><div class="content"><a class="title" href="/2022/01/03/%E5%90%8E%E7%AB%AF-Golang-Go%E5%9F%BA%E7%A1%80-Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86/" title="Go语言基础之包管理">Go语言基础之包管理</a><time datetime="2022-01-03T03:37:35.000Z" title="发表于 2022-01-03 11:37:35">2022-01-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>