<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Nginx入门学习笔记 | Lemon-CS</title><meta name="keywords" content="Nginx"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Nginx学习笔记和配置实战"><meta property="og:type" content="article"><meta property="og:title" content="Nginx入门学习笔记"><meta property="og:url" content="https://lemon-cs.github.io/2020/04/29/Nginx%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="Nginx学习笔记和配置实战"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg"><meta property="article:published_time" content="2020-04-29T06:42:56.000Z"><meta property="article:modified_time" content="2021-12-31T07:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="Nginx"><meta property="article:tag" content="反向代理"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/04/29/Nginx%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Nginx入门学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-31 15:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Nginx入门学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-29T06:42:56.000Z" title="发表于 2020-04-29 14:42:56">2020-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-31T07:37:35.000Z" title="更新于 2021-12-31 15:37:35">2021-12-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Nginx入门学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Nginx学习笔记"><a href="#Nginx学习笔记" class="headerlink" title="Nginx学习笔记"></a>Nginx学习笔记</h1><h2 id="1-什么是Nginx？"><a href="#1-什么是Nginx？" class="headerlink" title="1-什么是Nginx？"></a>1-什么是Nginx？</h2><p><strong>Nginx (engine x)</strong> 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p><p>Nginx因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是Apache2.2＋mod_proxy_balancer的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到Apache的近2/3。对proxy和rewrite模块的支持很彻底，还支持mod_fcgi、ssl、vhosts ，适合用来做mongrel clusters的前端HTTP响应。<br>Nginx和Apache一样使用模块化设计，nginx模块包括内置模块和第三方模块，其中内置模块中包含主模块和事件模块。</p><p><strong>Nginx处理请求逻辑图</strong></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/20190511170603322.png"></p><h2 id="2-正向代理和反向代理"><a href="#2-正向代理和反向代理" class="headerlink" title="2-正向代理和反向代理"></a>2-正向代理和反向代理</h2><h3 id="2-1-什么是正向代理？"><a href="#2-1-什么是正向代理？" class="headerlink" title="2.1-什么是正向代理？"></a>2.1-什么是正向代理？</h3><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p><ul><li>客户端请求目标服务器之间的代理服务器</li><li>请求会先经过代理服务器，然后再转发请求到目标服务器，获得内容后，最后再响应给客户端</li></ul><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png"></p><h3 id="2-2-什么是反向代理？"><a href="#2-2-什么是反向代理？" class="headerlink" title="2.2-什么是反向代理？"></a>2.2-什么是反向代理？</h3><p>反向代理，客户端是无感知代理的存在，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。</p><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><strong>作用：</strong></p><ul><li>保证内网的安全，公网作为访问地址，web服务器谁内网；</li><li>负载均衡</li></ul><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png"></p><h2 id="3-Nginx的作用"><a href="#3-Nginx的作用" class="headerlink" title="3-Nginx的作用"></a>3-Nginx的作用</h2><h3 id="3-1-Nginx可以提供的服务"><a href="#3-1-Nginx可以提供的服务" class="headerlink" title="3.1-Nginx可以提供的服务"></a>3.1-Nginx可以提供的服务</h3><ul><li><p><strong>正向代理</strong></p></li><li><p><strong>反向代理</strong></p></li><li><p><strong>HTTP服务器</strong></p><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器。</p><p>现在很多项目流行前后分离，也就是前端服务器和后端服务器分离，分别部署，这样的方式能让前后端人员能各司其职，不需要互相依赖，而前后分离中，前端项目的运行是不需要用Tomcat、Apache等服务器环境的，因此可以直接用nginx来作为静态服务器。</p></li><li><p><strong>负载均衡</strong></p><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，<strong>负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡</strong>。</p></li></ul><h3 id="3-2-Nginx的优点"><a href="#3-2-Nginx的优点" class="headerlink" title="3.2-Nginx的优点"></a>3.2-Nginx的优点</h3><ol><li>高并发。静态小文件</li><li>占用资源少。2万并发、10个线程，内存消耗几百M。</li><li>功能种类比较多。web,cache,proxy。每一个功能都不是特别强。</li><li>支持epoll模型，使得nginx可以支持高并发。</li><li>nginx 配合动态服务和Apache有区别。（FASTCGI 接口）</li><li>利用nginx可以对IP限速，可以限制连接数。</li><li>配置简单，更灵活。</li></ol><h2 id="4-Nginx的安装与使用"><a href="#4-Nginx的安装与使用" class="headerlink" title="4-Nginx的安装与使用"></a>4-Nginx的安装与使用</h2><h3 id="4-1-Nginx的安装"><a href="#4-1-Nginx的安装" class="headerlink" title="4.1-Nginx的安装"></a>4.1-Nginx的安装</h3><p>详细安装方法请参考：</p><blockquote><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/nginx-tutorial/blob/master/docs/nginx-ops.md">https://github.com/dunwu/nginx-tutorial/blob/master/docs/nginx-ops.md</a></p></blockquote><h3 id="4-2-Nginx的使用"><a href="#4-2-Nginx的使用" class="headerlink" title="4.2-Nginx的使用"></a>4.2-Nginx的使用</h3><p>nginx 的使用比较简单，就是几条命令。</p><p>常用到的命令如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">nginx</span> <span class="string">-s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-s reopen     重新打开日志文件。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-t            不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-v            显示 nginx 的版本。</span></span><br><span class="line"><span class="attr">nginx</span> <span class="string">-V            显示 nginx 的版本，编译器版本和配置参数。</span></span><br></pre></td></tr></table></figure><p>如果不想每次都敲命令，可以在 nginx 安装目录下新添一个启动批处理文件<strong>startup.bat</strong>，双击即可运行。内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">@echo</span> <span class="string">off</span></span><br><span class="line"><span class="attr">rem</span> <span class="string">如果启动前已经启动nginx并记录下pid文件，会kill指定进程</span></span><br><span class="line"><span class="meta">nginx.exe</span> <span class="string">-s stop</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rem</span> <span class="string">测试配置文件语法正确性</span></span><br><span class="line"><span class="meta">nginx.exe</span> <span class="string">-t -c conf/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rem</span> <span class="string">显示版本信息</span></span><br><span class="line"><span class="meta">nginx.exe</span> <span class="string">-v</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rem</span> <span class="string">按照指定配置去启动nginx</span></span><br><span class="line"><span class="meta">nginx.exe</span> <span class="string">-c conf/nginx.conf</span></span><br></pre></td></tr></table></figure><p>如果是运行在 Linux 下，写一个 shell 脚本，大同小异。</p><h2 id="5-Nginx配置实战"><a href="#5-Nginx配置实战" class="headerlink" title="5-Nginx配置实战"></a>5-Nginx配置实战</h2><h3 id="5-1-http-反向代理配置"><a href="#5-1-http-反向代理配置" class="headerlink" title="5.1-http 反向代理配置"></a>5.1-http 反向代理配置</h3><p>nginx.conf 配置文件如下：<br><strong>注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行用户</span></span><br><span class="line"><span class="comment">#user somebody;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#启动进程,通常设置成和cpu的数量相等</span></span><br><span class="line"><span class="attr">worker_processes</span>  <span class="string">1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#全局错误日志</span></span><br><span class="line"><span class="attr">error_log</span>  <span class="string">D:/Tools/nginx-1.10.1/logs/error.log;</span></span><br><span class="line"><span class="attr">error_log</span>  <span class="string">D:/Tools/nginx-1.10.1/logs/notice.log  notice;</span></span><br><span class="line"><span class="attr">error_log</span>  <span class="string">D:/Tools/nginx-1.10.1/logs/info.log  info;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#PID文件，记录当前启动的nginx的进程ID</span></span><br><span class="line"><span class="attr">pid</span>        <span class="string">D:/Tools/nginx-1.10.1/logs/nginx.pid;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#工作模式及连接数上限</span></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">		<span class="attr">use</span> <span class="string">epoll;    #默认使用epoll</span></span><br><span class="line">    <span class="attr">worker_connections</span> <span class="string">1024;    #单个后台worker process进程的最大并发链接数</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #设定mime类型(邮件支持类型),类型由mime.types文件定义</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">D:/Tools/nginx-1.10.1/conf/mime.types;</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #设定日志</span></span><br><span class="line">    <span class="attr">log_format</span>  <span class="string">main  &#x27;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="meta">&#x27;$status</span> <span class="string">$body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="meta">&#x27;&quot;$http_user_agent&quot;</span> <span class="string">&quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">access_log</span>    <span class="string">D:/Tools/nginx-1.10.1/logs/access.log main;</span></span><br><span class="line">    <span class="attr">rewrite_log</span>     <span class="string">on;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，</span></span><br><span class="line"><span class="comment">    #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on;</span></span><br><span class="line"><span class="comment">    #tcp_nopush     on;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #连接超时时间</span></span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">120;</span></span><br><span class="line">    <span class="attr">tcp_nodelay</span>        <span class="string">on;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #gzip压缩开关</span></span><br><span class="line"><span class="comment">    #gzip  on;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #设定实际的服务器列表</span></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">zp_server1&#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">127.0.0.1:8089;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #HTTP服务器</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">        #监听80端口，80端口是知名端口号，用于HTTP协议</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #定义使用www.xx.com访问</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">www.helloworld.com;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #首页</span></span><br><span class="line">        <span class="attr">index</span> <span class="string">index.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #指向webapp的目录</span></span><br><span class="line">        <span class="attr">root</span> <span class="string">D:\01_Workspace\Project\github\zp\SpringNotes\spring-security\spring-shiro\src\main\webapp;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #编码格式</span></span><br><span class="line">        <span class="attr">charset</span> <span class="string">utf-8;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #代理配置参数</span></span><br><span class="line">        <span class="attr">proxy_connect_timeout</span> <span class="string">180;</span></span><br><span class="line">        <span class="attr">proxy_send_timeout</span> <span class="string">180;</span></span><br><span class="line">        <span class="attr">proxy_read_timeout</span> <span class="string">180;</span></span><br><span class="line">        <span class="attr">proxy_set_header</span> <span class="string">Host $host;</span></span><br><span class="line">        <span class="attr">proxy_set_header</span> <span class="string">X-Forwarder-For $remote_addr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #反向代理的路径（和upstream绑定），location 后面设置映射的路径</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://zp_server1;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #静态文件，nginx自己处理</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span></span><br><span class="line">            <span class="attr">root</span> <span class="string">D:\01_Workspace\Project\github\zp\SpringNotes\spring-security\spring-shiro\src\main\webapp\views;</span></span><br><span class="line"><span class="comment">            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span></span><br><span class="line">            <span class="attr">expires</span> <span class="string">30d;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #设定查看Nginx状态的地址</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/NginxStatus &#123;</span></span><br><span class="line">            <span class="attr">stub_status</span>           <span class="string">on;</span></span><br><span class="line">            <span class="attr">access_log</span>            <span class="string">on;</span></span><br><span class="line">            <span class="attr">auth_basic</span>            <span class="string">&quot;NginxStatus&quot;;</span></span><br><span class="line">            <span class="attr">auth_basic_user_file</span>  <span class="string">conf/htpasswd;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #禁止访问 .htxxx 文件</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">~ /\.ht &#123;</span></span><br><span class="line">            <span class="attr">deny</span> <span class="string">all;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #错误处理页面（可选择性配置）</span></span><br><span class="line"><span class="comment">        #error_page   404              /404.html;</span></span><br><span class="line"><span class="comment">        #error_page   500 502 503 504  /50x.html;</span></span><br><span class="line"><span class="comment">        #location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">        #    root   html;</span></span><br><span class="line"><span class="comment">        #&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>启动 webapp，注意启动绑定的端口要和 nginx 中的 <code>upstream</code> 设置的端口保持一致。</li><li>更改 host：在 C:\Windows\System32\drivers\etc 目录下的 host 文件中添加一条 DNS 记录</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 www.helloworld.com</span><br></pre></td></tr></table></figure><ol start="3"><li>启动前文中 startup.bat 的命令</li><li>在浏览器中访问 <code>www.helloworld.com</code>，不出意外，已经可以访问了。</li></ol><h3 id="5-2-Nginx跨域解决方案"><a href="#5-2-Nginx跨域解决方案" class="headerlink" title="5.2-Nginx跨域解决方案"></a>5.2-Nginx跨域解决方案</h3><p><strong>为什么会有跨域问题？</strong></p><p>浏览器的同源策略拒绝了我们的请求。 所谓同源是指，域名，协议，端口相同，浏览器执行一个脚本时同源的脚本才会被执行。如果非同源，那么在请求数据时，浏览器会在控制台中报上面的异常，提示拒绝访问。这是为了同一浏览器打开多个网站时，保护你的A网站登陆信息不被B网站拿去访问A网站，B网站登陆信息同理。</p><p>web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。如果项目没做前后端分离，是不会有跨域问题的。前后端分离的项目中，前端调用后台服务时，报错 <code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，你就是遇到了跨域问题。</p><p>各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路：</p><ol><li><p><strong>CORS</strong></p><p>在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 <code>Access-Control-Allow-Origin</code>中。</p></li><li><p><strong>jsonp</strong></p><p>把后端根据请求，构造 json 数据，并返回，前端用 jsonp 跨域。</p></li></ol><p><strong>需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案</strong>。</p><p><strong>举例：</strong></p><p><code>www.helloworld.com</code> 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。</p><p>前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line"><span class="comment">   # 检查域名后缀</span></span><br><span class="line">   <span class="attr">if</span> <span class="string">($http_origin ~ \.test\.com) &#123;</span></span><br><span class="line"><span class="comment">   			# 允许跨域请求的域，*代表所有，$http_origin动态获取请求客户端请求的域</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Origin $http_origin;</span></span><br><span class="line"><span class="comment">        # 允许请求的方法，比如 GET/POST/PUT/DELETE</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Methods GET,POST,OPTIONS;</span></span><br><span class="line"><span class="comment">        # 允许带上 cookie 请求</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Credentials true;</span></span><br><span class="line"><span class="comment">        # 允许请求的 header</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span></span><br><span class="line"><span class="comment">        # 预检命令的缓存，如果不缓存每次会发送两次请求</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Max-Age 1728000;</span></span><br><span class="line">   <span class="attr">&#125;</span></span><br><span class="line"><span class="comment">   # options请求不转给后端，直接返回204</span></span><br><span class="line"><span class="comment">   # 第二个if会导致上面的add_header无效，这是nginx的问题，这里直接重复执行下</span></span><br><span class="line">   <span class="attr">if</span> <span class="string">($request_method = OPTIONS) &#123;</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Origin $http_origin;</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Methods GET,POST,OPTIONS;</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Credentials true;</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;</span></span><br><span class="line">        <span class="attr">add_header</span> <span class="string">Access-Control-Max-Age 1728000;</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">204;</span></span><br><span class="line">   <span class="attr">&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">   # 其他请求代理到后端</span></span><br><span class="line">   <span class="attr">proxy_set_header</span> <span class="string">Host $host;</span></span><br><span class="line">   <span class="attr">proxy_redirect</span> <span class="string">off;</span></span><br><span class="line">   <span class="attr">proxy_set_header</span> <span class="string">X-Real-IP $remote_addr;</span></span><br><span class="line">   <span class="attr">proxy_set_header</span> <span class="string">X-Scheme $scheme;</span></span><br><span class="line">   <span class="attr">proxy_set_header</span> <span class="string">X-Forwarded-For $proxy_add_x_forwarded_for;</span></span><br><span class="line">   <span class="attr">proxy_set_header</span> <span class="string">X-Forwarded-Proto $scheme;</span></span><br><span class="line">   <span class="attr">proxy_pass</span> <span class="string">http://xxx.xxx.xxx.xxx;</span></span><br><span class="line"><span class="meta">&#125;</span> <span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="1-Access-Control-Allow-Origin"><a href="#1-Access-Control-Allow-Origin" class="headerlink" title="1. Access-Control-Allow-Origin"></a>1. <strong>Access-Control-Allow-Origin</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器默认是不被允许跨域的。给Nginx服务器配置`Access-Control-Allow-Origin *`后，表示服务器可以接受所有的请求源（Origin）,即接受所有跨域的请求。</span><br></pre></td></tr></table></figure><h4 id="2-Access-Control-Allow-Headers-是为了防止出现以下错误："><a href="#2-Access-Control-Allow-Headers-是为了防止出现以下错误：" class="headerlink" title="2. Access-Control-Allow-Headers 是为了防止出现以下错误："></a>2. <strong>Access-Control-Allow-Headers</strong> 是为了防止出现以下错误：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</span><br></pre></td></tr></table></figure><p>这个错误表示当前请求Content-Type的值不被支持。其实是我们发起了”application/json”的类型请求导致的。这里涉及到一个概念：<code>预检请求（preflight request）</code>,请看下面”预检请求”的介绍。</p><h4 id="3-Access-Control-Allow-Methods-是为了防止出现以下错误："><a href="#3-Access-Control-Allow-Methods-是为了防止出现以下错误：" class="headerlink" title="3. Access-Control-Allow-Methods 是为了防止出现以下错误："></a>3. <strong>Access-Control-Allow-Methods</strong> 是为了防止出现以下错误：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</span><br></pre></td></tr></table></figure><h4 id="4-给OPTIONS-添加-204的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误"><a href="#4-给OPTIONS-添加-204的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误" class="headerlink" title="4.给OPTIONS 添加 204的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误"></a>4.给<code>OPTIONS</code> 添加 <code>204</code>的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误</h4><p>发送”预检请求”时，需要用到方法 <code>OPTIONS</code> ,所以服务器需要允许该方法。</p><h3 id="5-3-Nginx防盗链"><a href="#5-3-Nginx防盗链" class="headerlink" title="5.3-Nginx防盗链"></a>5.3-Nginx防盗链</h3><p>防盗链的意义在于防止网站中的文件链接在其他网站中被使用，盗链的文件或图片在其他网站中加载，在这个过程中，实质上加载的请求是被盗链服务器上响应的，这就造成了一些不正常流量(并非自己网站的正常打开页面加载的处理请求)造成了消耗不必要的带宽。</p><p>要实现防盗链，需要了解HTTP协议中的请求头部的Referer头域和采用URL的格式表示访问当前网页或者文件的源地址。通过该头域的值，我们可以检测到访问目标资源的源地址。这样，如果我们检测到Referer(rui’fe~)头域中的值并不是自己站点内的URL，就采取组织措施，实现防盗链。</p><p>nginx防盗链使用到了valid_referers这个名单定义项(相当是定义白名单域名，如需定义多个域名使用空格分隔，非这里定义的域名会在转跳中返回403状态码)，if中定义：非名单里里的域名可以定义返回403状态拒绝访问或返回一个盗链显示图片，如果使用盗链显示图片就定义rewrite跳转到那个图片的URL。</p><ul><li>location中定义防止盗链的文件类型，以正则的语法进行匹配</li><li>expires、access_log定义了这些文件过期时间和日志不记录类型的配置，防盗链与静态文件过期时间和访问日志不记录可以在一个location中定义配置</li><li>rewrite设定指定转跳，设定指定转跳的URL地址，返回状态码302</li><li>return跟rewrite类似，只不过在最后处理请求时是直接拒绝掉这个盗链的请求，返回状态码403</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server&#123;</span></span><br><span class="line"><span class="attr">..</span></span><br><span class="line"><span class="comment">    # 对源站点验证</span></span><br><span class="line">    <span class="attr">valid_referers</span> <span class="string">*.xxx.com;</span></span><br><span class="line"><span class="comment">    # 非法引入会进入下方判断</span></span><br><span class="line">    <span class="meta">if($invalid_referer)</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">return</span> <span class="string">404;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-负载均衡配置"><a href="#5-4-负载均衡配置" class="headerlink" title="5.4-负载均衡配置"></a>5.4-负载均衡配置</h3><p>反向代理的例子中，代理仅仅指向一个服务器。</p><p>但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的 app，这时需要使用负载均衡来分流。</p><p>nginx 也可以实现简单的负载均衡功能。</p><p>假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台 linux 环境的服务器上。网站域名叫 <code>www.helloworld.com</code>，公网 IP 为 192.168.1.11。在公网 IP 所在的服务器上部署 nginx，对所有请求做负载均衡处理。</p><p>nginx.conf 配置如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">     #设定mime类型,类型由mime.type文件定义</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">/etc/nginx/mime.types;</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line"><span class="comment">    #设定日志格式</span></span><br><span class="line">    <span class="attr">access_log</span>    <span class="string">/var/log/nginx/access.log;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #设定负载均衡的服务器列表</span></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line"><span class="comment">        #weigth参数表示权值，权值越高被分配到的几率越大</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.11:80   weight=5;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.12:80   weight=1;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.13:80   weight=6;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   #HTTP服务器</span></span><br><span class="line">   <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">        #侦听80端口</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #定义使用www.xx.com访问</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">www.helloworld.com;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        #对所有请求进行负载均衡请求</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">root</span>        <span class="string">/root;                 #定义服务器的默认网站根目录位置</span></span><br><span class="line">            <span class="attr">index</span>       <span class="string">index.html index.htm;  #定义首页索引文件的名称</span></span><br><span class="line">            <span class="attr">proxy_pass</span>  <span class="string">http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            #以下是一些反向代理的配置(可选择性配置)</span></span><br><span class="line"><span class="comment">            #proxy_redirect off;</span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">Host $host;</span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">X-Real-IP $remote_addr;</span></span><br><span class="line"><span class="comment">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            <span class="attr">proxy_set_header</span> <span class="string">X-Forwarded-For $remote_addr;</span></span><br><span class="line">            <span class="attr">proxy_connect_timeout</span> <span class="string">90;          #nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="attr">proxy_send_timeout</span> <span class="string">90;             #后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="attr">proxy_read_timeout</span> <span class="string">90;             #连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="attr">proxy_buffer_size</span> <span class="string">4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="attr">proxy_buffers</span> <span class="string">4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span></span><br><span class="line">            <span class="attr">proxy_busy_buffers_size</span> <span class="string">64k;       #高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="attr">proxy_temp_file_write_size</span> <span class="string">64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">client_max_body_size</span> <span class="string">10m;          #允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="attr">client_body_buffer_size</span> <span class="string">128k;      #缓冲区代理缓冲用户端请求的最大字节数</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Nginx的负载均衡策略</strong></p><h4 id="1-轮循-round-robin-默认策略（RR-默认）"><a href="#1-轮循-round-robin-默认策略（RR-默认）" class="headerlink" title="1. 轮循(round-robin)默认策略（RR-默认）"></a>1. 轮循(round-robin)默认策略（RR-默认）</h4><p>根据请求次数，将每个请求均匀分配到每台服务器,如果后端服务器宕机，自动剔除。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态服务器组</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line"><span class="comment">        #默认使用轮询策略</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.11:80;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.12:80;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.13:80;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>最基本的配置方法，上面的例子就是轮询的方式，它是upstream模块默认的负载均衡默认策略。每个请求会按时间顺序逐一分配到不同的后端服务器。</p><p>有如下参数：</p><table><thead><tr><th>fail_timeout</th><th>与max_fails结合使用。</th></tr></thead><tbody><tr><td>max_fails</td><td>设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了，</td></tr><tr><td>fail_time</td><td>服务器会被认为停机的时间长度,默认为10s。</td></tr><tr><td>backup</td><td>标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里。</td></tr><tr><td>down</td><td>标记服务器永久停机了。</td></tr></tbody></table><p>注意：</p><ul><li>在轮询中，如果服务器down掉了，会自动剔除该服务器。</li><li>缺省配置就是轮询策略。</li><li>此策略适合服务器配置相当，无状态且短平快的服务使用。</li></ul><h4 id="2-权重-Weight"><a href="#2-权重-Weight" class="headerlink" title="2. 权重(Weight)"></a>2. 权重(Weight)</h4><p>权重方式，在轮询策略的基础上指定轮询的几率，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line"><span class="comment">        #weigth参数表示权值，权值越高被分配到的几率越大</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.11:80   weight=5;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.12:80   weight=1;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">192.168.1.13:80   weight=6;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>权重越高分配到需要处理的请求越多。</li><li>此策略可以与least_conn和ip_hash结合使用。</li><li>此策略比较适合服务器的硬件配置差别比较大的情况。</li></ul><h4 id="3-ip-hash"><a href="#3-ip-hash" class="headerlink" title="3. ip_hash"></a>3. ip_hash</h4><p>在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么<strong>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的</strong>。<br>我们可以采用<strong>ip_hash</strong>指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过<strong>哈希算法，自动定位到该服务器</strong>。<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决<strong>session的问题</strong>。</p><p>指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。</p><p><strong>同一客户端的Web请求被分发到同一个后端服务器进行处理，使用该策略可以有效的避免用户Session失效的问题。该策略可以连续产生1045个互异的value，经过20次hash仍然找不到可用的机器时，算法会退化成轮循。</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态服务器组</span></span><br><span class="line">  <span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line">    <span class="meta">ip_hash;</span>  <span class="string">#保证每个访客固定访问一个后端服务器</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">localhost:8080  weight=2; #tomcat 7.0</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">localhost:8081; #tomcat 8.0</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">localhost:8082; #tomcat 8.5</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">localhost:8083  max_fails=3 fail_timeout=20s; #tomcat 9.0</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>在nginx版本1.3.1之前，不能在ip_hash中使用权重（weight）。</li><li>ip_hash不能与backup同时使用。</li><li>此策略适合有状态服务，比如session。</li><li>当有服务器需要剔除，必须手动down掉。</li></ul><h4 id="4-最少连接-least-conn"><a href="#4-最少连接-least-conn" class="headerlink" title="4. 最少连接(least_conn)"></a>4. 最少连接(least_conn)</h4><p>把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态服务器组</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line">  <span class="meta">least_conn;</span>  <span class="string">#把请求转发给连接数较少的后端服务器</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8080  weight=2; #tomcat 7.0</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8081; #tomcat 8.0</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8082 backup; #tomcat 8.5</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8083  max_fails=3 fail_timeout=20s; #tomcat 9.0</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</li></ul><h4 id="5-参数说明"><a href="#5-参数说明" class="headerlink" title="5. 参数说明"></a>5. 参数说明</h4><ul><li><p>weight</p><p>启用权重策略，总数按照10进行计算，如果分配为3，则表示所有连接中的30%分配给该服务器,默认值为1；</p></li><li><p>max_fail/fail_timeout</p><p>某台服务器允许请求失败的次数，超过最大数后，在fail_timeout时间内，新的请求不会分配给这台机器，等fail_timeout时间过去后， 会再尝试请求这台服务器，如此循环往复；如果设置为0，反向代理服务器则会将这台服务器设置为永久无效状态。max_fail默认为1，fail_timeout默认为10秒；</p></li><li><p>backup</p><p>将某台服务器设定为备用机，当列表中的其他服务器都不可用时，启用备用机；</p></li><li><p>down</p><p>将某台服务器设定为不可用状态；</p></li><li><p>max_conns</p><p>限制分配给某台服务器的最大连接数，超过这个数量，反向代理服务器将不会分配新的连接，默认为0，表示不限制；</p></li></ul><h4 id="6-第三方策略"><a href="#6-第三方策略" class="headerlink" title="6. 第三方策略"></a>6. 第三方策略</h4><p>扩展策略默认不被编译进nginx内核，如果启用该策略，需要自行编译安装，需要安装第三方插件。</p><ul><li><p><strong>fair</strong></p><p>按照服务器端的响应时间来分配请求，响应时间短的优先分配。</p><p>根据后台服务器的响应时间判断负载情况，从中选出负载最轻的后端服务。但是在实际请款中，网络环境往往不那么简单，所以慎用。</p><p>在编译安装后，如果需要启用该策略，需要在upstream标签中添加<code>fair;</code>,启用该策略后，加权轮循将失效。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态服务器组</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8080; #tomcat 7.0</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8081; #tomcat 8.0</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8082; #tomcat 8.5</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8083; #tomcat 9.0</span></span><br><span class="line">  <span class="meta">fair;</span>  <span class="string">#实现响应时间短的优先分配</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>url_hash</strong></p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。　</p><ul><li>按照请求url的hash结果来分配请求，试每个url定向到同一个后端服务器，在1.7.2之后的nginx版本中，该模块应集成到内核中，不需要单独安装；</li><li>启用该策略，需要在upstream标签中添加`hash $request_url;。</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#动态服务器组</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">load_balance_server &#123;</span></span><br><span class="line">  <span class="attr">hash</span> <span class="string">$request_uri;  #实现每个url定向到同一个后端服务器</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8080; #tomcat 7.0</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8081; #tomcat 8.0</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8082; #tomcat 8.5</span></span><br><span class="line">  <span class="attr">server</span> <span class="string">localhost:8083; #tomcat 9.0</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-网站有多个-webapp-的配置"><a href="#5-5-网站有多个-webapp-的配置" class="headerlink" title="5.5-网站有多个 webapp 的配置"></a>5.5-网站有多个 webapp 的配置</h3><p>当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。</p><p>举个例子：假如 <code>www.helloworld.com</code> 站点有好几个 webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分:</p><blockquote><p><a target="_blank" rel="noopener" href="http://www.helloworld.com/finance/">www.helloworld.com/finance/</a></p><p><a target="_blank" rel="noopener" href="http://www.helloworld.com/product/">www.helloworld.com/product/</a></p><p><a target="_blank" rel="noopener" href="http://www.helloworld.com/admin/">www.helloworld.com/admin/</a></p></blockquote><p>我们知道，http 的默认端口号是 80，如果在一台服务器上同时启动这 3 个 webapp 应用，都用 80 端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。</p><p>那么，问题来了，用户在实际访问 <code>www.helloworld.com</code> 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。</p><p>配置也不难，来看看怎么做吧：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #此处省略一些基本配置</span></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">product_server&#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">www.helloworld.com:8081;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">admin_server&#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">www.helloworld.com:8082;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">upstream</span> <span class="string">finance_server&#123;</span></span><br><span class="line">        <span class="attr">server</span> <span class="string">www.helloworld.com:8083;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">        #此处省略一些基本配置</span></span><br><span class="line"><span class="comment">        #默认指向product的server</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://product_server;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/product/&#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://product_server;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/admin/ &#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://admin_server;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/finance/ &#123;</span></span><br><span class="line">            <span class="attr">proxy_pass</span> <span class="string">http://finance_server;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-6-https-反向代理配置"><a href="#5-6-https-反向代理配置" class="headerlink" title="5.6-https 反向代理配置"></a>5.6-https 反向代理配置</h3><p>一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用 ssl 通信标准的安全 HTTP 协议）。</p><p>这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点：</p><ul><li>HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口</li><li>SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key</li></ul><p>其他和 http 反向代理基本一样，只是在 <code>Server</code> 部分配置有些不同。</p><p>首先要确定 Nginx有没安装了ssl 模块。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">nginx</span> <span class="string">-V</span></span><br><span class="line"><span class="comment"># 如未安装需进入Nginx 源码目录重新编译，在原命令基础上添加--with-http_ssl_module再进行编译安装 </span></span><br><span class="line"><span class="meta">./configure</span> <span class="string">--prefix=/usr/local/nginx ... --with-http_ssl_module</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#HTTP服务器</span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #监听443端口。443为知名端口号，主要用于HTTPS协议</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">443 ssl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #定义使用www.xx.com访问</span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">www.helloworld.com;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #ssl证书文件位置(常见证书文件格式为：crt/pem)</span></span><br><span class="line">    <span class="attr">ssl_certificate</span>      <span class="string">cert.pem;</span></span><br><span class="line"><span class="comment">    #ssl证书key位置</span></span><br><span class="line">    <span class="attr">ssl_certificate_key</span>  <span class="string">cert.key;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #ssl配置参数（选择性配置）</span></span><br><span class="line">    <span class="attr">ssl_session_cache</span>    <span class="string">shared:SSL:1m;</span></span><br><span class="line">    <span class="attr">ssl_session_timeout</span>  <span class="string">5m;</span></span><br><span class="line"><span class="comment">    #数字签名，此处使用MD5</span></span><br><span class="line">    <span class="attr">ssl_ciphers</span>  <span class="string">HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="attr">ssl_prefer_server_ciphers</span>  <span class="string">on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">root</span>   <span class="string">/root;</span></span><br><span class="line">        <span class="attr">index</span>  <span class="string">index.html index.htm;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-7-静态站点配置"><a href="#5-7-静态站点配置" class="headerlink" title="5.7-静态站点配置"></a>5.7-静态站点配置</h3><p>有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。</p><p>举例来说：如果所有的静态资源都放在了 <code>/app/dist</code> 目录下，我们只需要在 <code>nginx.conf</code> 中指定首页以及这个站点的 host 即可。</p><p>配置如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">worker_processes</span>  <span class="string">1;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">mime.types;</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on;</span></span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gzip</span> <span class="string">on;</span></span><br><span class="line">    <span class="attr">gzip_types</span> <span class="string">text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;</span></span><br><span class="line">    <span class="attr">gzip_vary</span> <span class="string">on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">static.zp.cn;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">            <span class="attr">root</span> <span class="string">/app/dist;</span></span><br><span class="line">            <span class="attr">index</span> <span class="string">index.html;</span></span><br><span class="line"><span class="comment">            #转发任何请求到 index.html</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>然后，添加 HOST：</p><p>127.0.0.1 static.zp.cn</p><p>此时，在本地浏览器访问 static.zp.cn ，就可以访问静态站点了。</p><h3 id="5-8-搭建文件服务器"><a href="#5-8-搭建文件服务器" class="headerlink" title="5.8-搭建文件服务器"></a>5.8-搭建文件服务器</h3><p>有时候，团队需要归档一些数据或资料，那么文件服务器必不可少。使用 Nginx 可以非常快速便捷的搭建一个简易的文件服务。</p><p>Nginx 中的配置要点：</p><ul><li>将 autoindex 开启可以显示目录，默认不开启。</li><li>将 autoindex_exact_size 开启可以显示文件的大小。</li><li>将 autoindex_localtime 开启可以显示文件的修改时间。</li><li>root 用来设置开放为文件服务的根路径。</li><li>charset 设置为 <code>charset utf-8,gbk;</code>，可以避免中文乱码问题（windows 服务器下设置后，依然乱码，本人暂时没有找到解决方法）。</li></ul><p>一个最简化的配置如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">autoindex</span> <span class="string">on;# 显示目录</span></span><br><span class="line"><span class="attr">autoindex_exact_size</span> <span class="string">on;# 显示文件大小</span></span><br><span class="line"><span class="attr">autoindex_localtime</span> <span class="string">on;# 显示文件时间</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">charset</span>      <span class="string">utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">9050 default_server;</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">[::]:9050 default_server;</span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">_;</span></span><br><span class="line">    <span class="attr">root</span>         <span class="string">/share/fs;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-9-Nginx缓存配置"><a href="#5-9-Nginx缓存配置" class="headerlink" title="5.9-Nginx缓存配置"></a>5.9-Nginx缓存配置</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1.png"></p><p>面对第一次客户端的应用Nginx需要从后端的服务获取数据，对于后续的请求，Nginx若进行了缓存就不再从后端服务获取数据。</p><h4 id="1-proxy-cache-path"><a href="#1-proxy-cache-path" class="headerlink" title="1. proxy_cache_path"></a>1. proxy_cache_path</h4><p>语法：proxy_cache_path path [levels=levels].只能用在http中。</p><p>指定缓存位置、缓存名称、内存中缓存内容元数据信息大小限制、缓存总大小限制。缓存位置是一个目录应该先创建好，nginx并不会帮我们创建这个缓存目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /root/cache levels=1:2 keys_zone=zzm_cache:10m max_size=1g inactive=60m use_temp_path=off;</span><br></pre></td></tr></table></figure><ul><li>/root/cache：定义 proxy_cache 生成文件的根路径</li><li>levels：默认所有缓存文件都放在上面指定的根路径中，从而可能影响缓存的性能。推荐指定为 2 级目录来存储缓存文件</li><li>key_zone：这个的值是字符串，可以随意写。用于在共享内存中定义一块存储区域来存放缓存的 key 和 metadata（类似于使用次数），这样 nginx 可以快速判断一个 request 是否命中缓存。1m 可以存储 8000 个key,10m可以存在80000个key</li><li>max_size：最大 cache 空间。如果不指定，会使用掉所有 disk space。当达到 disk 上限后，会删除最少使用的 cache</li><li>inactive：内存中缓存的过期检查周期。示例配置中如果 1h 内都没有被访问，则不论状态是否为 expired，都会清除缓存。需要注意的是，inactive 和 expired 配置项的含义是不同的，expired 只是判断过期时间，不会删除缓存；而 inactive 是直接删除过期缓存</li><li>use_temp_path：如果为 off，则 nginx 会将缓存文件直接写入指定的 cache 文件中，而不使用 temp_path 指定的临时存储路径</li></ul><h4 id="2-proxy-cache"><a href="#2-proxy-cache" class="headerlink" title="2. proxy_cache"></a>2. proxy_cache</h4><p>proxy_cache zone | off。默认是关闭的，可以用在http,server,location中。</p><p>指定使用前面设置的缓存名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_cache zzm_cache;</span><br><span class="line">    proxy_pass http://zzm;</span><br><span class="line">    proxy_cache_valid 200 304 12h;</span><br><span class="line">    proxy_cache_valid any 10m;</span><br><span class="line">    proxy_cache_key $host$uri$is_args<span class="variable">$args</span>;</span><br><span class="line">    add_header Nginx-Cache <span class="string">&quot;<span class="variable">$upstream_cache_status</span>&quot;</span>;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy_cache：对应 http 段的 key_zone，是你定义的 proxy_cache 所使用的共享空间的名称，我在1.1中定义的是zzm_cache，所以在这里也写的是zzm_cache。</li><li>proxy_cache_valid：对指定的 HTTP 状态进行缓存，并指定缓存时间。可以自定义写入多个配置项。这里我们对200和304的返回码缓存12小时。其余的缓存10分钟</li><li>proxy_cache_key：缓存的维度</li><li>is_args:如果$args设置，值为”?”，否则为””</li><li>proxy_next_upstream 当请求服务器发生错误或超时时，会尝试到下一台服务器</li></ul><h4 id="3-静态资源缓存浏览器"><a href="#3-静态资源缓存浏览器" class="headerlink" title="3. 静态资源缓存浏览器"></a>3. 静态资源缓存浏览器</h4><p><strong>expires 指令</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">location</span> <span class="string">/static&#123;</span></span><br><span class="line"><span class="attr">alias</span> <span class="string">/xxx/yyy;</span></span><br><span class="line"><span class="comment">				#expires 10s;    # 缓存10s后过期</span></span><br><span class="line">        <span class="attr">expires</span> <span class="string">@22h30m; # 指定缓存过期时间</span></span><br><span class="line"><span class="comment">        # expires -1h; # 缓存1小时前失效，即不缓存</span></span><br><span class="line"><span class="comment">        # expires epoch; # 过期时间为1 January,1970,00:00:01 GMT，同样不进行缓存</span></span><br><span class="line"><span class="comment">        # expires off; # 不设置，会使用浏览器默认值</span></span><br><span class="line"><span class="comment">        # expires max; # 过期时间设置为31 December 2037 23:59:59 GMT，“Cache-Control”的值为10年</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4-服务器资源缓存到-Nginx端"><a href="#4-服务器资源缓存到-Nginx端" class="headerlink" title="4. 服务器资源缓存到 Nginx端"></a>4. 服务器资源缓存到 Nginx端</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置缓存保存的目录</span></span><br><span class="line"><span class="comment"># keys_zone 设置共享内存及占用的空间大小，mycache为自定义名称，在下方需使用</span></span><br><span class="line"><span class="comment"># max_size 设置缓存总大小</span></span><br><span class="line"><span class="comment"># inactive 缓存超出所指定的时间进行清理</span></span><br><span class="line"><span class="attr">proxy_cache_path</span> <span class="string">/usr/local/nginx/upstream_cache keys_zone=mycache:5m max_size=1g inactive=30m use_temp_path=off; </span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="comment"># 开启并使用缓存，mycache为上方所指定的名称</span></span><br><span class="line"><span class="attr">proxy_cache</span> <span class="string">mycache;</span></span><br><span class="line"><span class="comment"># 针对指定状态码的缓存过期时间</span></span><br><span class="line"><span class="attr">proxy_cache_valid</span> <span class="string">200 304 8h;</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-10-常见问题"><a href="#5-10-常见问题" class="headerlink" title="5.10-常见问题"></a>5.10-常见问题</h3><ul><li>使用Nginx的反向代理，让同一个用户的请求一定转发到同一台服务器上，这种均衡策略会消耗更多的服务器资源，也增加了代理服务器的负担；</li><li>使用其他策略作为负载均衡时，会出现用户Session丢失的情况，为避免出现这种情况，可以将用户的Session存放到缓存服务器中，比较常用的方案时redis/memchache；</li><li>反向代理服务器也可以开启缓存服务，但是开启该项服务会增加代理服务器的负担，影响整体的负载均衡效率；</li><li>使用Nginx反向代理布置负载均衡，操作相对简单，但是会有“单点故障”的问题，如果后台某台服务器宕机，会带来很多的麻烦，后期如果后台服务器继续增加，反向代理服务器会成为负载均衡方案的瓶颈。</li></ul><h2 id="6-Nginx的架构和原理"><a href="#6-Nginx的架构和原理" class="headerlink" title="6-Nginx的架构和原理"></a>6-Nginx的架构和原理</h2><h3 id="6-1-Nginx的整体架构"><a href="#6-1-Nginx的整体架构" class="headerlink" title="6.1-Nginx的整体架构"></a>6.1-Nginx的整体架构</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/Nginx%E7%9A%84%E6%9E%B6%E6%9E%84.png"></p><h4 id="1-主进程"><a href="#1-主进程" class="headerlink" title="1. 主进程"></a>1. 主进程</h4><p>Nginx启动时，会生成两种类型的进程，一个是主进程（master），一个（windows版本的目前只有一个）或多个工作进程（worker）。</p><p>主进程并不处理网络请求，主要负责调度工作进程，也就是图示的3项：加载配置、启动工作进程、非停升级</p><p>因此，Nginx启动以后，查看操作系统的进程列表，我们就能看到至少有两个Nginx进程。</p><h4 id="2-工作进程"><a href="#2-工作进程" class="headerlink" title="2. 工作进程"></a>2. 工作进程</h4><p>服务器实际处理网络请求及响应的是工作进程（worker），在类unix系统上，Nginx可以配置多个worker，而每个worker进程都可以同时处理数以千计的网络请求。</p><h4 id="3-模块化设计"><a href="#3-模块化设计" class="headerlink" title="3.模块化设计"></a>3.模块化设计</h4><p>Nginx的worker进程，包括核心和功能性模块，核心模块负责维持一个运行循环（run-loop），执行网络请求处理的不同阶段的模块功能。</p><p>比如：网络读写、存储读写、内容传输、外出过滤，以及将请求发往上游服务器等。</p><p>而其代码的模块化设计，也使得我们可以根据需要对功能模块进行适当的选择和修改，编译成具有特定功能的服务器。</p><h4 id="4-事件驱动模型"><a href="#4-事件驱动模型" class="headerlink" title="4. 事件驱动模型"></a>4. 事件驱动模型</h4><p>基于异步及非阻塞的事件驱动模型，可以说是Nginx得以获得高并发、高性能的关键因素，同时也得益于对Linux、Solaris及类BSD等操作系统内核中事件通知及I/O性能增强功能的采用，如kqueue、epoll及eventports。</p><h4 id="5-代理（proxy）设计"><a href="#5-代理（proxy）设计" class="headerlink" title="5. 代理（proxy）设计"></a>5. 代理（proxy）设计</h4><p>代理设计，可以说是Nginx深入骨髓的设计，无论是对于HTTP，还是对于FastCGI、Memcache、Redis等的网络请求或响应，本质上都采用了代理机制。所以，Nginx天生就是高性能的代理服务器。</p><h3 id="6-2-Nginx的模块化设计"><a href="#6-2-Nginx的模块化设计" class="headerlink" title="6.2-Nginx的模块化设计"></a>6.2-Nginx的模块化设计</h3><p>高度模块化的设计是Nginx的架构基础。Nginx服务器被分解为多个模块，每个模块就是一个功能模块，只负责自身的功能，模块之间严格遵循“高内聚，低耦合”的原则。</p><p>如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1.png"></p><h4 id="1-核心模块"><a href="#1-核心模块" class="headerlink" title="1. 核心模块"></a>1. 核心模块</h4><p>核心模块是Nginx服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、事件驱动机制、进程管理等核心功能。</p><h4 id="2-标准HTTP模块"><a href="#2-标准HTTP模块" class="headerlink" title="2. 标准HTTP模块"></a>2. 标准HTTP模块</h4><p>标准HTTP模块提供HTTP协议解析相关的功能，比如：端口配置、网页编码设置、HTTP响应头设置等等。</p><h4 id="3-可选HTTP模块"><a href="#3-可选HTTP模块" class="headerlink" title="3. 可选HTTP模块"></a>3. 可选HTTP模块</h4><p>可选HTTP模块主要用于扩展标准的HTTP功能，让Nginx能处理一些特殊的服务，比如：Flash多媒体传输、解析GeoIP请求、网络传输压缩、安全协议SSL支持等。</p><h4 id="4-邮件服务模块"><a href="#4-邮件服务模块" class="headerlink" title="4. 邮件服务模块"></a>4. 邮件服务模块</h4><p>邮件服务模块主要用于支持Nginx的邮件服务，包括对POP3协议、IMAP协议和SMTP协议的支持。</p><h4 id="5-第三方模块"><a href="#5-第三方模块" class="headerlink" title="5. 第三方模块"></a>5. 第三方模块</h4><p>第三方模块是为了扩展Nginx服务器应用，完成开发者自定义功能，比如：Json支持、Lua支持等。</p><h3 id="6-3-Nginx的请求方式处理"><a href="#6-3-Nginx的请求方式处理" class="headerlink" title="6.3-Nginx的请求方式处理"></a>6.3-Nginx的请求方式处理</h3><p>Nginx是一个高性能的Web服务器，能够同时处理大量的并发请求。它结合多进程机制和异步机制，异步机制使用的是异步非阻塞方式，接下来就给大家介绍一下Nginx的多线程机制和异步非阻塞机制。</p><h4 id="1-多进程机制"><a href="#1-多进程机制" class="headerlink" title="1. 多进程机制"></a>1. 多进程机制</h4><p>服务器每当收到一个客户端时，就有服务器主进程（master process）生成一个子进程（worker process）出来和客户端建立连接进行交互，直到连接断开，该子进程就结束了。</p><p>使用进程的好处是各个进程之间相互独立，不需要加锁，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。</p><p>其次，采用独立的进程，可以让进程互相之间不会影响，如果一个进程发生异常退出时，其它进程正常工作，master进程则很快启动新的worker进程，确保服务不会中断，从而将风险降到最低。</p><p>缺点是操作系统生成一个子进程需要进行内存复制等操作，在资源和时间上会产生一定的开销。当有大量请求时，会导致系统性能下降。</p><h4 id="2-异步非阻塞机制"><a href="#2-异步非阻塞机制" class="headerlink" title="2. 异步非阻塞机制"></a>2. 异步非阻塞机制</h4><p>每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。</p><p>当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求（即为非阻塞），而客户端在此期间也无需等待响应，可以去处理其他事情（即为异步）</p><p>当IO返回时，就会通知此工作进程，该进程得到通知，暂时挂起当前处理的事务去响应客户端请求。</p><h3 id="6-4-Nginx事件驱动模型"><a href="#6-4-Nginx事件驱动模型" class="headerlink" title="6.4-Nginx事件驱动模型"></a>6.4-Nginx事件驱动模型</h3><p>在Nginx的异步非阻塞机制中，工作进程在调用IO后，就去处理其他的请求，当IO调用返回后，会通知该工作进程。</p><p>对于这样的系统调用，主要使用Nginx服务器的事件驱动模型来实现，如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png"></p><p>如上图所示，Nginx的事件驱动模型由事件收集器、事件发送器和事件处理器三部分基本单元组成。</p><ul><li>事件收集器：负责收集worker进程的各种IO请求；</li><li>事件发送器：负责将IO事件发送到事件处理器；</li><li>事件处理器：负责各种事件的响应工作。</li></ul><p>事件发送器将每个请求放入一个待处理事件列表，使用非阻塞I/O方式调用事件处理器来处理该请求。</p><p>其处理方式称为“多路IO复用方法”，常见的包括以下三种：select模型、poll模型、epoll模型。</p><h3 id="6-5-Nginx进程处理模型"><a href="#6-5-Nginx进程处理模型" class="headerlink" title="6.5-Nginx进程处理模型"></a>6.5-Nginx进程处理模型</h3><p>Nginx服务器使用 master/worker 多进程模式，多线程启动和执行的流程如下：</p><p>主程序Masterprocess启动后，通过一个for循环来接收和处理外部信号</p><p>主进程通过fork()函数产生worker子进程，每个子进程执行一个for循环来实现Nginx服务器对事件的接收和处理</p><p>一般推荐worker进程数与CPU内核数一致，这样一来不存在大量的子进程生成和管理任务，避免了进程之间竞争CPU资源和进程切换的开销。</p><p>而且Nginx为了更好的利用多核特性，提供了CPU亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来Cache的失效。</p><p>对于每个请求，有且只有一个工作进程对其处理。首先，每个worker进程都是从master进程fork过来。在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程。</p><p>所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢占accept_mutex</p><p>抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接。</p><p>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求就是这样。</p><p>我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。</p><p>如下图所示：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.png"></p><p>在Nginx服务器的运行过程中，主进程和工作进程需要进程交互。交互依赖于Socket实现的管道来实现。</p><h4 id="1-主进程与工作进程交互"><a href="#1-主进程与工作进程交互" class="headerlink" title="1. 主进程与工作进程交互"></a>1. 主进程与工作进程交互</h4><p>这条管道与普通的管道不同，它是由主进程指向工作进程的单向管道，包含主进程向工作进程发出的指令工，作进程ID等。同时主进程与外界通过信号通信；每个子进程具备接收信号，并处理相应的事件的能力。</p><h4 id="2-工作进程与工作进程交互"><a href="#2-工作进程与工作进程交互" class="headerlink" title="2. 工作进程与工作进程交互"></a>2. 工作进程与工作进程交互</h4><p>这种交互和主进程-工作进程交互基本一致，但是会通过主进程间接完成，工作进程之间是相互隔离的。</p><p>所以当工作进程W1需要向工作进程W2发指令时，首先找到W2的进程ID，然后将正确的指令写入指向W2的通道，W2收到信号采取相应的措施。</p><blockquote><p>参考：</p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5026ab611d4e">https://www.jianshu.com/p/5026ab611d4e</a></p><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/143985.htm">https://www.jb51.net/article/143985.htm</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RfaPtO3VWDozIZvGxN2ASQ">https://mp.weixin.qq.com/s/RfaPtO3VWDozIZvGxN2ASQ</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bOhypYveaRbAbDPWUEdFfg">https://mp.weixin.qq.com/s/bOhypYveaRbAbDPWUEdFfg</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/04/29/Nginx%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://lemon-cs.github.io/2020/04/29/Nginx%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></div><div class="post_share"><div class="social-share" data-image="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05/01/Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"><img class="prev-cover" src="https://s4.ax1x.com/2022/02/15/HRSP1A.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java浅拷贝和深拷贝</div></div></a></div><div class="next-post pull-right"><a href="/2020/04/15/JWT%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2021/12/53994acaedfff1ec.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JWT详解</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">Nginx学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFNginx%EF%BC%9F"><span class="toc-text">1-什么是Nginx？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">2-正向代理和反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">2.1-什么是正向代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-text">2.2-什么是反向代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Nginx%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3-Nginx的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Nginx%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.1-Nginx可以提供的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Nginx%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">3.2-Nginx的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">4-Nginx的安装与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Nginx%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">4.1-Nginx的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Nginx%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2-Nginx的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Nginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98"><span class="toc-text">5-Nginx配置实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-http-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-text">5.1-http 反向代理配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Nginx%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">5.2-Nginx跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Access-Control-Allow-Origin"><span class="toc-text">1. Access-Control-Allow-Origin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Access-Control-Allow-Headers-%E6%98%AF%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E9%94%99%E8%AF%AF%EF%BC%9A"><span class="toc-text">2. Access-Control-Allow-Headers 是为了防止出现以下错误：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Access-Control-Allow-Methods-%E6%98%AF%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E9%94%99%E8%AF%AF%EF%BC%9A"><span class="toc-text">3. Access-Control-Allow-Methods 是为了防止出现以下错误：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%99OPTIONS-%E6%B7%BB%E5%8A%A0-204%E7%9A%84%E8%BF%94%E5%9B%9E%EF%BC%8C%E6%98%AF%E4%B8%BA%E4%BA%86%E5%A4%84%E7%90%86%E5%9C%A8%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82%E6%97%B6Nginx%E4%BE%9D%E7%84%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">4.给OPTIONS 添加 204的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Nginx%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-text">5.3-Nginx防盗链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE"><span class="toc-text">5.4-负载均衡配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AE%E5%BE%AA-round-robin-%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5%EF%BC%88RR-%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-text">1. 轮循(round-robin)默认策略（RR-默认）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9D%83%E9%87%8D-Weight"><span class="toc-text">2. 权重(Weight)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ip-hash"><span class="toc-text">3. ip_hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5-least-conn"><span class="toc-text">4. 最少连接(least_conn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-text">5. 参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%AD%96%E7%95%A5"><span class="toc-text">6. 第三方策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E7%BD%91%E7%AB%99%E6%9C%89%E5%A4%9A%E4%B8%AA-webapp-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">5.5-网站有多个 webapp 的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-https-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-text">5.6-https 反向代理配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="toc-text">5.7-静态站点配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">5.8-搭建文件服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-Nginx%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="toc-text">5.9-Nginx缓存配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-proxy-cache-path"><span class="toc-text">1. proxy_cache_path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-proxy-cache"><span class="toc-text">2. proxy_cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">3. 静态资源缓存浏览器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E5%88%B0-Nginx%E7%AB%AF"><span class="toc-text">4. 服务器资源缓存到 Nginx端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">5.10-常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Nginx%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">6-Nginx的架构和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Nginx%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-text">6.1-Nginx的整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E8%BF%9B%E7%A8%8B"><span class="toc-text">1. 主进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B"><span class="toc-text">2. 工作进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-text">3.模块化设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">4. 事件驱动模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%A3%E7%90%86%EF%BC%88proxy%EF%BC%89%E8%AE%BE%E8%AE%A1"><span class="toc-text">5. 代理（proxy）设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Nginx%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.2-Nginx的模块化设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-text">1. 核心模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%87%E5%87%86HTTP%E6%A8%A1%E5%9D%97"><span class="toc-text">2. 标准HTTP模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%AF%E9%80%89HTTP%E6%A8%A1%E5%9D%97"><span class="toc-text">3. 可选HTTP模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97"><span class="toc-text">4. 邮件服务模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97"><span class="toc-text">5. 第三方模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Nginx%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86"><span class="toc-text">6.3-Nginx的请求方式处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">1. 多进程机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6"><span class="toc-text">2. 异步非阻塞机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Nginx%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.4-Nginx事件驱动模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Nginx%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.5-Nginx进程处理模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%E4%BA%A4%E4%BA%92"><span class="toc-text">1. 主进程与工作进程交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B%E4%BA%A4%E4%BA%92"><span class="toc-text">2. 工作进程与工作进程交互</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/30/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/" title="Netty知识点详解"><img src="https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Netty知识点详解"></a><div class="content"><a class="title" href="/2021/12/30/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/" title="Netty知识点详解">Netty知识点详解</a><time datetime="2021-12-30T06:31:42.000Z" title="发表于 2021-12-30 14:31:42">2021-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/28/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2021/12/28/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2021-12-28T14:09:50.000Z" title="发表于 2021-12-28 22:09:50">2021-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/26/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB"><img src="https://s3.bmp.ovh/imgs/2021/12/2de6481e0a4697bf.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go操作MongoDB"></a><div class="content"><a class="title" href="/2021/12/26/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB">Go操作MongoDB</a><time datetime="2021-12-26T14:09:50.000Z" title="发表于 2021-12-26 22:09:50">2021-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/10/SpringBoot%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="SpringBoot之基础回顾"><img src="https://static01.imgkr.com/temp/31d9be0ee4fc43549ffe1bd007bc4e59.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot之基础回顾"></a><div class="content"><a class="title" href="/2020/08/10/SpringBoot%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="SpringBoot之基础回顾">SpringBoot之基础回顾</a><time datetime="2020-08-10T14:09:50.000Z" title="发表于 2020-08-10 22:09:50">2020-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/09/SpringMVC%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="SpringMVC之源码分析"><img src="https://s3.bmp.ovh/imgs/2022/01/e846e507b0d2ee95.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringMVC之源码分析"></a><div class="content"><a class="title" href="/2020/08/09/SpringMVC%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="SpringMVC之源码分析">SpringMVC之源码分析</a><time datetime="2020-08-09T06:32:50.000Z" title="发表于 2020-08-09 14:32:50">2020-08-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>