<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Angular入门学习笔记 | Lemon-CS</title><meta name="keywords" content="Angular"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Angular入门学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="Angular入门学习笔记"><meta property="og:url" content="https://lemon-cs.github.io/2020/01/15/Angular%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="Angular入门学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg"><meta property="article:published_time" content="2020-01-15T12:36:54.000Z"><meta property="article:modified_time" content="2022-01-24T17:15:38.824Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="前端"><meta property="article:tag" content="Angular"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/01/15/Angular%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Angular入门学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-25 01:15:38"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Angular入门学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-01-15T12:36:54.000Z" title="发表于 2020-01-15 20:36:54">2020-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-24T17:15:38.824Z" title="更新于 2022-01-25 01:15:38">2022-01-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Angular入门学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Angular入门"><a href="#1-Angular入门" class="headerlink" title="1-Angular入门"></a>1-Angular入门</h1><h2 id="1-1-开发环境的搭建"><a href="#1-1-开发环境的搭建" class="headerlink" title="1.1-开发环境的搭建"></a>1.1-开发环境的搭建</h2><ol><li><p>安装最新版本的NodeJS</p><p>具体安装教程可参照 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhouyu2017/p/6485265.html">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a></p></li><li><p>设置镜像</p><p>在命令窗口中进行操作：</p><p>或者设置淘宝镜像：<code>npm config set registry https://registry.npm.taobao.org/</code></p><p>查看镜像地址：<code>npm config get registry</code></p></li><li><p>安装Angular Cli</p><p>安装脚手架工具：<code>npm install -g @angular/cli</code></p><p>如果npm安装脚手架工具失败，可先安装cnpm淘宝镜像 <code>npm install –g cnpm –registry=https：//[registry.npm.taobao.org](http://registry.npm.taobao.org/)</code></p><p>再使用cnpm安装脚手架工具 <code>cnpm install -g @angular/cli</code></p><p>验证是否安装成功：<code>ng version</code></p></li><li><p>安装Visual Studio Code</p><p>具体安装教程可参照 <a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/59703552b622b78fc007401b.html">https://jingyan.baidu.com/article/59703552b622b78fc007401b.html</a></p><p>安装完成后添加Angular v8 Snippets插件来支持Angular语法;安装Chinese(Simplified) Language Pack for Visual Studio Code插件来汉化Visual Studio Code;安装jslint插件来保持代码风格的一致性。</p><p>插件具体安装教程可参照 <a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/90808022029213fd91c80f15.html">https://jingyan.baidu.com/article/90808022029213fd91c80f15.html</a></p><p>如果网络环境受到限制无法直接安装，可采用离线安装，具体的操作教程可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012814856/article/details/80684376">https://blog.csdn.net/u012814856/article/details/80684376</a></p></li></ol><h2 id="1-2-新建项目"><a href="#1-2-新建项目" class="headerlink" title="1.2-新建项目"></a>1.2-新建项目</h2><ol><li><p>新建项目</p><p>找到你要创建项目的目录，使用“<code>ng new 项目名称</code>”创建一个Angular项目（如果要创建带路由的项目，则使用“<code>ng new 项目名 --routing</code> ”来创建项目）</p><p>进入刚刚创建的项目的目录下，添加项目依赖：npm install 或 cnpm install</p><p>启动项目<code>ng serve</code> （如果使用代理proxy.conf.json，则使用“npm start”来启动项目,此时需要在package,json中做相关配置<code>：“start” : ”ng serve --proxy-config proxy.conf.json”</code>,）</p></li><li><p>新建组件</p><p>在app目录下新建<code>components</code>文件夹</p><p>新建组件，在命令框中使用命令 <code>“ng g component components/组件名”</code> 创建新组件。创建之后要在<code>app.module.ts</code>中引入该组件</p><p>新建文件夹、各种文件可直接在相应的目录下右击创建</p></li><li><p>使用<code>ng-zorro</code>的组件</p><p>需要安装ng-zorro-antd相关的依赖，具体教程参见 <a target="_blank" rel="noopener" href="https://ng.ant.design/docs/getting-started/zh">https://ng.ant.design/docs/getting-started/zh</a></p></li></ol><h2 id="1-3-常见命令"><a href="#1-3-常见命令" class="headerlink" title="1.3-常见命令"></a>1.3-常见命令</h2><ol><li><p>查看nodejs的版本 <code>node –v</code></p></li><li><p>查看npm的版本 <code>npm –v</code></p></li><li><p>查看Cli脚手架的版本信息 <code>ng version</code></p></li><li><p>设置npm前缀 <code>npm config set prefix &quot;D:\Develop\nodejs\node_global&quot;</code> （具体路径根据实际情况来定）</p></li><li><p>查看npm前缀 <code>npm config get prefix</code></p></li><li><p>设置npm缓存 <code>npm config set cache &quot;D:\Develop\nodejs\node_cache&quot;</code> （具体路径根据实际情况来定）</p></li><li><p>查看npm缓存 <code>npm config get cache</code></p></li><li><p>查看npm配置信息列表 <code>npm config list</code></p></li><li><p>创建一个Angular项目 <code>ng new 项目名称</code></p></li><li><p>创建一个带有路由的Angular项目 <code>ng new 项目名称 --routing</code></p></li><li><p>退出某个目录 cd ..</p></li><li><p>进入某个目录 cd Program Files\Microsoft VS Code\bin （具体路径根据实际情况来定）</p></li><li><p>转换盘符 d： （具体切换到那个盘根据实际情况来定）</p></li><li><p>初始化项目依赖 <code>npm install 或者 cnpm install</code></p></li><li><p>创建一个组件 <code>ng g component components/组件名</code> （components是自己新建的文件夹，可根据实际情况改变）</p></li><li><p>启动项目 <code>ng serve 或 ng serve --open</code></p></li><li><p>使用代理时启动项目 <code>npm start</code></p></li><li><p>自动完成 ng-zorro-antd 的初始化配置 <code>ng add ng-zorro-antd</code></p></li></ol><h2 id="1-4-参考网站"><a href="#1-4-参考网站" class="headerlink" title="1.4-参考网站"></a>1.4-参考网站</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008754631">Angular 4.x 修仙之路</a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008754631">https://segmentfault.com/a/1190000008754631</a></p><p>Angular中文官网:<a target="_blank" rel="noopener" href="https://angular.cn/">https://angular.cn/</a></p><p>npm install Angular依赖包下载<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/package">https://www.npmjs.com/package/package</a></p><p>ng zorro网址<a target="_blank" rel="noopener" href="https://ng.ant.design/docs/introduce/zh">https://ng.ant.design/docs/introduce/zh</a></p><h1 id="2-Angular基础"><a href="#2-Angular基础" class="headerlink" title="2-Angular基础"></a>2-Angular基础</h1><h2 id="2-1-架构概览"><a href="#2-1-架构概览" class="headerlink" title="2.1-架构概览"></a>2.1-架构概览</h2><p>Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。 Angular 本身就是用 TypeScript 写成的。它将核心功能和可选功能作为一组 TypeScript 库进行实现，你可以把它们导入你的应用中。</p><p>Angular 的基本构造块是 <em>NgModule</em>，它为<em>组件</em>提供了编译的上下文环境。 NgModule 会把相关的代码收集到一些功能集中。Angular 应用就是由一组 NgModule 定义出的。 应用至少会有一个用于引导应用的<em>根模块</em>，通常还会有很多<em>特性模块</em>。</p><ul><li>组件定义<em>视图</em>。视图是一组可见的屏幕元素，Angular 可以根据你的程序逻辑和数据来选择和修改它们。 每个应用都至少有一个根组件。</li><li>组件使用<em>服务</em>。服务会提供那些与视图不直接相关的功能。服务提供商可以作为<em>依赖</em>被<em>注入</em>到组件中， 这能让你的代码更加模块化、更加可复用、更加高效。</li></ul><p>组件和服务都是简单的类，这些类使用<em>装饰器</em>来标出它们的类型，并提供元数据以告知 Angular 该如何使用它们。</p><ul><li>组件类的元数据将组件类和一个用来定义视图的<em>模板</em>关联起来。 模板把普通的 HTML 和 Angular <em>指令</em>与<em>绑定标记（markup）</em>组合起来，这样 Angular 就可以在呈现 HTML 之前先修改这些 HTML。</li><li>服务类的元数据提供了一些信息，Angular 要用这些信息来让组件可以通过<em>依赖注入（DI）</em>使用该服务。</li></ul><p>应用的组件通常会定义很多视图，并进行分级组织。 Angular 提供了 <code>Router</code> 服务来帮助你定义视图之间的导航路径。 路由器提供了先进的浏览器内导航功能。</p><h2 id="2-2-基本概念"><a href="#2-2-基本概念" class="headerlink" title="2.2-基本概念"></a>2.2-基本概念</h2><h3 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1-模块"></a>2.2.1-模块</h3><p>Angular 定义了 <code>NgModule</code>，它和 JavaScript（ES2015） 的模块不同而且有一定的互补性。 NgModule 为一个组件集声明了编译的上下文环境，它专注于某个应用领域、某个工作流或一组紧密相关的能力。 NgModule 可以将其组件和一组相关代码（如服务）关联起来，形成功能单元。</p><p>每个 Angular 应用都有一个<em>根模块</em>，通常命名为 <code>AppModule</code>。根模块提供了用来启动应用的引导机制。 一个应用通常会包含很多功能模块。</p><p>像 JavaScript 模块一样，NgModule 也可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。 比如，要在你的应用中使用路由器（Router）服务，就要导入 <code>Router</code> 这个 NgModule。</p><p>把你的代码组织成一些清晰的功能模块，可以帮助管理复杂应用的开发工作并实现可复用性设计。 另外，这项技术还能让你获得<em>惰性加载</em>（也就是按需加载模块）的优点，以尽可能减小启动时需要加载的代码体积。</p><h3 id="2-2-2-组件"><a href="#2-2-2-组件" class="headerlink" title="2.2.2-组件"></a>2.2.2-组件</h3><p>每个 Angular 应用都至少有一个组件，也就是<em>根组件</em>，它会把组件树和页面中的 DOM 连接起来。 每个组件都会定义一个类，其中包含应用的数据和逻辑，并与一个 HTML <em>模板</em>相关联，该模板定义了一个供目标环境下显示的视图。</p><p><code>@Component()</code> 装饰器表明紧随它的那个类是一个组件，并提供模板和该组件专属的元数据。</p><h3 id="2-2-3-模板、指令和数据绑定"><a href="#2-2-3-模板、指令和数据绑定" class="headerlink" title="2.2.3-模板、指令和数据绑定"></a>2.2.3-模板、指令和数据绑定</h3><p>模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。 模板中的<em>指令</em>会提供程序逻辑，而<em>绑定标记</em>会把你应用中的数据和 DOM 连接在一起。 有两种类型的数据绑定：</p><ul><li><em>事件绑定</em>让你的应用可以通过更新应用的数据来响应目标环境下的用户输入。</li><li><em>属性绑定</em>让你将从应用数据中计算出来的值插入到 HTML 中。</li></ul><p>在视图显示出来之前，Angular 会先根据你的应用数据和逻辑来运行模板中的指令并解析绑定表达式，以修改 HTML 元素和 DOM。 Angular 支持<em>双向数据绑定</em>，这意味着 DOM 中发生的变化（比如用户的选择）同样可以反映回你的程序数据中。</p><p>你的模板也可以用<em>管道</em>转换要显示的值以增强用户体验。比如，可以使用管道来显示适合用户所在地区的日期和货币格式。 Angular 为一些通用的转换提供了预定义管道，你还可以定义自己的管道。</p><h3 id="2-2-4-服务与依赖注入"><a href="#2-2-4-服务与依赖注入" class="headerlink" title="2.2.4-服务与依赖注入"></a>2.2.4-服务与依赖注入</h3><p>对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建<em>服务</em>类。 服务类的定义通常紧跟在 “@Injectable()” 装饰器之后。该装饰器提供的元数据可以让你的服务作为依赖<em>被注入到</em>客户组件中。</p><p><em>依赖注入</em>（或 DI）让你可以保持组件类的精简和高效。有了 DI，组件就不用从服务器获取数据、验证用户输入或直接把日志写到控制台，而是会把这些任务委托给服务。</p><h3 id="2-2-5-路由"><a href="#2-2-5-路由" class="headerlink" title="2.2.5-路由"></a>2.2.5-路由</h3><p>Angular 的 <code>Router</code> 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。 它的工作模型基于人们熟知的浏览器导航约定：</p><ul><li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li><li>在页面中点击链接，浏览器就会导航到一个新页面。</li><li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li></ul><p>不过路由器会把类似 URL 的路径映射到视图而不是页面。 当用户执行一个动作时（比如点击链接），本应该在浏览器中加载一个新页面，但是路由器拦截了浏览器的这个行为，并显示或隐藏一个视图层次结构。</p><p>如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需<em>惰性加载</em>此模块。</p><p>路由器会根据你应用中的导航规则和数据状态来拦截 URL。 当用户点击按钮、选择下拉框或收到其它任何来源的输入时，你可以导航到一个新视图。 路由器会在浏览器的历史日志中记录这个动作，所以前进和后退按钮也能正常工作。</p><p>要定义导航规则，你就要把<em>导航路径</em>和你的组件关联起来。 路径（path）使用类似 URL 的语法来和程序数据整合在一起，就像模板语法会把你的视图和程序数据整合起来一样。 然后你就可以用程序逻辑来决定要显示或隐藏哪些视图，以根据你制定的访问规则对用户的输入做出响应。</p><p><strong>注：</strong>这些基础部门之间是如何关联的呢？</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Angular.jpeg"></p><ul><li>组件和模板共同定义了 Angular 的视图。<ul><li>组件类上的装饰器为其添加了元数据，其中包括指向相关模板的指针。</li><li>组件模板中的指令和绑定标记会根据程序数据和程序逻辑修改这些视图。</li></ul></li><li>依赖注入器会为组件提供一些服务，比如路由器服务就能让你定义如何在视图之间导航。</li></ul><h2 id="2-3-模块NgModule"><a href="#2-3-模块NgModule" class="headerlink" title="2.3-模块NgModule"></a>2.3-模块NgModule</h2><ol><li>NgModule简介</li></ol><p>Angular 应用是模块化的，它拥有自己的模块化系统，称作 <em>NgModule</em>。 一个 NgModule 就是一个容器，用于存放一些内聚的代码块，这些代码块专注于某个应用领域、某个工作流或一组紧密相关的功能。 它可以包含一些组件、服务提供商或其它代码文件，其作用域由包含它们的 NgModule 定义。 它还可以导入一些由其它模块中导出的功能，并导出一些指定的功能供其它 NgModule 使用。</p><p>每个 Angular 应用都至少有一个 NgModule 类，也就是<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/bootstrapping">根模块</a>，它习惯上命名为 <code>AppModule</code>，并位于一个名叫 <code>app.module.ts</code> 的文件中。<em>引导</em>这个根模块就可以启动你的应用。</p><p>虽然小型的应用可能只有一个 NgModule，不过大多数应用都会有很多<em>特性模块</em>。应用的<em>根模块</em>之所以叫根模块，是因为它可以包含任意深度的层次化子模块。</p><ol start="2"><li><p>@NgModule 元数据</p><p>NgModule 是一个带有 <code>@NgModule()</code> 装饰器的类。<code>@NgModule()</code> 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。</p><ul><li><p><code>declarations</code>（可声明对象表） —— 那些属于本 NgModule 的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/architecture-components">组件</a>、<em>指令</em>、<em>管道</em>。</p></li><li><p><code>exports</code>（导出表） —— 那些能在其它模块的<em>组件模板</em>中使用的可声明对象的子集。</p></li><li><p><code>imports</code>（导入表） —— 那些导出了<em>本</em>模块中的组件模板所需的类的其它模块。</p></li><li><p><code>providers</code> —— 本模块向全局服务中贡献的那些<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/architecture-services">服务</a>的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供商，这通常是首选方式。）</p></li><li><p><code>bootstrap</code> —— 应用的主视图，称为<em>根组件</em>。它是应用中所有其它视图的宿主。只有<em>根模块</em>才应该设置这个 <code>bootstrap</code> 属性。</p></li><li><p>一个简单的根 NgModule 定义：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;      <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>:      [ BrowserModule ],</span><br><span class="line">  <span class="attr">providers</span>:    [ Logger ],</span><br><span class="line">  <span class="attr">declarations</span>: [ AppComponent ],</span><br><span class="line">  <span class="attr">exports</span>:      [ AppComponent ],</span><br><span class="line">  <span class="attr">bootstrap</span>:    [ AppComponent ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NgModule 和组件</p><p>NgModule 为其中的组件提供了一个<em>编译上下文环境</em>。根模块总会有一个根组件，并在引导期间创建它。 但是，任何模块都能包含任意数量的其它组件，这些组件可以通过路由器加载，也可以通过模板创建。那些属于这个 NgModule 的组件会共享同一个编译上下文环境。</p><p>组件及其模板共同定义<em>视图</em>。组件还可以包含<em>视图层次结构</em>，它能让你定义任意复杂的屏幕区域，可以将其作为一个整体进行创建、修改和销毁。 一个视图层次结构中可以混合使用由不同 NgModule 中的组件定义的视图。</p></li><li><p>Angular 自带的库</p><p>Angular 会作为一组 JavaScript 模块进行加载，你可以把它们看成库模块。每个 Angular 库的名称都带有 <code>@angular</code> 前缀。 使用 <code>npm</code> 包管理器安装 Angular 的库，并使用 JavaScript 的 <code>import</code> 语句导入其中的各个部分。</p><p>例如，像下面这样，从 <code>@angular/core</code> 库中导入 Angular 的 <code>Component</code> 装饰器</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-4-组件"><a href="#2-4-组件" class="headerlink" title="2.4-组件"></a>2.4-组件</h2><p>组件<em>控制屏幕上被称为</em>视图*的一小片区域。比如，<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/tutorial/index">教程</a>中的下列视图都是由一个个组件所定义和控制的：</p><ul><li>带有导航链接的应用根组件。</li><li>英雄列表。</li><li>英雄编辑器。</li></ul><p>你在类中定义组件的应用逻辑，为视图提供支持。 组件通过一些由属性和方法组成的 API 与视图交互。</p><p>比如，<code>HeroListComponent</code> 中有一个 名为<code>heroes</code>的属性，它储存着一个数组的英雄数据。 <code>HeroListComponent</code> 还有一个 <code>selectHero()</code> 方法，当用户从列表中选择一个英雄时，它会设置 <code>selectedHero</code> 属性的值。 该组件会从服务获取英雄列表，它是一个 TypeScript 的构造器<a target="_blank" rel="noopener" href="http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties">参数型属性</a>。本服务通过依赖注入系统提供给该组件。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="attr">heroes</span>: Hero[];</span><br><span class="line">  selectedHero: Hero;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> service: HeroService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.heroes = <span class="built_in">this</span>.service.getHeroes();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">selectHero</span>(<span class="params">hero: Hero</span>)</span> &#123; <span class="built_in">this</span>.selectedHero = hero; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户在应用中穿行时，Angular 就会创建、更新、销毁一些组件。 你的应用可以通过一些可选的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/lifecycle-hooks">生命周期钩子</a>（比如<code>ngOnInit()</code>）来在每个特定的时机采取行动。</p><ol><li><p>组件的元数据</p><p><code>@Component</code> 装饰器会指出紧随其后的那个类是个组件类，并为其指定元数据。 在下面的范例代码中，你可以看到 <code>HeroListComponent</code> 只是一个普通类，完全没有 Angular 特有的标记或语法。 直到给它加上了 <code>@Component</code> 装饰器，它才变成了组件。</p><p>组件的元数据告诉 Angular 到哪里获取它需要的主要构造块，以创建和展示这个组件及其视图。 具体来说，它把一个<em>模板</em>（无论是直接内联在代码中还是引用的外部文件）和该组件关联起来。 该组件及其模板，共同描述了一个<em>视图</em>。</p><p>除了包含或指向模板之外，<code>@Component</code> 的元数据还会配置要如何在 HTML 中引用该组件，以及该组件需要哪些服务等等。</p><p>下面的例子中就是 <code>HeroListComponent</code> 的基础元数据：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>:    <span class="string">&#x27;app-hero-list&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./hero-list.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>:  [ HeroService ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了一些最常用的 <code>@Component</code> 配置选项：</p><ul><li><code>selector</code>：是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 比如，如果应用的 HTML 中包含 ``，Angular 就会在这些标签中插入一个 <code>HeroListComponent</code> 实例的视图。</li><li><code>templateUrl</code>：该组件的 HTML 模板文件相对于这个组件文件的地址。 另外，你还可以用 <code>template</code> 属性的值来提供内联的 HTML 模板。 这个模板定义了该组件的<em>宿主视图</em>。</li><li><code>providers</code>：当前组件所需的服务<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/glossary#provider">提供商</a>的一个数组。在这个例子中，它告诉 Angular 该如何提供一个 <code>HeroService</code> 实例，以获取要显示的英雄列表。</li></ul></li><li><p>模板与视图</p><p>你要通过组件的配套模板来定义其视图。模板就是一种 HTML，它会告诉 Angular 如何渲染该组件。</p><p>视图通常会分层次进行组织，让你能以 UI 分区或页面为单位进行修改、显示或隐藏。 与组件直接关联的模板会定义该组件的<em>宿主视图</em>。该组件还可以定义一个<em>带层次结构的视图</em>，它包含一些<em>内嵌的视图</em>作为其它组件的宿主。</p><p>带层次结构的视图可以包含同一模块（NgModule）中组件的视图，也可以（而且经常会）包含其它模块中定义的组件的视图。</p></li><li><p>模板语法</p><p>模板很像标准的 HTML，但是它还包含 Angular 的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax">模板语法</a>，这些模板语法可以根据你的应用逻辑、应用状态和 DOM 数据来修改这些 HTML。 你的模板可以使用<em>数据绑定</em>来协调应用和 DOM 中的数据，使用<em>管道</em>在显示出来之前对其进行转换，使用<em>指令</em>来把程序逻辑应用到要显示的内容上。</p><p>比如，下面是本教程中 <code>HeroListComponent</code> 的模板：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hero List<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>Pick a hero from the list<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;selectHero(hero)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;hero.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">&quot;selectedHero&quot;</span> [<span class="attr">hero</span>]=<span class="string">&quot;selectedHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个模板使用了典型的 HTML 元素，比如 <code>和</code>，还包括一些 Angular 的模板语法元素，如 <code>*ngFor</code>，<code>&#123;&#123;hero.name&#125;&#125;</code>，<code>click</code>、<code>[hero]</code> 和 ``。这些模板语法元素告诉 Angular 该如何根据程序逻辑和数据在屏幕上渲染 HTML。</p><ul><li><code>*ngFor</code> 指令告诉 Angular 在一个列表上进行迭代。</li><li><code>&#123;&#123;hero.name&#125;&#125;</code>、<code>(click)</code> 和 <code>[hero]</code> 把程序数据绑定到及绑定回 DOM，以响应用户的输入。更多内容参见稍后的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/architecture-components#data-binding">数据绑定</a>部分。</li><li>模板中的 `` 标签是一个代表新组件 <code>HeroDetailComponent</code> 的元素。 <code>HeroDetailComponent</code>（代码略）定义了 <code>HeroListComponent</code> 的英雄详情子视图。 注意观察像这样的自定义组件是如何与原生 HTML 元素无缝的混合在一起的。</li></ul></li><li><p>数据绑定</p><p>如果没有框架，你就要自己负责把数据值推送到 HTML 控件中，并把来自用户的响应转换成动作和对值的更新。 手动写这种数据推拉逻辑会很枯燥、容易出错，难以阅读 —— 有前端 JavaScript 开发经验的程序员一定深有体会。</p><p>Angular 支持<em>双向数据绑定</em>，这是一种对模板中的各个部件与组件中的各个部件进行协调的机制。 往模板 HTML 中添加绑定标记可以告诉 Angular 该如何连接它们。</p><p>下图显示了数据绑定标记的四种形式。每种形式都有一个方向 —— 从组件到 DOM、从 DOM 到组件或双向。</p></li></ol><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.jpeg"></p><pre><code>`HeroListComponent` 模板中的例子使用了其中的三种形式：
</code></pre><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> [<span class="attr">hero</span>]=<span class="string">&quot;selectedHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> (<span class="attr">click</span>)=<span class="string">&quot;selectHero(hero)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&#123;&#123;hero.name&#125;&#125;</code><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/displaying-data#interpolation"><em>插值表达式</em></a>在 `` 标签中显示组件的 <code>hero.name</code> 属性的值。</li><li><code>[hero]</code><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#property-binding"><em>属性绑定</em></a>把父组件 <code>HeroListComponent</code> 的 <code>selectedHero</code> 的值传到子组件 <code>HeroDetailComponent</code> 的 <code>hero</code> 属性中。</li><li>当用户点击某个英雄的名字时，<code>(click)</code> <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/user-input#binding-to-user-input-events"><em>事件绑定</em></a>会调用组件的 <code>selectHero</code> 方法。</li></ul><p><strong>双向数据绑定</strong>（主要用于<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/forms">模板驱动表单</a>中），它会把属性绑定和事件绑定组合成一种单独的写法。</p><pre><code>`HeroDetailComponent` 模板中的例子通过 `ngModel` 指令使用了双向数据绑定：
</code></pre><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;hero.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。</p><p>Angular 在每个 JavaScript 事件循环中处理<em>所有的</em>数据绑定，它会从组件树的根部开始，递归处理全部子组件。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.jpeg"></p><p>数据绑定在模板及其组件之间的通讯中扮演了非常重要的角色，它对于父组件和子组件之间的通讯也同样重要。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.png"></p><ol start="5"><li><p>管道</p><p>Angular 的管道可以让你在模板中声明显示值的转换逻辑。 带有 <code>@Pipe</code> 装饰器的类中会定义一个转换函数，用来把输入值转换成供视图显示用的输出值。</p><p>Angular 自带了很多管道，比如 <a target="_blank" rel="noopener" href="https://angular.cn/api/common/DatePipe">date</a> 管道和 <a target="_blank" rel="noopener" href="https://angular.cn/api/common/CurrencyPipe">currency</a> 管道，完整的列表参见 <a target="_blank" rel="noopener" href="https://angular.cn/api?type=pipe">Pipes API 列表</a>。你也可以自己定义一些新管道。</p><p>要在 HTML 模板中指定值的转换方式，请使用 <a target="_blank" rel="noopener" href="https://angular.cn/guide/template-syntax#pipe">管道操作符 (|)</a>。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;interpolated_value | pipe_name&#125;&#125;</span><br></pre></td></tr></table></figure><p>你可以把管道串联起来，把一个管道函数的输出送给另一个管道函数进行转换。 管道还能接收一些参数，来控制它该如何进行转换。</p><p>比如，你可以把要使用的日期格式传给 <code>date</code> 管道：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Default format: output &#x27;Jun 15, 2015&#x27;--&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Today is &#123;&#123;today | date&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- fullDate format: output &#x27;Monday, June 15, 2015&#x27;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The date is &#123;&#123;today | date:&#x27;fullDate&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- shortTime format: output &#x27;9:43 AM&#x27;--&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>The time is &#123;&#123;today | date:&#x27;shortTime&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>指令</p><p>Angular 的模板是<em>动态的</em>。当 Angular 渲染它们的时候，会根据<em>指令</em>给出的指示对 DOM 进行转换。 指令就是一个带有 <code>@Directive()</code> 装饰器的类。</p><p>组件从技术角度上说就是一个指令，但是由于组件对 Angular 应用来说非常独特、非常重要，因此 Angular 专门定义了 <code>@Component()</code> 装饰器，它使用一些面向模板的特性扩展了 <code>@Directive()</code> 装饰器。</p><p>除组件外，还有两种指令：<em>结构型指令</em>和<em>属性型指令</em>。 Angular 本身定义了一系列这两种类型的指令，你也可以使用 <code>@Directive()</code> 装饰器来定义自己的指令。</p><p>像组件一样，指令的元数据把它所装饰的指令类和一个 <code>selector</code> 关联起来，<code>selector</code> 用来把该指令插入到 HTML 中。 在模板中，指令通常作为属性出现在元素标签上，可能仅仅作为名字出现，也可能作为赋值目标或绑定目标出现。</p><ul><li><p>结构型指令</p><p><em>结构型指令</em>通过添加、移除或替换 DOM 元素来修改布局。</p><p>这个范例模板使用了两个内置的结构型指令来为要渲染的视图添加程序逻辑：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">&quot;selectedHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/displaying-data#ngFor"><code>*ngFor</code></a> 是一个迭代器，它要求 Angular 为 <code>heroes</code> 列表中的每个英雄渲染出一个 ``。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/displaying-data#ngIf"><code>*ngIf</code></a> 是个条件语句，只有当选中的英雄存在时，它才会包含 <code>HeroDetail</code> 组件。</li></ul></li><li><p>属性型指令</p><p><em>属性型指令</em>会修改现有元素的外观或行为。 在模板中，它们看起来就像普通的 HTML 属性一样，因此得名“属性型指令”。</p><p><code>ngModel</code> 指令就是属性型指令的一个例子，它实现了双向数据绑定。 <code>ngModel</code> 修改现有元素（一般是 ``）的行为：设置其显示属性值，并响应 change 事件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;hero.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular 还有很多预定义指令既不修改布局结构（比如 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ngSwitch">ngSwitch</a>），也不修改 DOM 元素和组件的样子（比如 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ngStyle">ngStyle</a> 和 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ngClass">ngClass</a>）。</p></li></ul></li></ol><h2 id="2-5-服务与依赖注入"><a href="#2-5-服务与依赖注入" class="headerlink" title="2.5-服务与依赖注入"></a>2.5-服务与依赖注入</h2><p><em>服务</em>是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。</p><p>Angular 把组件和服务区分开，以提高模块性和复用性。 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。</p><p>理想情况下，组件的工作只管用户体验，而不用顾及其它。 它应该提供用于数据绑定的属性和方法，以便作为视图（由模板渲染）和应用逻辑（通常包含一些<em>模型</em>的概念）的中介者。</p><p>组件应该把诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。</p><p>Angular 不会<em>强迫</em>你遵循这些原则。Angular 只会通过<em>依赖注入</em>来帮你更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。</p><ol><li><p>服务案例</p><p>下面是一个服务类的范例，用于把日志记录到浏览器的控制台：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">log</span>(<span class="params">msg: <span class="built_in">any</span></span>)</span>   &#123; <span class="built_in">console</span>.log(msg); &#125;</span><br><span class="line">  <span class="function"><span class="title">error</span>(<span class="params">msg: <span class="built_in">any</span></span>)</span> &#123; <span class="built_in">console</span>.error(msg); &#125;</span><br><span class="line">  <span class="function"><span class="title">warn</span>(<span class="params">msg: <span class="built_in">any</span></span>)</span>  &#123; <span class="built_in">console</span>.warn(msg); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务也可以依赖其它服务。比如，这里的 <code>HeroService</code> 就依赖于 <code>Logger</code> 服务，它还用 <code>BackendService</code> 来获取英雄数据。<code>BackendService</code> 还可能再转而依赖 <code>HttpClient</code> 服务来从服务器异步获取英雄列表。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> heroes: Hero[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span> backend: BackendService,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span> logger: Logger</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getHeroes</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.backend.getAll(Hero).then( <span class="function">(<span class="params">heroes: Hero[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.logger.log(<span class="string">`Fetched <span class="subst">$&#123;heroes.length&#125;</span> heroes.`</span>);</span><br><span class="line">      <span class="built_in">this</span>.heroes.push(...heroes); <span class="comment">// fill cache</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.heroes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>依赖注入</p><p>DI 被融入 Angular 框架中，用于在任何地方给新建的组件提供服务或所需的其它东西。 组件是服务的消费者，也就是说，你可以把一个服务<em>注入</em>到组件中，让组件类得以访问该服务类。</p><p>在 Angular 中，要把一个类定义为服务，就要用 <code>@Injectable()</code> 装饰器来提供元数据，以便让 Angular 可以把它作为<em>依赖</em>注入到组件中。 同样，也要使用 <code>@Injectable()</code> 装饰器来表明一个组件或其它类（比如另一个服务、管道或 NgModule）<em>拥有</em>一个依赖。</p><ul><li><em>注入器</em>是主要的机制。Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建注入器。</li><li>该注入器会创建依赖、维护一个<em>容器</em>来管理这些依赖，并尽可能复用它们。</li><li><em>提供商</em>是一个对象，用来告诉注入器应该如何获取或创建依赖。</li></ul><p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个提供商，以便注入器可以使用这个提供商来创建新实例。 对于服务，该提供商通常就是服务类本身。</p><p>当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。 比如 <code>HeroListComponent</code> 的构造函数中需要 <code>HeroService</code>：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> service: HeroService</span>)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在，注入器就会使用以前注册的服务提供商来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p><p>当所有请求的服务已解析并返回时，Angular 可以用这些服务实例为参数，调用该组件的构造函数。</p><p><code>HeroService</code> 的注入过程如下所示：</p></li></ol><p><img src="https://gitee.com/lemon-cs/images/raw/master/HeroService%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B.jpeg"></p><ol start="3"><li><p>提供服务</p><p>对于要用到的任何服务，你必须至少注册一个<em>提供商</em>。服务可以在自己的元数据中把自己注册为提供商，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供商。要注册提供商，就要在服务的 <code>@Injectable()</code> 装饰器中提供它的元数据，或者在<code>@NgModule()</code> 或 <code>@Component()</code> 的元数据中。</p><ul><li>默认情况下，Angular CLI 的 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/cli/generate"><code>ng generate service</code></a> 命令会在 <code>@Injectable()</code> 装饰器中提供元数据来把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供商：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content_copy@Injectable(&#123;  providedIn: &#x27;root&#x27;, &#125;)</span><br></pre></td></tr></table></figure><p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。这种在 <code>@Injectable</code> 元数据中注册提供商的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小。</p><ul><li>当你使用<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/architecture-modules">特定的 NgModule</a> 注册提供商时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 <code>@NgModule()</code> 装饰器中的 <code>providers</code> 属性：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content_copy@NgModule(&#123;  providers: [   BackendService,   Logger ], ... &#125;)</span><br></pre></td></tr></table></figure><ul><li><p>当你在组件级注册提供商时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 <code>@Component()</code> 元数据的 <code>providers</code> 属性中注册服务提供商。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>:    <span class="string">&#x27;app-hero-list&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./hero-list.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">providers</span>:  [ HeroService ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="2-6-工具与技巧"><a href="#2-6-工具与技巧" class="headerlink" title="2.6-工具与技巧"></a>2.6-工具与技巧</h2><h3 id="响应式编程工具"><a href="#响应式编程工具" class="headerlink" title="响应式编程工具"></a>响应式编程工具</h3><ul><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/lifecycle-hooks">生命周期钩子</a>：通过实现生命周期钩子接口，可以窃听组件生命周期中的一些关键时刻 —— 从创建到销毁。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/observables">可观察对象（Observable）和事件处理</a>：如何在组件和服务中使用可观察对象来发布和订阅任意类型的消息，比如用户交互事件和异步操作结果。</li></ul><h3 id="客户端与服务器的交互工具"><a href="#客户端与服务器的交互工具" class="headerlink" title="客户端与服务器的交互工具"></a>客户端与服务器的交互工具</h3><ul><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/http">HTTP</a>：用 HTTP 客户端与服务器通讯，以获取数据、保存数据或执行服务端动作。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/universal">服务端渲染</a>：Angular Universal 会通过服务端渲染（SSR）技术在服务器上生成静态的应用页面。 这让你可以在服务器上运行 Angular 应用，以提升性能并在手机或低功耗设备上快速显示首屏，并为 Web 爬虫提供帮助（SEO）。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/service-worker-intro">Service Worker</a>：借助 Service Worker 来减轻对网络的依赖，你可以显著提升用户体验。</li></ul><h3 id="特定领域的库"><a href="#特定领域的库" class="headerlink" title="特定领域的库"></a>特定领域的库</h3><ul><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/animations">动画</a>：使用 Angular 的动画库，你可以让组件支持动画行为，而不用深入了解动画技术或 CSS。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/forms">Forms</a>：通过基于 HTML 的验证和脏数据检查，来支持复杂的数据输入场景。</li></ul><h3 id="为开发周期提供支持"><a href="#为开发周期提供支持" class="headerlink" title="为开发周期提供支持"></a>为开发周期提供支持</h3><ul><li><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/aot-compiler">编译</a>：Angular 为开发环境提供了 JIT（即时）编译方式，为生产环境提供了 AOT（预先）编译方式。</p></li><li><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/testing">测试平台</a>：对应用的各个部件运行单元测试，让它们好像在和 Angular 框架交互一样。</p></li><li><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/i18n">国际化</a>：Angular 的国际化工具可以帮助你让应用可用于多种语言中。</p></li><li><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/security">安全指南</a>：学习 Angular 对常见 Web 应用的弱点和工具（比如跨站脚本攻击）提供的内置防护措施。</p></li></ul><h3 id="环境搭建、构建与开发配置"><a href="#环境搭建、构建与开发配置" class="headerlink" title="环境搭建、构建与开发配置"></a>环境搭建、构建与开发配置</h3><ul><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/cli">CLI 命令参考手册</a>：Angular CLI 是一个命令行工具，你可以使用它来创建项目、生成应用及库代码，还能执行很多开发任务，比如测试、打包和发布。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/file-structure">工作区与文件结构</a>：理解 Angular 工作区与项目文件夹的结构。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/npm-packages">npm 包</a>：Angular 框架、Angular CLI 和 Angular 应用中用到的组件都是用 <a target="_blank" rel="noopener" href="https://docs.npmjs.com/">npm</a> 打包的，并通过 npm 注册服务器进行发布。Angular CLI 会创建一个默认的 <code>package.json</code> 文件，它会指定一组初始的包，它们可以一起使用，共同支持很多常见的应用场景。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/typescript-configuration">TypeScript 配置</a>：TypeScript 是 Angular 应用开发的主要语言。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/browser-support">浏览器支持</a>：学习如何让你的应用能和各种浏览器兼容。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/build">构建与运行</a>：学习为项目定义不同的构建和代理服务器设置的配置方式，比如开发、预生产和生产。</li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/deployment">部署</a>：学习把你的 Angular 应用发布到远端服务器的技巧。</li></ul><h1 id="3-组件与模板"><a href="#3-组件与模板" class="headerlink" title="3-组件与模板"></a>3-组件与模板</h1><h2 id="3-1-显示数据"><a href="#3-1-显示数据" class="headerlink" title="3.1-显示数据"></a>3.1-显示数据</h2><ol><li><p>使用插件表达式显示组件属性</p><p>要显示组件的属性，最简单的方式就是通过插值表达式 (interpolation) 来绑定属性名。 要使用插值表达式，就把属性名包裹在双花括号里放进视图模板，如 <code>&#123;&#123;myHero&#125;&#125;</code>。</p><p>使用 CLI 命令 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/cli/new"><code>ng new displaying-data</code></a> 创建一个工作空间和一个名叫 <code>displaying-data</code> 的应用。</p><p>删除 <code>app.component.html</code> 文件，这个范例中不再需要它了。</p><p>然后，到 <code>app.component.ts</code> 文件中修改组件的模板和代码。</p><p>修改完之后，它应该是这样的：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-root&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;My favorite hero is: &#123;&#123;myHero&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">&#x27;Tour of Heroes&#x27;</span>;</span><br><span class="line">  myHero = <span class="string">&#x27;Windstorm&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再把两个属性 <code>title</code> 和 <code>myHero</code> 添加到之前空白的组件中。</p><p>修改完的模板会使用双花括号形式的插值表达式来显示这两个模板属性：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;My favorite hero is: &#123;&#123;myHero&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br></pre></td></tr></table></figure><p>Angular 自动从组件中提取 <code>title</code> 和 <code>myHero</code> 属性的值，并且把这些值插入浏览器中。当这些属性发生变化时，Angular 就会自动刷新显示。</p><p><strong>注意</strong>：你没有调用 <strong>new</strong> 来创建 <code>AppComponent</code> 类的实例，是 Angular 替你创建了它。那么它是如何创建的呢？</p><p><strong>注意</strong> ：<code>@Component</code> 装饰器中指定的 CSS 选择器 <code>selector</code>，它指定了一个叫 `` 的元素。 该元素是 <code>index.html</code> 文件里的一个占位符。</p><p>src/index.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-root</span>&gt;</span><span class="tag">&lt;/<span class="name">app-root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你通过 <code>main.ts</code> 中的 <code>AppComponent</code> 类启动时，Angular 在 <code>index.html</code> 中查找一个 <code>元素， 然后实例化一个 `AppComponent`，并将其渲染到</code> 标签中。</p><p>运行应用。它应该显示出标题和英雄名：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/title-and-hero.jpeg"></p></li><li><p>内联模板还是模板文件？</p><p>你可以在两种地方存放组件模板。 你可以使用 <code>template</code> 属性把它定义为<em>内联</em>的，或者把模板定义在一个独立的 HTML 文件中， 再通过 <code>@Component</code> 装饰器中的 <code>templateUrl</code> 属性， 在组件元数据中把它链接到组件。</p><p>到底选择内联 HTML 还是独立 HTML 取决于个人喜好、具体状况和组织级策略。 上面的应用选择内联 HTML ，是因为模板很小，而且没有额外的 HTML 文件显得这个演示简单些。</p><p>无论用哪种风格，模板数据绑定在访问组件属性方面都是完全一样的。</p><p>默认情况下，Angular CLI 命令 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/cli/generate"><code>ng generate component</code></a> 在生成组件时会带有模板文件，你可以通过参数来覆盖它</p></li><li><p>使用构造函数还是变量初始化？</p><p>虽然这个例子使用了变量赋值的方式初始化组件，你还可以使用构造函数来声明和初始化属性。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  myHero: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.title = <span class="string">&#x27;Tour of Heroes&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.myHero = <span class="string">&#x27;Windstorm&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ngFor显示数组属性</p><p>要显示一个英雄列表，先向组件中添加一个英雄名字数组，然后把 <code>myHero</code> 重定义为数组中的第一个名字。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">  title = <span class="string">&#x27;Tour of Heroes&#x27;</span>;</span><br><span class="line">  heroes = [<span class="string">&#x27;Windstorm&#x27;</span>, <span class="string">&#x27;Bombasto&#x27;</span>, <span class="string">&#x27;Magneta&#x27;</span>, <span class="string">&#x27;Tornado&#x27;</span>];</span><br><span class="line">  myHero = <span class="built_in">this</span>.heroes[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，在模板中使用 Angular 的 <code>ngFor</code> 指令来显示 <code>heroes</code> 列表中的每一项</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;My favorite hero is: &#123;&#123;myHero&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;Heroes:&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; hero &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>这个界面使用了由 <code>和</code> 标签组成的无序列表。<code>元素里的 `*ngFor` 是 Angular 的“迭代”指令。 它将</code> 元素及其子级标记为“迭代模板”：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; hero &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/lemon-cs/images/raw/master/hero-names-list.jpeg"></p></li><li><p>为数据创建一个类</p><p>应用代码直接在组件内部直接定义了数据。 作为演示还可以，但它显然不是最佳实践。</p><p>现在使用的是到了一个字符串数组的绑定。在真实的应用中，大多是到一个对象数组的绑定。</p><p>要将此绑定转换成使用对象，需要把这个英雄名字数组变成 <code>Hero</code> 对象数组。但首先得有一个 <code>Hero</code> 类。</p><p><code>ng generate class hero</code></p><p>代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> id: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你定义了一个类，具有一个构造函数和两个属性：<code>id</code> 和 <code>name</code>。</p><p>它可能看上去不像是有属性的类，但它确实有，利用的是 TypeScript 提供的简写形式 —— 用构造函数的参数直接定义属性。</p><p>来看第一个参数：</p><p><code>public id: number,</code>这个简写语法做了很多：</p><ul><li>声明了一个构造函数参数及其类型。</li><li>声明了一个同名的公共属性。</li><li>当创建该类的一个实例时，把该属性初始化为相应的参数值。</li></ul><p><strong>使用Hero类：</strong></p><p>导入了 <code>Hero</code> 类之后，组件的 <code>heroes</code> 属性就可以返回一个<em>类型化的</em><code>Hero</code> 对象数组了</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">heroes = [</span><br><span class="line">  <span class="keyword">new</span> Hero(<span class="number">1</span>, <span class="string">&#x27;Windstorm&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> Hero(<span class="number">13</span>, <span class="string">&#x27;Bombasto&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> Hero(<span class="number">15</span>, <span class="string">&#x27;Magneta&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> Hero(<span class="number">20</span>, <span class="string">&#x27;Tornado&#x27;</span>)</span><br><span class="line">];</span><br><span class="line">myHero = <span class="built_in">this</span>.heroes[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>接着，修改模板。 现在它显示的是英雄的 <code>id</code> 和 <code>name</code>。 要修复它，只显示英雄的 <code>name</code> 属性就行了。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;My favorite hero is: &#123;&#123;myHero.name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;Heroes:&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; hero.name &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></li><li><p>通过ngIf进行条件显示</p><p>有时，应用需要只在特定情况下显示视图或视图的一部分。</p><p>来改一下这个例子，如果多于三位英雄，显示一条消息。</p><p>Angular 的 <code>ngIf</code> 指令会根据一个布尔条件来显示或移除一个元素。 来看看实际效果，把下列语句加到模板的底部：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">ngIf</span>=<span class="string">&quot;heroes.length &gt; 3&quot;</span>&gt;</span>There are many heroes!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>双引号中的模板表达式 <code>*ngIf=&quot;heros.length &gt; 3&quot;</code>，外观和行为很象 TypeScript 。 当组件中的英雄列表有三个以上的条目时，Angular 就会把这个段落添加到 DOM 中，于是消息显示了出来。 如果有三个或更少的条目，则 Angular 会省略这些段落，所以不显示消息。</p><p>Angular 并不是在显示和隐藏这条消息，它是在从 DOM 中添加和移除这个段落元素。 这会提高性能，特别是在一些大的项目中有条件地包含或排除一大堆带着很多数据绑定的 HTML 时。</p></li></ol><h2 id="3-2-模板语法"><a href="#3-2-模板语法" class="headerlink" title="3.2-模板语法"></a>3.2-模板语法</h2><p>Angular 应用管理着用户之所见和所为，并通过 Component 类的实例（<em>组件</em>）和面向用户的模板交互来实现这一点。</p><p>从使用模型-视图-控制器 (MVC) 或模型-视图-视图模型 (MVVM) 的经验中，很多开发人员都熟悉了组件和模板这两个概念。 在 Angular 中，组件扮演着控制器或视图模型的角色，模板则扮演视图的角色。</p><ol><li><p>模板中的HTML</p><p>HTML 是 Angular 模板的语言。几乎所有的 HTML 语法都是有效的模板语法。 但值得注意的例外是 <code>元素，它被禁用了，以阻止脚本注入攻击的风险。（实际上，</code> 只是被忽略了。）</p><p>有些合法的 HTML 被用在模板中是没有意义的。<code>、</code> 和 `` 元素这个舞台上中并没有扮演有用的角色。剩下的所有元素基本上就都一样用了。</p><p>可以通过组件和指令来扩展模板中的 HTML 词汇。它们看上去就是新元素和属性。接下来将学习如何通过数据绑定来动态获取/设置 DOM（文档对象模型）的值。</p><p>首先看看数据绑定的第一种形式 —— 插值表达式，它展示了模板的 HTML 可以有多丰富。</p></li><li><p>插值与模板表达式</p><p>插值能让你把计算后的字符串合并到 HTML 元素标签之间和属性赋值语句内的文本中。模板表达式则是用来供你求出这些字符串的。</p><ul><li><p>插值表达式</p><p>所谓 “插值” 是指将表达式嵌入到标记文本中。 默认情况下，插值表达式会用双花括号 <code>&#123;&#123;`和 `&#125;&#125;</code> 作为分隔符。</p><p>在下面的代码片段中，<code>&#123;&#123; currentCustomer &#125;&#125;</code> 就是插值表达式的例子。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Current customer: &#123;&#123; currentCustomer &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;itemImageUrl&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在括号之间的“素材”，通常是组件属性的名字。Angular 会用组件中相应属性的字符串值，替换这个名字。 上例中，Angular 计算 <code>title</code> 和 <code>itemImageUrl</code> 属性的值，并把它们填在空白处。 首先显示粗体的应用标题，然后显示英雄的图片。</p><p>一般来说，括号间的素材是一个<strong>模板表达式</strong>，Angular 先<strong>对它求值</strong>，再把它<strong>转换成字符串</strong>。 下列插值表达式通过把括号中的两个数字相加说明了这一点：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &quot;The sum of 1 + 1 is 2&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The sum of 1 + 1 is &#123;&#123;1 + 1&#125;&#125;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个表达式可以调用宿主组件的方法，就像下面用的 <code>getVal()</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &quot;The sum of 1 + 1 is not 4&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The sum of 1 + 1 is not &#123;&#123;1 + 1 + getVal()&#125;&#125;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular 对所有双花括号中的表达式求值，把求值的结果转换成字符串，并把它们跟相邻的字符串字面量连接起来。最后，把这个组合出来的插值结果赋给<strong>元素或指令的属性</strong>。</p><p>从表面上看，你就像是在元素标签之间插入了结果并对标签的属性进行了赋值。</p></li></ul></li><li><p>表达式上下文</p><p>典型的<em>表达式上下文</em>就是这个<strong>组件实例</strong>，它是各种绑定值的来源。 在下面的代码片段中，双花括号中的 <code>recommended</code> 和引号中的 <code>itemImageUrl2</code> 所引用的都是 <code>AppComponent</code> 中的属性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123;recommended&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> [<span class="attr">src</span>]=<span class="string">&quot;itemImageUrl2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表达式的上下文可以包括组件之外的对象。 比如<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-input-variable">模板输入变量</a> (<code>let customer</code>)和<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ref-vars">模板引用变量</a>(<code>#customerInput</code>)就是备选的上下文对象之一。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let customer of customers&quot;</span>&gt;</span>&#123;&#123;customer.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Type something:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> #<span class="attr">customerInput</span>&gt;</span>&#123;&#123;customerInput.value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表达式中的上下文变量是由<em>模板变量</em>、指令的<em>上下文变量</em>（如果有）和组件的<em>成员</em>叠加而成的。 如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。</p></li><li><p>模板语句</p><p>模板<strong>语句</strong>用来响应由绑定目标（如 HTML 元素、组件或指令）触发的<strong>事件</strong>。 模板语句将在<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#event-binding">事件绑定</a>一节看到，它出现在 <code>=</code> 号右侧的引号中，就像这样：<code>(event)=&quot;statement&quot;</code>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;deleteHero()&quot;</span>&gt;</span>Delete hero<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板语句<em>有副作用</em>。 这是事件处理的关键。因为你要根据用户的输入更新应用状态。</p><p>响应事件是 Angular 中“单向数据流”的另一面。 在一次事件循环中，可以随意改变任何地方的任何东西。</p><p>和模板表达式一样，模板<em>语句</em>使用的语言也像 JavaScript。 模板语句解析器和模板表达式解析器有所不同，特别之处在于它支持基本赋值 (<code>=</code>) 和表达式链 (<code>;</code> 和 <code>,</code>)。</p><p>然而，某些 JavaScript 语法仍然是不允许的：</p><ul><li><code>new</code> 运算符</li><li>自增和自减运算符：<code>++</code> 和 <code>--</code></li><li>操作并赋值，例如 <code>+=</code> 和 <code>-=</code></li><li>位操作符 <code>|</code> 和 <code>&amp;</code></li><li><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#expression-operators">模板表达式运算符</a></li></ul></li><li><p>语句上下文</p><p>和表达式中一样，语句只能引用语句上下文中 —— 通常是正在绑定事件的那个<strong>组件实例</strong>。</p><p>典型的<em>语句上下文</em>就是当前组件的实例。 <code>(click)=&quot;deleteHero()&quot;</code> 中的 <em>deleteHero</em> 就是这个数据绑定组件上的一个方法。</p><p><code>&lt;button (click)=&quot;deleteHero()&quot;&gt;Delete hero&lt;/button&gt;</code></p><p>语句上下文可以引用模板自身上下文中的属性。 在下面的例子中，就把模板的 <code>$event</code> 对象、<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-input-variable">模板输入变量</a> (<code>let hero</code>)和<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ref-vars">模板引用变量</a> (<code>#heroForm</code>)传给了组件中的一个事件处理器方法。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;onSave($event)&quot;</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span> (<span class="attr">click</span>)=<span class="string">&quot;deleteHero(hero)&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> #<span class="attr">heroForm</span> (<span class="attr">ngSubmit</span>)=<span class="string">&quot;onSubmit(heroForm)&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板上下文中的变量名的优先级高于组件上下文中的变量名。在上面的 <code>deleteHero(hero)</code> 中，<code>hero</code> 是一个模板输入变量，而不是组件中的 <code>hero</code> 属性。</p><p>模板语句不能引用全局命名空间的任何东西。比如不能引用 <code>window</code> 或 <code>document</code>，也不能调用 <code>console.log</code> 或 <code>Math.max</code>。</p></li><li><p>绑定语法</p><p>数据绑定是一种机制，用来协调用户所见和应用数据。 虽然你能往 HTML 推送值或者从 HTML 拉取值， 但如果把这些琐事交给数据绑定框架处理， 应用会更容易编写、阅读和维护。 只要简单地在绑定源和目标 HTML 元素之间声明绑定，框架就会完成这项工作。</p><p>绑定的类型可以根据数据流的方向分成三类： <em>从数据源到视图</em>、<em>从视图到数据源</em>以及双向的<em>从视图到数据源再到视图</em>。</p><table><thead><tr><th>数据方向</th><th>语法</th><th>绑定类型</th></tr></thead><tbody><tr><td>单向<br>从数据源到视图</td><td>[<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkWithHref#target">target</a>]=”expression” bind-target=”expression”</td><td>插值<br>属性<br>Attribute<br>CSS 类<br>样式</td></tr><tr><td>从视图到数据源的单向绑定</td><td>(<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkWithHref#target">target</a>)=”statement” on-target=”statement”事件</td><td>事件</td></tr><tr><td>双向</td><td>[(<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkWithHref#target">target</a>)]=”expression” bindon-target=”expression”</td><td>双向</td></tr></tbody></table></li><li><p>绑定目标</p><table><thead><tr><th>绑定类型</th><th>目标</th><th>范例</th></tr></thead><tbody><tr><td>属性</td><td>元素的 property<br>组件的 property<br>指令的 property</td><td>&lt;img [src]=”heroImageUrl”&gt;<br>&lt;app-hero-detail [hero]=”currentHero”&gt;<br>&lt;div [ngClass]=”{‘special’: isSpecial}”&gt;</td></tr></tbody></table></li></ol></article></div><tr><td>事件</td><td>元素的事件<br>组件的事件<br>指令的事件</td><td>&lt;button (click)=”onSave()”&gt;Save<br>&lt;app-hero-detail (deleteRequest)=”deleteHero()”&gt;<br>&lt;div (myClick)=”clicked=$event” clickable&gt;click me</td></tr></main></div><tr><td>双向</td><td>事件与 property</td><td>&lt;input [(<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/forms/NgModel">ngModel</a>)]=”name”&gt;</td></tr><tr><td>Attribute</td><td>attribute（例外情况）</td><td>&lt;button [attr.aria-label]=”help”&gt;help</td></tr><tr><td>CSS 类</td><td><code>class</code> property</td><td>&lt;div [class.special]=”isSpecial”&gt;Special</td></tr><tr><td>样式</td><td><code>style</code> property</td><td>&lt;button [style.color]=”isSpecial ? ‘red’ : ‘green’”&gt;</td></tr><li><p>内置指令</p><ul><li><p>内置属性型指令</p><p>属性型指令会监听和修改其它 HTML 元素或组件的行为、元素属性（Attribute）、DOM 属性（Property）。 它们通常会作为 HTML 属性的名称而应用在元素上。</p><ul><li><p>NgClass</p><p>你经常用动态添加或删除 CSS 类的方式来控制元素如何显示。 通过绑定到 <code>NgClass</code>，可以同时添加或移除多个类。</p><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#class-binding">CSS 类绑定</a> 是添加或删除<em>单个</em>类的最佳途径。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- toggle the &quot;special&quot; class on/off with a property --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">class.special</span>]=<span class="string">&quot;isSpecial&quot;</span>&gt;</span>The class binding is special<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当想要同时添加或移除<em>多个</em> CSS 类时，<code>NgClass</code> 指令可能是更好的选择。</p><p>试试把 <code>ngClass</code> 绑定到一个 key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是 <code>true</code>，这个类就会被加上，否则就会被移除。</p><p>组件方法 <code>setCurrentClasses</code> 可以把组件的属性 <code>currentClasses</code> 设置为一个对象，它将会根据三个其它组件的状态为 <code>true</code> 或 <code>false</code> 而添加或移除三个类。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">currentClasses: &#123;&#125;;</span><br><span class="line"><span class="function"><span class="title">setCurrentClasses</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// CSS classes: added/removed per current state of component properties</span></span><br><span class="line">  <span class="built_in">this</span>.currentClasses =  &#123;</span><br><span class="line">    <span class="string">&#x27;saveable&#x27;</span>: <span class="built_in">this</span>.canSave,</span><br><span class="line">    <span class="string">&#x27;modified&#x27;</span>: !<span class="built_in">this</span>.isUnchanged,</span><br><span class="line">    <span class="string">&#x27;special&#x27;</span>:  <span class="built_in">this</span>.isSpecial</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 <code>NgClass</code> 属性绑定到 <code>currentClasses</code>，根据它来设置此元素的 CSS 类：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">ngClass</span>]=<span class="string">&quot;currentClasses&quot;</span>&gt;</span>This div is initially saveable, unchanged, and special<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>NgStyle</p><p>你可以根据组件的状态动态设置内联样式。 <code>NgStyle</code> 绑定可以同时设置多个内联样式。</p><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#style-binding">样式绑定</a>是设置<em>单一</em>样式值的简单方式。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">style.font-size</span>]=<span class="string">&quot;isSpecial ? &#x27;x-large&#x27; : &#x27;smaller&#x27;&quot;</span> &gt;</span></span><br><span class="line">  This div is x-large or smaller.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要同时设置<em>多个</em>内联样式，<code>NgStyle</code> 指令可能是更好的选择。</p><p><code>NgStyle</code> 需要绑定到一个 key:value 控制对象。 对象的每个 key 是样式名，它的 value 是能用于这个样式的任何值。</p><p>来看看组件的 <code>setCurrentStyles</code> 方法，它会根据另外三个属性的状态把组件的 <code>currentStyles</code> 属性设置为一个定义了三个样式的对象：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">currentStyles: &#123;&#125;;</span><br><span class="line"><span class="function"><span class="title">setCurrentStyles</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// CSS styles: set per current state of component properties</span></span><br><span class="line">  <span class="built_in">this</span>.currentStyles = &#123;</span><br><span class="line">    <span class="string">&#x27;font-style&#x27;</span>:  <span class="built_in">this</span>.canSave      ? <span class="string">&#x27;italic&#x27;</span> : <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;font-weight&#x27;</span>: !<span class="built_in">this</span>.isUnchanged ? <span class="string">&#x27;bold&#x27;</span>   : <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;font-size&#x27;</span>:   <span class="built_in">this</span>.isSpecial    ? <span class="string">&#x27;24px&#x27;</span>   : <span class="string">&#x27;12px&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 <code>ngStyle</code> 属性绑定到 <code>currentStyles</code>，来根据它设置此元素的样式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">ngStyle</span>]=<span class="string">&quot;currentStyles&quot;</span>&gt;</span></span><br><span class="line">  This div is initially italic, normal weight, and extra large (24px).</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>NgModel- 使用[(ngModel)]双向绑定到表单元素</p><p>当开发数据输入表单时，你通常都要既显示数据属性又根据用户的更改去修改那个属性。</p><p>使用 <code>NgModel</code> 指令进行双向数据绑定可以简化这种工作。例子如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> [(<span class="attr">ngModel</span>)]=<span class="string">&quot;currentHero.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用 ngModel 时需要 FormsModule</strong><br>在使用 ngModel 指令进行双向数据绑定之前，你必须导入 FormsModule 并把它添加到 NgModule 的 imports 列表中。 要了解 FormsModule 和 ngModel 的更多知识，参见表单一章。</p><p>导入 FormsModule 并让 [(ngModel)] 可用的代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125;  <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>; <span class="comment">// &lt;--- JavaScript import from Angular</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Other imports */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule  <span class="comment">// &lt;--- import into the NgModule</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">/* Other module metadata */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>内置结构型属性</p><p>结构型指令的职责是 HTML 布局。 它们塑造或重塑 DOM 的<em>结构</em>，这通常是通过添加、移除和操纵它们所附加到的宿主元素来实现的。</p><ul><li><p>NgIf</p><p>通过把 <code>NgIf</code> 指令应用到元素上（称为<em>宿主元素</em>），你可以往 DOM 中添加或从 DOM 中移除这个元素。 在下面的例子中，该指令绑定到了类似于 <code>isActive</code> 这样的条件表达式。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-hero-detail</span> *<span class="attr">ngIf</span>=<span class="string">&quot;isActive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-hero-detail</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>isActive</code> 表达式返回真值时，<code>NgIf</code> 把 <code>HeroDetailComponent</code> 添加到 DOM 中；为假时，<code>NgIf</code> 会从 DOM 中移除 <code>HeroDetailComponent</code>，并销毁该组件及其所有子组件。</p><p><code>ngIf</code> 指令通常会用来防范空指针错误。 而显示/隐藏的方式是无法防范的，当一个表达式尝试访问空值的属性时，Angular 就会抛出一个异常。</p><p>这里我们用 <code>NgIf</code> 来保护了两个 `` 防范空指针错误。 <code>currentHero</code> 的名字只有当存在 <code>currentHero</code> 时才会显示出来。 而 <code>nullHero</code> 永远不会显示。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;currentHero&quot;</span>&gt;</span>Hello, &#123;&#123;currentHero.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngIf</span>=<span class="string">&quot;nullHero&quot;</span>&gt;</span>Hello, &#123;&#123;nullHero.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>NgFor</p><p><code>NgFor</code> 是一个<em>重复器</em>指令 —— 自定义数据显示的一种方式。 你的目标是展示一个由多个条目组成的列表。首先定义了一个 HTML 块，它规定了单个条目应该如何显示。 再告诉 Angular 把这个块当做模板，渲染列表中的每个条目。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let hero of heroes&quot;</span>&gt;</span>&#123;&#123;hero.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>NgSwitch</p><p><code>NgSwitch</code> 指令类似于 JavaScript 的 <code>switch</code> 语句。 它可以从多个可能的元素中根据<em>switch 条件</em>来显示某一个。 Angular 只会把<em>选中的</em>元素放进 DOM 中。</p><p><code>NgSwitch</code> 实际上包括三个相互协作的指令：<code>NgSwitch</code>、<code>NgSwitchCase</code> 和 <code>NgSwitchDefault</code>，例子如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> [<span class="attr">ngSwitch</span>]=<span class="string">&quot;currentHero.emotion&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-happy-hero</span>    *<span class="attr">ngSwitchCase</span>=<span class="string">&quot;&#x27;happy&#x27;&quot;</span>    [<span class="attr">hero</span>]=<span class="string">&quot;currentHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-happy-hero</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-sad-hero</span>      *<span class="attr">ngSwitchCase</span>=<span class="string">&quot;&#x27;sad&#x27;&quot;</span>      [<span class="attr">hero</span>]=<span class="string">&quot;currentHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-sad-hero</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-confused-hero</span> *<span class="attr">ngSwitchCase</span>=<span class="string">&quot;&#x27;confused&#x27;&quot;</span> [<span class="attr">hero</span>]=<span class="string">&quot;currentHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-confused-hero</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-unknown-hero</span>  *<span class="attr">ngSwitchDefault</span>           [<span class="attr">hero</span>]=<span class="string">&quot;currentHero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-unknown-hero</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>NgSwitch</code> 是主控指令，要把它绑定到一个返回<em>候选值</em>的表达式。 本例子中的 <code>emotion</code> 是个字符串，但实际上这个候选值可以是任意类型。</p><p>*<em>绑定到 <code>[ngSwitch]</code>*<em>。如果试图用 <code>*ngSwitch</code> 的形式使用它就会报错，这是因为 <code>NgSwitch</code> 是一个</em>属性型*指令，而不是</em>结构型指令*。 它要修改的是所在元素的行为，而不会直接接触 DOM 结构。</p><p><strong>绑定到 <code>\*ngSwitchCase</code> 和 <code>\*ngSwitchDefault</code></strong> <code>NgSwitchCase</code> 和 <code>NgSwitchDefault</code> 指令都是<em>结构型指令</em>，因为它们会从 DOM 中添加或移除元素。</p><ul><li><code>NgSwitchCase</code> 会在它绑定到的值等于候选值时，把它所在的元素加入到 DOM 中。</li><li><code>NgSwitchDefault</code> 会在没有任何一个 <code>NgSwitchCase</code> 被选中时把它所在的元素加入 DOM 中。</li></ul><p>这组指令在要添加或移除<em>组件元素</em>时会非常有用。 这个例子会在 <code>hero-switch.components.ts</code> 中定义的四个“感人英雄”组件之间选择。 每个组件都有一个<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#inputs-outputs">输入属性</a><code>hero</code>，它绑定到父组件的 <code>currentHero</code> 上。</p><p>这组指令在原生元素和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web Component</a>上都可以正常工作。 比如，你可以把 `` 分支改成这样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">ngSwitchCase</span>=<span class="string">&quot;&#x27;confused&#x27;&quot;</span>&gt;</span>Are you as confused as &#123;&#123;currentHero.name&#125;&#125;?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><h2 id="3-3-用户输入"><a href="#3-3-用户输入" class="headerlink" title="3.3-用户输入"></a>3.3-用户输入</h2><p>当用户点击链接、按下按钮或者输入文字时，这些用户动作都会产生 DOM 事件。 本章解释如何使用 Angular 事件绑定语法把这些事件绑定到事件处理器。</p><ol><li><p>绑定到用户输入事件</p><p>你可以使用 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#event-binding">Angular 事件绑定</a>机制来响应任何 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Events">DOM 事件</a>。 许多 DOM 事件是由用户输入触发的。绑定这些事件可以获取用户输入。</p><p>要绑定 DOM 事件，只要把 DOM 事件的名字包裹在圆括号中，然后用放在引号中的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-statements">模板语句</a>对它赋值就可以了。</p><p>下例展示了一个事件绑定，它实现了一个点击事件处理器：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;onClickMe()&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等号左边的 <code>(click)</code> 表示把按钮的点击事件作为<strong>绑定目标</strong>。 等号右边引号中的文本是<strong>模板语句</strong>，通过调用组件的 <code>onClickMe</code> 方法来响应这个点击事件。</p><p>写绑定时，需要知道模板语句的<strong>执行上下文</strong>。 出现在模板语句中的每个标识符都属于特定的上下文对象。 这个对象通常都是控制此模板的 Angular 组件。 上例中只显示了一行 HTML，那段 HTML 片段属于下面这个组件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  selector: &#x27;app-click-me&#x27;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;onClickMe()&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;&#123;clickMessage&#125;&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">export class ClickMeComponent &#123;</span><br><span class="line">  clickMessage = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">  onClickMe() &#123;</span><br><span class="line">    this.clickMessage = &#x27;You are my hero!&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户点击按钮时，Angular 调用 <code>ClickMeComponent</code> 的 <code>onClickMe</code> 方法。</p></li><li><p>通过 $event 对象取得用户输入</p><p>DOM 事件可以携带可能对组件有用的信息。 本节将展示如何绑定输入框的 <code>keyup</code> 事件，在每个敲击键盘时获取用户输入。</p><p>下面的代码监听 <code>keyup</code> 事件，并将整个事件载荷 (<code>$event</code>) 传递给组件的事件处理器。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;input (keyup)=&quot;onKey($event)&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;&#123;&#123;values&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>当用户按下并释放一个按键时，触发 <code>keyup</code> 事件，Angular 在 <code>$event</code> 变量提供一个相应的 DOM 事件对象，上面的代码将它作为参数传递给 <code>onKey()</code> 方法。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyUpComponent_v1</span> </span>&#123;</span><br><span class="line">  values = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onKey</span>(<span class="params">event: <span class="built_in">any</span></span>)</span> &#123; <span class="comment">// without type info</span></span><br><span class="line">    <span class="built_in">this</span>.values += event.target.value + <span class="string">&#x27; | &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$event</code> 对象的属性取决于 DOM 事件的类型。例如，鼠标事件与输入框编辑事件包含了不同的信息。</p><p>所有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Event">标准 DOM 事件对象</a>都有一个 <code>target</code> 属性， 引用触发该事件的元素。 在本例中，<code>target</code> 是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement">`` 元素</a>， <code>event.target.value</code> 返回该元素的当前内容。</p><p>在组件的 <code>onKey()</code> 方法中，把输入框的值和分隔符 (|) 追加组件的 <code>values</code> 属性。 使用<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#interpolation">插值表达式</a>来把存放累加结果的 <code>values</code> 属性回显到屏幕上。</p></li></ol><h2 id="3-4-生命周期钩子"><a href="#3-4-生命周期钩子" class="headerlink" title="3.4-生命周期钩子"></a>3.4-生命周期钩子</h2><p>每个组件都有一个被 Angular 管理的生命周期。</p><p>Angular 创建它，渲染它，创建并渲染它的子组件，在它被绑定的属性发生变化时检查它，并在它从 DOM 中被移除前销毁它。</p><p>Angular 提供了<strong>生命周期钩子</strong>，把这些关键生命时刻暴露出来，赋予你在它们发生时采取行动的能力。</p><p>除了那些组件内容和视图相关的钩子外,指令有相同生命周期钩子。</p><ol><li><p>组件生命周期钩子概览</p><p>指令和组件的实例有一个生命周期：当 Angular 新建、更新和销毁它们时触发。 通过实现一个或多个 Angular <code>core</code> 库里定义的<em>生命周期钩子</em>接口，开发者可以介入该生命周期中的这些关键时刻。</p><p>每个接口都有唯一的一个钩子方法，它们的名字是由接口名再加上 <code>ng</code> 前缀构成的。比如，<code>OnInit</code> 接口的钩子方法叫做 <code>ngOnInit</code>， Angular 在创建组件后立刻调用它，：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PeekABoo</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> logger: LoggerService</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// implement OnInit&#x27;s `ngOnInit` method</span></span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.logIt(<span class="string">`OnInit`</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">logIt</span>(<span class="params">msg: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.logger.log(<span class="string">`#<span class="subst">$&#123;nextId++&#125;</span> <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有指令或者组件会实现所有这些接口，并且有些钩子只对组件有意义。只有在指令/组件中<em>定义过的</em>那些钩子方法才会被 Angular 调用。</p></li><li><p>生命周期的顺序</p><p>当 Angular 使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法：</p><table><thead><tr><th>钩子</th><th>用途及时机</th></tr></thead><tbody><tr><td>ngOnChanges()</td><td>当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 <code>SimpleChanges</code> 对象<br>在 <code>ngOnInit()</code> 之前以及所绑定的一个或多个输入属性的值发生变化时都会调用。</td></tr><tr><td>ngOnInit()</td><td>在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。<br>在第一轮 <code>ngOnChanges()</code> 完成之后调用，只调用<strong>一次</strong>。</td></tr><tr><td>ngDoCheck()</td><td>检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。<br>在每个变更检测周期中，紧跟在 <code>ngOnChanges()</code> 和 <code>ngOnInit()</code> 后面调用。</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkActive#ngAfterContentInit">ngAfterContentInit()</a></td><td>当 Angular 把外部内容投影进组件/指令的视图之后调用。<br>第一次 <code>ngDoCheck()</code> 之后调用，只调用一次。</td></tr><tr><td>ngAfterContentChecked()</td><td>每当 Angular 完成被投影组件内容的变更检测之后调用。<br><code>ngAfterContentInit()</code> 和每次 <code>ngDoCheck()</code> 之后调用</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/forms/NgForm#ngAfterViewInit">ngAfterViewInit()</a></td><td>当 Angular 初始化完组件视图及其子视图之后调用。<br>第一次 <code>ngAfterContentChecked()</code> 之后调用，只调用一次。</td></tr><tr><td>ngAfterViewChecked()</td><td>每当 Angular 做完组件视图和子视图的变更检测之后调用。<br><code>ngAfterViewInit()</code> 和每次 <code>ngAfterContentChecked()</code> 之后调用。</td></tr><tr><td>ngOnDestroy()</td><td>每当 Angular 每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。<br>在 Angular 销毁指令/组件之前调用。</td></tr></tbody></table></li></ol><h2 id="3-5-组件之间的交互"><a href="#3-5-组件之间的交互" class="headerlink" title="3.5-组件之间的交互"></a>3.5-组件之间的交互</h2><ol><li><p>通过输入型绑定把数据从父组件传到子组件</p><p><code>HeroChildComponent</code> 有两个***输入型属性***，它们通常带<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#inputs-outputs">@Input 装饰器</a>。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; Hero &#125; <span class="keyword">from</span> <span class="string">&#x27;./hero&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-hero-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;&#123;&#123;hero.name&#125;&#125; says:&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;I, &#123;&#123;hero.name&#125;&#125;, am at your service, &#123;&#123;masterName&#125;&#125;.&lt;/p&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroChildComponent</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Input</span>() hero: Hero;</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">&#x27;master&#x27;</span>) masterName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个 <code>@Input</code> 为子组件的属性名 <code>masterName</code> 指定一个别名 <code>master</code>(译者注：不推荐为起别名，请参见风格指南).</p><p>父组件 <code>HeroParentComponent</code> 把子组件的 <code>HeroChildComponent</code> 放到 <code>*ngFor</code> 循环器中，把自己的 <code>master</code> 字符串属性绑定到子组件的 <code>master</code> 别名上，并把每个循环的 <code>hero</code> 实例绑定到子组件的 <code>hero</code> 属性。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; HEROES &#125; <span class="keyword">from</span> <span class="string">&#x27;./hero&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-hero-parent&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;master&#125;&#125; controls &#123;&#123;heroes.length&#125;&#125; heroes&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;app-hero-child *ngFor=&quot;let hero of heroes&quot;</span></span><br><span class="line"><span class="string">      [hero]=&quot;hero&quot;</span></span><br><span class="line"><span class="string">      [master]=&quot;master&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/app-hero-child&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroParentComponent</span> </span>&#123;</span><br><span class="line">  heroes = HEROES;</span><br><span class="line">  master = <span class="string">&#x27;Master&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行应用程序会显示三个英雄：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/parent-to-child.jpeg"></p></li><li><p>通过 setter 截听输入属性值的变化</p><p>使用一个输入属性的 setter，以拦截父组件中值的变化，并采取行动。</p><p>子组件 <code>NameChildComponent</code> 的输入属性 <code>name</code> 上的这个 setter，会 trim 掉名字里的空格，并把空值替换成默认字符串。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-name-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&quot;&#123;&#123;name&#125;&#125;&quot;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChildComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = (name &amp;&amp; name.trim()) || <span class="string">&#x27;&lt;no name set&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>(): <span class="title">string</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>._name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的 <code>NameParentComponent</code> 展示了各种名字的处理方式，包括一个全是空格的名字。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-name-parent&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h2&gt;Master controls &#123;&#123;names.length&#125;&#125; names&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;app-name-child *ngFor=&quot;let name of names&quot; [name]=&quot;name&quot;&gt;&lt;/app-name-child&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NameParentComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Displays &#x27;Dr IQ&#x27;, &#x27;&lt;no name set&gt;&#x27;, &#x27;Bombasto&#x27;</span></span><br><span class="line">  names = [<span class="string">&#x27;Dr IQ&#x27;</span>, <span class="string">&#x27;   &#x27;</span>, <span class="string">&#x27;  Bombasto  &#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://gitee.com/lemon-cs/images/raw/master/setter.jpeg"></p><ol start="3"><li><p>通过ngOnChanges()来截听输入属性值的变化</p><p>使用 <code>OnChanges</code> 生命周期钩子接口的 <code>ngOnChanges()</code> 方法来监测输入属性值的变化并做出回应。</p><p>当需要监视多个、交互式输入属性的时候，本方法比用属性的 setter 更合适。</p><p>这个 <code>VersionChildComponent</code> 会监测输入属性 <code>major</code> 和 <code>minor</code> 的变化，并把这些变化编写成日志以报告这些变化。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input, OnChanges, SimpleChange &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-version-child&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Version &#123;&#123;major&#125;&#125;.&#123;&#123;minor&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;h4&gt;Change log:&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor=&quot;let change of changeLog&quot;&gt;&#123;&#123;change&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionChildComponent</span> <span class="title">implements</span> <span class="title">OnChanges</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Input</span>() major: <span class="built_in">number</span>;</span><br><span class="line">  <span class="meta">@Input</span>() minor: <span class="built_in">number</span>;</span><br><span class="line">  changeLog: <span class="built_in">string</span>[] = [];</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">ngOnChanges</span>(<span class="params">changes: &#123;[propKey: <span class="built_in">string</span>]: SimpleChange&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> log: <span class="built_in">string</span>[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> propName <span class="keyword">in</span> changes) &#123;</span><br><span class="line">      <span class="keyword">let</span> changedProp = changes[propName];</span><br><span class="line">      <span class="keyword">let</span> to = <span class="built_in">JSON</span>.stringify(changedProp.currentValue);</span><br><span class="line">      <span class="keyword">if</span> (changedProp.isFirstChange()) &#123;</span><br><span class="line">        log.push(<span class="string">`Initial value of <span class="subst">$&#123;propName&#125;</span> set to <span class="subst">$&#123;to&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">from</span> = <span class="built_in">JSON</span>.stringify(changedProp.previousValue);</span><br><span class="line">        log.push(<span class="string">`<span class="subst">$&#123;propName&#125;</span> changed from <span class="subst">$&#123;<span class="keyword">from</span>&#125;</span> to <span class="subst">$&#123;to&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.changeLog.push(log.join(<span class="string">&#x27;, &#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VersionParentComponent</code> 提供 <code>minor</code> 和 <code>major</code> 值，把修改它们值的方法绑定到按钮上。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-version-parent&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Source code version&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;newMinor()&quot;&gt;New minor version&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;newMajor()&quot;&gt;New major version&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;app-version-child [major]=&quot;major&quot; [minor]=&quot;minor&quot;&gt;&lt;/app-version-child&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionParentComponent</span> </span>&#123;</span><br><span class="line">  major = <span class="number">1</span>;</span><br><span class="line">  minor = <span class="number">23</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">newMinor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.minor++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">newMajor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.major++;</span><br><span class="line">    <span class="built_in">this</span>.minor = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是点击按钮的结果。</p></li></ol><p><img src="https://gitee.com/lemon-cs/images/raw/master/parent-to-child-on-changes.gif"></p><ol start="4"><li><p>父组件监听子组件的事件</p><p>子组件暴露一个 <code>EventEmitter</code> 属性，当事件发生时，子组件利用该属性 <code>emits</code>(向上弹射)事件。父组件绑定到这个事件属性，并在事件发生时作出回应。</p><p>子组件的 <code>EventEmitter</code> 属性是一个<strong>输出属性</strong>，通常带有<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#inputs-outputs">@Output 装饰器</a>，就像在 <code>VoterComponent</code> 中看到的。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, EventEmitter, Input, Output &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-voter&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h4&gt;&#123;&#123;name&#125;&#125;&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;vote(true)&quot;  [disabled]=&quot;didVote&quot;&gt;Agree&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;vote(false)&quot; [disabled]=&quot;didVote&quot;&gt;Disagree&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">VoterComponent</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Input</span>()  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Output</span>() voted = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">boolean</span>&gt;();</span><br><span class="line">  didVote = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">vote</span>(<span class="params">agreed: <span class="built_in">boolean</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.voted.emit(agreed);</span><br><span class="line">    <span class="built_in">this</span>.didVote = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮会触发 <code>true</code> 或 <code>false</code>(布尔型<em>有效载荷</em>)的事件。</p><p>父组件 <code>VoteTakerComponent</code> 绑定了一个事件处理器(<code>onVoted()</code>)，用来响应子组件的事件(<code>$event</code>)并更新一个计数器。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125;      <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-vote-taker&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Should mankind colonize the Universe?&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Agree: &#123;&#123;agreed&#125;&#125;, Disagree: &#123;&#123;disagreed&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;app-voter *ngFor=&quot;let voter of voters&quot;</span></span><br><span class="line"><span class="string">      [name]=&quot;voter&quot;</span></span><br><span class="line"><span class="string">      (voted)=&quot;onVoted($event)&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/app-voter&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">VoteTakerComponent</span> </span>&#123;</span><br><span class="line">  agreed = <span class="number">0</span>;</span><br><span class="line">  disagreed = <span class="number">0</span>;</span><br><span class="line">  voters = [<span class="string">&#x27;Narco&#x27;</span>, <span class="string">&#x27;Celeritas&#x27;</span>, <span class="string">&#x27;Bombasto&#x27;</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">onVoted</span>(<span class="params">agreed: <span class="built_in">boolean</span></span>)</span> &#123;</span><br><span class="line">    agreed ? <span class="built_in">this</span>.agreed++ : <span class="built_in">this</span>.disagreed++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本框架把事件参数(用 <code>$event</code> 表示)传给事件处理方法，该方法会处理它：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/child-to-parent.gif"></p></li><li><p>父组件与子组件通过本地变量互动</p><p>父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法，如下例所示。</p><p>子组件 <code>CountdownTimerComponent</code> 进行倒计时，归零时发射一个导弹。<code>start</code> 和 <code>stop</code> 方法负责控制时钟并在模板里显示倒计时的状态信息。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnDestroy, OnInit &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-countdown-timer&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownTimerComponent</span> <span class="title">implements</span> <span class="title">OnInit</span>, <span class="title">OnDestroy</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  intervalId = <span class="number">0</span>;</span><br><span class="line">  message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  seconds = <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">clearTimer</span>(<span class="params"></span>)</span> &#123; <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.intervalId); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span>    &#123; <span class="built_in">this</span>.start(); &#125;</span><br><span class="line">  <span class="function"><span class="title">ngOnDestroy</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.clearTimer(); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.countDown(); &#125;</span><br><span class="line">  <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>  &#123;</span><br><span class="line">    <span class="built_in">this</span>.clearTimer();</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">`Holding at T-<span class="subst">$&#123;<span class="built_in">this</span>.seconds&#125;</span> seconds`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">countDown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.clearTimer();</span><br><span class="line">    <span class="built_in">this</span>.intervalId = <span class="built_in">window</span>.setInterval(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.seconds -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.seconds === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = <span class="string">&#x27;Blast off!&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.seconds &lt; <span class="number">0</span>) &#123; <span class="built_in">this</span>.seconds = <span class="number">10</span>; &#125; <span class="comment">// reset</span></span><br><span class="line">        <span class="built_in">this</span>.message = <span class="string">`T-<span class="subst">$&#123;<span class="built_in">this</span>.seconds&#125;</span> seconds and counting`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计时器组件的宿主组件 <code>CountdownLocalVarParentComponent</code> 如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125;                <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CountdownTimerComponent &#125;  <span class="keyword">from</span> <span class="string">&#x27;./countdown-timer.component&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-countdown-parent-lv&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;timer.start()&quot;&gt;Start&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;timer.stop()&quot;&gt;Stop&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;seconds&quot;&gt;&#123;&#123;timer.seconds&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;../assets/demo.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLocalVarParentComponent</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>父组件不能通过数据绑定使用子组件的 <code>start</code> 和 <code>stop</code> 方法，也不能访问子组件的 <code>seconds</code> 属性。</p><p>把本地变量(<code>#timer</code>)放到()标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，于是可以在父组件的模板中访问子组件的所有属性和方法。</p><p>这个例子把父组件的按钮绑定到子组件的 <code>start</code> 和 <code>stop</code> 方法，并用插值表达式来显示子组件的 <code>seconds</code> 属性。</p><p>下面是父组件和子组件一起工作时的效果。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/countdown-timer-anim.gif"></p></li><li><p>父组件调用@ViewChild()</p><p>这个<em>本地变量</em>方法是个简单便利的方法。但是它也有局限性，因为父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权。</p><p>如果父组件的<em>类</em>需要读取子组件的属性值或调用子组件的方法，就不能使用<em>本地变量</em>方法。</p><p>当父组件<em>类</em>需要这种访问时，可以把子组件作为 <em>ViewChild</em>，***注入***到父组件里面。</p><p>下面是父组件 <code>CountdownViewChildParentComponent</code>:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AfterViewInit, ViewChild &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125;                <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CountdownTimerComponent &#125;  <span class="keyword">from</span> <span class="string">&#x27;./countdown-timer.component&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-countdown-parent-vc&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;start()&quot;&gt;Start&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;stop()&quot;&gt;Stop&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;seconds&quot;&gt;&#123;&#123; seconds() &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;app-countdown-timer&gt;&lt;/app-countdown-timer&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;../assets/demo.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownViewChildParentComponent</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@ViewChild</span>(CountdownTimerComponent, &#123;<span class="attr">static</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">  <span class="keyword">private</span> timerComponent: CountdownTimerComponent;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">seconds</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">ngAfterViewInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...</span></span><br><span class="line">    <span class="comment">// but wait a tick first to avoid one-time devMode</span></span><br><span class="line">    <span class="comment">// unidirectional-data-flow-violation error</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.seconds = <span class="function">() =&gt;</span> <span class="built_in">this</span>.timerComponent.seconds, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.timerComponent.start(); &#125;</span><br><span class="line">  <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.timerComponent.stop(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把子组件的视图插入到父组件类需要做一点额外的工作。</p><p>首先，你必须导入对装饰器 <code>ViewChild</code> 以及生命周期钩子 <code>AfterViewInit</code> 的引用。</p><p>接着，通过 <code>@ViewChild</code> 属性装饰器，将子组件 <code>CountdownTimerComponent</code> 注入到私有属性 <code>timerComponent</code> 里面。</p><p>组件元数据里就不再需要 <code>#timer</code> 本地变量了。而是把按钮绑定到父组件自己的 <code>start</code> 和 <code>stop</code> 方法，使用父组件的 <code>seconds</code> 方法的插值表达式来展示秒数变化。</p><p>这些方法可以直接访问被注入的计时器组件。</p><p><code>ngAfterViewInit()</code> 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问，所以它先把秒数显示为 0.</p><p>然后 Angular 会调用 <code>ngAfterViewInit</code> 生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular 的单向数据流规则会阻止在同一个周期内更新父组件视图。应用在显示秒数之前会被迫<em>再等一轮</em>。</p><p>使用 <code>setTimeout()</code> 来等下一轮，然后改写 <code>seconds()</code> 方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值。</p></li><li><p>父组件和子组件通过服务来通讯</p><p>父组件和它的子组件共享同一个服务，利用该服务在组件家族内部实现双向通讯。</p><p>该服务实例的作用域被限制在父组件和其子组件内。这个组件子树之外的组件将无法访问该服务或者与它们通讯。</p><p>这个 MissionService 把 MissionControlComponent 和多个 AstronautComponent 子组件连接起来。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Subject &#125;    <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MissionService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Observable string sources</span></span><br><span class="line">  <span class="keyword">private</span> missionAnnouncedSource = <span class="keyword">new</span> Subject&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">  <span class="keyword">private</span> missionConfirmedSource = <span class="keyword">new</span> Subject&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Observable string streams</span></span><br><span class="line">  missionAnnounced$ = <span class="built_in">this</span>.missionAnnouncedSource.asObservable();</span><br><span class="line">  missionConfirmed$ = <span class="built_in">this</span>.missionConfirmedSource.asObservable();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Service message commands</span></span><br><span class="line">  <span class="function"><span class="title">announceMission</span>(<span class="params">mission: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.missionAnnouncedSource.next(mission);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">confirmMission</span>(<span class="params">astronaut: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.missionConfirmedSource.next(astronaut);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MissionControlComponent</code> 提供服务的实例，并将其共享给它的子组件(通过 <code>providers</code> 元数据数组)，子组件可以通过构造函数将该实例注入到自身。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125;          <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; MissionService &#125;     <span class="keyword">from</span> <span class="string">&#x27;./mission.service&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-mission-control&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Mission Control&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)=&quot;announce()&quot;&gt;Announce mission&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;app-astronaut *ngFor=&quot;let astronaut of astronauts&quot;</span></span><br><span class="line"><span class="string">      [astronaut]=&quot;astronaut&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/app-astronaut&gt;</span></span><br><span class="line"><span class="string">    &lt;h3&gt;History&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor=&quot;let event of history&quot;&gt;&#123;&#123;event&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">providers</span>: [MissionService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MissionControlComponent</span> </span>&#123;</span><br><span class="line">  astronauts = [<span class="string">&#x27;Lovell&#x27;</span>, <span class="string">&#x27;Swigert&#x27;</span>, <span class="string">&#x27;Haise&#x27;</span>];</span><br><span class="line">  history: <span class="built_in">string</span>[] = [];</span><br><span class="line">  missions = [<span class="string">&#x27;Fly to the moon!&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;Fly to mars!&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;Fly to Vegas!&#x27;</span>];</span><br><span class="line">  nextMission = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> missionService: MissionService</span>)</span> &#123;</span><br><span class="line">    missionService.missionConfirmed$.subscribe(</span><br><span class="line">      <span class="function"><span class="params">astronaut</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.history.push(<span class="string">`<span class="subst">$&#123;astronaut&#125;</span> confirmed the mission`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">announce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mission = <span class="built_in">this</span>.missions[<span class="built_in">this</span>.nextMission++];</span><br><span class="line">    <span class="built_in">this</span>.missionService.announceMission(mission);</span><br><span class="line">    <span class="built_in">this</span>.history.push(<span class="string">`Mission &quot;<span class="subst">$&#123;mission&#125;</span>&quot; announced`</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.nextMission &gt;= <span class="built_in">this</span>.missions.length) &#123; <span class="built_in">this</span>.nextMission = <span class="number">0</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AstronautComponent</code> 也通过自己的构造函数注入该服务。由于每个 <code>AstronautComponent</code> 都是 <code>MissionControlComponent</code> 的子组件，所以它们获取到的也是父组件的这个服务实例。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Input, OnDestroy &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; MissionService &#125; <span class="keyword">from</span> <span class="string">&#x27;./mission.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Subscription &#125;   <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-astronaut&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;p&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123;astronaut&#125;&#125;: &lt;strong&gt;&#123;&#123;mission&#125;&#125;&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;button</span></span><br><span class="line"><span class="string">        (click)=&quot;confirm()&quot;</span></span><br><span class="line"><span class="string">        [disabled]=&quot;!announced || confirmed&quot;&gt;</span></span><br><span class="line"><span class="string">        Confirm</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AstronautComponent</span> <span class="title">implements</span> <span class="title">OnDestroy</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Input</span>() astronaut: <span class="built_in">string</span>;</span><br><span class="line">  mission = <span class="string">&#x27;&lt;no mission announced&gt;&#x27;</span>;</span><br><span class="line">  confirmed = <span class="literal">false</span>;</span><br><span class="line">  announced = <span class="literal">false</span>;</span><br><span class="line">  subscription: Subscription;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> missionService: MissionService</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscription = missionService.missionAnnounced$.subscribe(</span><br><span class="line">      <span class="function"><span class="params">mission</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mission = mission;</span><br><span class="line">        <span class="built_in">this</span>.announced = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.confirmed = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">confirm</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.confirmed = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.missionService.confirmMission(<span class="built_in">this</span>.astronaut);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">ngOnDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// prevent memory leak when component destroyed</span></span><br><span class="line">    <span class="built_in">this</span>.subscription.unsubscribe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>History</em> 日志证明了：在父组件 <code>MissionControlComponent</code> 和子组件 <code>AstronautComponent</code> 之间，信息通过该服务实现了双向传递。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/bidirectional-service.gif"></p></li></ol><h2 id="3-6-管道"><a href="#3-6-管道" class="headerlink" title="3.6-管道"></a>3.6-管道</h2><p>每个应用开始的时候差不多都是一些简单任务：获取数据、转换它们，然后把它们显示给用户。 获取数据可能简单到创建一个局部变量就行，也可能复杂到从 WebSocket 中获取数据流。</p><p>一旦取到数据，你就可以把它们原始值的 <code>toString</code> 结果直接推入视图中。 但这种做法很少能具备良好的用户体验。 比如，几乎每个人都更喜欢简单的日期格式，例如1988-04-15，而不是服务端传过来的原始字符串格式 —— Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)。</p><p>显然，有些值最好显示成用户友好的格式。你很快就会发现，在很多不同的应用中，都在重复做出某些相同的变换。 你几乎会把它们看做某种 CSS 样式，事实上，你也确实更喜欢在 HTML 模板中应用它们 —— 就像 CSS 样式一样。</p><p>通过引入 Angular 管道（一种编写”从显示到值”转换逻辑的途径），你可以把它声明在 HTML 中。</p><ol><li><p>使用管道</p><p>管道把数据作为输入，然后转换它，给出期望的输出。 你要把组件的 <code>birthday</code> 属性转换成对人类更友好的日期格式。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-hero-birthday&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;p&gt;The hero&#x27;s birthday is &#123;&#123; birthday | date &#125;&#125;&lt;/p&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroBirthdayComponent</span> </span>&#123;</span><br><span class="line">  birthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1988</span>, <span class="number">3</span>, <span class="number">15</span>); <span class="comment">// April 15, 1988</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下组件的模板。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The hero&#x27;s birthday is &#123;&#123; birthday | date &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个插值表达式中，你让组件的 <code>birthday</code> 值通过<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#pipe">管道操作符</a>( | )流动到 右侧的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/common/DatePipe">Date 管道</a>函数中。所有管道都会用这种方式工作。</p></li><li><p>内置的管道</p><p>Angular 内置了一些管道，比如 DatePipe、UpperCasePipe、LowerCasePipe、CurrencyPipe 和 PercentPipe。 它们全都可以直接用在任何模板中。</p></li><li><p>对管道进行参数化</p><p>管道可能接受任何数量的可选参数来对它的输出进行微调。 可以在管道名后面添加一个冒号( : )再跟一个参数值，来为管道添加参数(比如 <code>currency:&#39;EUR&#39;</code>)。 如果这个管道可以接受多个参数，那么就用冒号来分隔这些参数值(比如 <code>slice:1:5</code>)。</p><p>修改生日模板，来为这个日期管道提供一个格式化参数。 当格式化完该英雄的 4 月 15 日生日之后，它应该被渲染成<strong>04/15/88</strong>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The hero&#x27;s birthday is &#123;&#123; birthday | date:&quot;MM/dd/yy&quot; &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数值可以是任何有效的模板表达式（参见<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax">模板语法</a>中的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-expressions">模板表达式</a>部分），比如字符串字面量或组件的属性。 换句话说，借助属性绑定，你也可以像用绑定来控制生日的值一样，控制生日的显示格式。</p><p>来写第二个组件，它把管道的格式参数<em>绑定</em>到该组件的 <code>format</code> 属性。这里是新组件的模板：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;p&gt;The hero&#x27;s birthday is &#123;&#123; birthday | date:format &#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;button (click)=&quot;toggleFormat()&quot;&gt;Toggle Format&lt;/button&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></li><li><p>自定义管道</p><p>你还可以写自己的自定义管道。 下面就是一个名叫 <code>ExponentialStrengthPipe</code> 的管道，它可以放大英雄的能力：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Pipe, PipeTransform &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Raise the value exponentially</span></span><br><span class="line"><span class="comment"> * Takes an exponent argument that defaults to 1.</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> *   value | exponentialStrength:exponent</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *   &#123;&#123; 2 | exponentialStrength:10 &#125;&#125;</span></span><br><span class="line"><span class="comment"> *   formats to: 1024</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pipe</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;exponentialStrength&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialStrengthPipe</span> <span class="title">implements</span> <span class="title">PipeTransform</span> </span>&#123;</span><br><span class="line">  transform(value: <span class="built_in">number</span>, exponent?: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(value, <span class="built_in">isNaN</span>(exponent) ? <span class="number">1</span> : exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个管道的定义中体现了几个关键点：</p><ul><li>管道是一个带有“管道元数据(pipe metadata)”装饰器的类。</li><li>这个管道类实现了 <code>PipeTransform</code> 接口的 <code>transform</code> 方法，该方法接受一个输入值和一些可选参数，并返回转换后的值。</li><li>当每个输入值被传给 <code>transform</code> 方法时，还会带上另一个参数，比如你这个管道就有一个 <code>exponent</code>(放大指数) 参数。</li><li>可以通过 <code>@Pipe</code> 装饰器来告诉 Angular：这是一个管道。该装饰器是从 Angular 的 <code>core</code> 库中引入的。</li><li>这个 <code>@Pipe</code> 装饰器允许你定义管道的名字，这个名字会被用在模板表达式中。它必须是一个有效的 JavaScript 标识符。 比如，你这个管道的名字是 <code>exponentialStrength</code>。</li></ul></li></ol><h1 id="4-表单"><a href="#4-表单" class="headerlink" title="4-表单"></a>4-表单</h1><h2 id="4-1-表单简介"><a href="#4-1-表单简介" class="headerlink" title="4.1-表单简介"></a>4.1-表单简介</h2><p>用表单处理用户输入是许多常见应用的基础功能。 应用通过表单来让用户登录、修改个人档案、输入敏感信息以及执行各种数据输入任务。</p><p>Angular 提供了两种不同的方法来通过表单处理用户输入：响应式表单和模板驱动表单。 两者都从视图中捕获用户输入事件、验证用户输入、创建表单模型、修改数据模型，并提供跟踪这些更改的途径。</p><p>不过，响应式表单和模板驱动表单在如何处理和管理表单和表单数据方面有所不同。各有优势。</p><p><strong>一般来说：</strong></p><ul><li><strong>响应式表单</strong>更健壮：它们的可扩展性、可复用性和可测试性更强。 如果表单是应用中的关键部分，或者你已经准备使用响应式编程模式来构建应用，请使用响应式表单。</li><li><strong>模板驱动表单</strong>在往应用中添加简单的表单时非常有用，比如邮件列表的登记表单。它们很容易添加到应用中，但是不像响应式表单那么容易扩展。如果你有非常基本的表单需求和简单到能用模板管理的逻辑，请使用模板驱动表单。</li></ul><table><thead><tr><th></th><th>响应式</th><th>模板驱动</th></tr></thead><tbody><tr><td>建立（表单模式）</td><td>显式，在组件类中创建。</td><td>隐式，由组件创建。</td></tr><tr><td>数据模式</td><td>结构化</td><td>非结构化</td></tr><tr><td>可预测性</td><td>同步</td><td>异步</td></tr><tr><td>表单验证</td><td>函数</td><td>指令</td></tr><tr><td>可变性</td><td>不可变</td><td>可变</td></tr><tr><td>可伸缩性</td><td>访问底层API</td><td>在API之上的抽象</td></tr></tbody></table><h2 id="4-2-响应式表单"><a href="#4-2-响应式表单" class="headerlink" title="4.2-响应式表单"></a>4.2-响应式表单</h2><p><em>响应式表单</em>提供了一种模型驱动的方式来处理表单输入，其中的值会随时间而变化。本文会向你展示如何创建和更新单个表单控件，然后在一个分组中使用多个控件，验证表单的值，以及如何实现更高级的表单。</p><p>响应式表单使用显式的、不可变的方式，管理表单在特定的时间点上的状态。对表单状态的每一次变更都会返回一个新的状态，这样可以在变化时维护模型的整体性。响应式表单是围绕 Observable 的流构建的，表单的输入和值都是通过这些输入值组成的流来提供的，它可以同步访问。</p><p>响应式表单还提供了一种更直观的测试路径，因为在请求时你可以确信这些数据是一致的、可预料的。这个流的任何一个消费者都可以安全地操纵这些数据。</p><p>响应式表单与模板驱动的表单有着显著的不同点。响应式表单通过对数据模型的同步访问提供了更多的可预测性，使用 Observable 的操作符提供了不可变性，并且通过 Observable 流提供了变化追踪功能。 如果你更喜欢在模板中直接访问数据，那么模板驱动的表单会显得更明确，因为它们依赖嵌入到模板中的指令，并借助可变数据来异步跟踪变化。参见<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/forms-overview">表单概览</a>来了解这两种范式之间的详细比较。</p><ul><li><p>注册 ReactiveFormsModule</p><p>要使用响应式表单，就要从 <code>@angular/forms</code> 包中导入 <code>ReactiveFormsModule</code> 并把它添加到你的 NgModule 的 <code>imports</code> 数组中。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ReactiveFormsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    <span class="comment">// other imports ...</span></span><br><span class="line">    ReactiveFormsModule</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>生成并导入一个新的表单控件</p><p><code>ng generate component NameEditor</code></p><p>当使用响应式表单时，<code>FormControl</code> 类是最基本的构造块。要注册单个的表单控件，请在组件中导入 <code>FormControl</code> 类，并创建一个 <code>FormControl</code> 的新实例，把它保存在类的某个属性中。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormControl &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-name-editor&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./name-editor.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./name-editor.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">NameEditorComponent</span> </span>&#123;</span><br><span class="line">  name = <span class="keyword">new</span> FormControl(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用 <code>FormControl</code> 的构造函数设置初始值，这个例子中它是空字符串。通过在你的组件类中创建这些控件，你可以直接对表单控件的状态进行监听、修改和校验。</p></li><li><p>在模板中注册该控件</p><p>在组件类中创建了控件之后，你还要把它和模板中的一个表单控件关联起来。修改模板，为表单控件添加 formControl 绑定，formControl 是由 ReactiveFormsModule 中的 FormControlDirective 提供的。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  Name:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> [<span class="attr">formControl</span>]=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-模板驱动表单"><a href="#4-3-模板驱动表单" class="headerlink" title="4.3-模板驱动表单"></a>4.3-模板驱动表单</h2><p>开发表单需要设计能力（那超出了本章的范围），而框架支持<em>双向数据绑定、变更检测、验证和错误处理</em>，而本章你将会学到它们。</p><p>这个页面演示了如何从草稿构建一个简单的表单。这个过程中你将学会如何：</p><ul><li>用组件和模板构建 Angular 表单</li><li>用 <code>ngModel</code> 创建双向数据绑定，以读取和写入输入控件的值</li><li>跟踪状态的变化，并验证表单控件</li><li>使用特殊的 CSS 类来跟踪控件的状态并给出视觉反馈</li><li>向用户显示验证错误提示，以及启用/禁用表单控件</li><li>使用模板引用变量在 HTML 元素之间共享信息</li></ul><ol><li><p>创建 Hero 模型类</p><p><code>ng generate class Hero</code></p><p>代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> id: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> name: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> power: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> alterEgo?: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建表达组件</p><p><code>ng generate component HeroForm</code></p><p>代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Hero &#125;    <span class="keyword">from</span> <span class="string">&#x27;../hero&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-hero-form&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./hero-form.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./hero-form.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroFormComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  powers = [<span class="string">&#x27;Really Smart&#x27;</span>, <span class="string">&#x27;Super Flexible&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Super Hot&#x27;</span>, <span class="string">&#x27;Weather Changer&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  model = <span class="keyword">new</span> Hero(<span class="number">18</span>, <span class="string">&#x27;Dr IQ&#x27;</span>, <span class="built_in">this</span>.powers[<span class="number">0</span>], <span class="string">&#x27;Chuck Overstreet&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  submitted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onSubmit</span>(<span class="params"></span>)</span> &#123; <span class="built_in">this</span>.submitted = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Remove this when we&#x27;re done</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">diagnostic</span>() &#123; <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.model); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 app.module.ts</p><p>因为模板驱动的表单位于它们自己的模块，所以在使用表单之前，需要将 <code>FormsModule</code> 添加到应用模块的 <code>imports</code> 数组中。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;      <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125;   <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125;  <span class="keyword">from</span> <span class="string">&#x27;./app.component&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HeroFormComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;./hero-form/hero-form.component&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent,</span><br><span class="line">    HeroFormComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">providers</span>: [],</span><br><span class="line">  <span class="attr">bootstrap</span>: [ AppComponent ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 app.component.ts</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;app-hero-form&gt;&lt;/app-hero-form&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建初始 HTML 表单模板</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hero Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;alterEgo&quot;</span>&gt;</span>Alter Ego<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;alterEgo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="5-Observable和RxJS"><a href="#5-Observable和RxJS" class="headerlink" title="5-Observable和RxJS"></a>5-Observable和RxJS</h1><h2 id="5-1-可观察对象（Observable）"><a href="#5-1-可观察对象（Observable）" class="headerlink" title="5.1-可观察对象（Observable）"></a>5.1-可观察对象（Observable）</h2><p>可观察对象支持在应用中的发布者和订阅者之间传递消息。 在需要进行事件处理、异步编程和处理多个值的时候，可观察对象相对其它技术有着显著的优点。</p><p>可观察对象是声明式的 —— 也就是说，虽然你定义了一个用于发布值的函数，但是在有消费者订阅它之前，这个函数并不会实际执行。 订阅之后，当这个函数执行完或取消订阅时，订阅者就会收到通知。</p><p>可观察对象可以发送多个任意类型的值 —— 字面量、消息、事件。无论这些值是同步发送的还是异步发送的，接收这些值的 API 都是一样的。 由于准备（setup）和清场（teardown）的逻辑都是由可观察对象自己处理的，因此你的应用代码只管订阅并消费这些值就可以了，做完之后，取消订阅。无论这个流是击键流、HTTP 响应流还是定时器，对这些值进行监听和停止监听的接口都是一样的。</p><ul><li><p>基本用法</p><p>作为发布者，你创建一个 <code>Observable</code> 的实例，其中定义了一个<em>订阅者（subscriber）</em>函数。 当有消费者调用 <code>subscribe()</code> 方法时，这个函数就会执行。 订阅者函数用于定义“如何获取或生成那些要发布的值或消息”。</p><p>要执行所创建的可观察对象，并开始从中接收通知，你就要调用它的 <code>subscribe()</code> 方法，并传入一个<em>观察者（observer）</em>。 这是一个 JavaScript 对象，它定义了你收到的这些消息的处理器（handler）。 <code>subscribe()</code> 调用会返回一个 <code>Subscription</code> 对象，该对象具有一个 <code>unsubscribe()</code> 方法。 当调用该方法时，你就会停止接收通知。</p><p>下面这个例子中示范了这种基本用法，它展示了如何使用可观察对象来对当前地理位置进行更新。</p><p>Observe geolocation updates</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create an Observable that will start listening to geolocation updates</span></span><br><span class="line"><span class="comment">// when a consumer subscribes.</span></span><br><span class="line"><span class="keyword">const</span> locations = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Get the next and error callbacks. These will be passed in when</span></span><br><span class="line">  <span class="comment">// the consumer subscribes.</span></span><br><span class="line">  <span class="keyword">const</span> &#123;next, error&#125; = observer;</span><br><span class="line">  <span class="keyword">let</span> watchId;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Simple geolocation API check provides values to publish</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;geolocation&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    watchId = navigator.geolocation.watchPosition(next, error);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    error(<span class="string">&#x27;Geolocation not available&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// When the consumer unsubscribes, clean up data ready for next subscription.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="function"><span class="title">unsubscribe</span>(<span class="params"></span>)</span> &#123; navigator.geolocation.clearWatch(watchId); &#125;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Call subscribe() to start listening for updates.</span></span><br><span class="line"><span class="keyword">const</span> locationsSubscription = locations.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">position</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Current Position: &#x27;</span>, position); &#125;,</span><br><span class="line">  <span class="function"><span class="title">error</span>(<span class="params">msg</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Error Getting Location: &#x27;</span>, msg); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Stop listening for location after 10 seconds</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; locationsSubscription.unsubscribe(); &#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure></li><li><p>定义观察者</p><p>用于接收可观察对象通知的处理器要实现 <code>Observer</code> 接口。这个对象定义了一些回调函数来处理可观察对象可能会发来的三种通知：</p><table><thead><tr><th>通知类型</th><th>说明</th></tr></thead><tbody><tr><td>next</td><td>必要。用来处理每个送达值。在开始执行后可能执行零次或多次。</td></tr><tr><td>error</td><td>可选。用来处理错误通知。错误会中断这个可观察对象实例的执行过程。</td></tr><tr><td>complete</td><td>可选。用来处理执行完毕（complete）通知。当执行完毕后，这些值就会继续传给下一个处理器。</td></tr></tbody></table><p>观察者对象可以定义这三种处理器的任意组合。如果你不为某种通知类型提供处理器，这个观察者就会忽略相应类型的通知。</p></li><li><p>订阅</p><p>只有当有人订阅 <code>Observable</code> 的实例时，它才会开始发布值。 订阅时要先调用该实例的 <code>subscribe()</code> 方法，并把一个观察者对象传给它，用来接收通知。</p><p>下面的例子会创建并订阅一个简单的可观察对象，它的观察者会把接收到的消息记录到控制台中：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create simple observable that emits three values</span></span><br><span class="line"><span class="keyword">const</span> myObservable = <span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create observer object</span></span><br><span class="line"><span class="keyword">const</span> myObserver = &#123;</span><br><span class="line">  <span class="attr">next</span>: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Observer got a next value: &#x27;</span> + x),</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Observer got an error: &#x27;</span> + err),</span><br><span class="line">  <span class="attr">complete</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Observer got a complete notification&#x27;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Execute with the observer object</span></span><br><span class="line">myObservable.subscribe(myObserver);</span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// Observer got a next value: 1</span></span><br><span class="line"><span class="comment">// Observer got a next value: 2</span></span><br><span class="line"><span class="comment">// Observer got a next value: 3</span></span><br><span class="line"><span class="comment">// Observer got a complete notification</span></span><br></pre></td></tr></table></figure><p>另外，<code>subscribe()</code> 方法还可以接收定义在同一行中的回调函数，无论 <code>next</code>、<code>error</code> 还是 <code>complete</code> 处理器。比如，下面的 <code>subscribe()</code> 调用和前面指定预定义观察者的例子是等价的。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">myObservable.subscribe(</span><br><span class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Observer got a next value: &#x27;</span> + x),</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Observer got an error: &#x27;</span> + err),</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Observer got a complete notification&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>无论哪种情况，<code>next</code> 处理器都是必要的，而 <code>error</code> 和 <code>complete</code> 处理器是可选的。</p><p>注意，<code>next()</code> 函数可以接受消息字符串、事件对象、数字值或各种结构，具体类型取决于上下文。 为了更通用一点，我们把由可观察对象发布出来的数据统称为<em>流</em>。任何类型的值都可以表示为可观察对象，而这些值会被发布为一个流。</p></li><li><p>创建可观察对象</p><p>使用 <code>Observable</code> 构造函数可以创建任何类型的可观察流。 当执行可观察对象的 <code>subscribe()</code> 方法时，这个构造函数就会把它接收到的参数作为订阅函数来运行。 订阅函数会接收一个 <code>Observer</code> 对象，并把值发布给观察者的 <code>next()</code> 方法。</p><p>比如，要创建一个与前面的 <code>of(1, 2, 3)</code> 等价的可观察对象，你可以这样做：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This function runs when subscribe() is called</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// synchronously deliver 1, 2, and 3, then complete</span></span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.next(<span class="number">2</span>);</span><br><span class="line">  observer.next(<span class="number">3</span>);</span><br><span class="line">  observer.complete();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// unsubscribe function doesn&#x27;t need to do anything in this</span></span><br><span class="line">  <span class="comment">// because values are delivered synchronously</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="function"><span class="title">unsubscribe</span>(<span class="params"></span>)</span> &#123;&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create a new Observable that will deliver the above sequence</span></span><br><span class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// execute the Observable and print the result of each notification</span></span><br><span class="line">sequence.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(num); &#125;,</span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Finished sequence&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Finished sequence</span></span><br></pre></td></tr></table></figure><p>如果要略微加强这个例子，我们可以创建一个用来发布事件的可观察对象。在这个例子中，订阅函数是用内联方式定义的。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromEvent</span>(<span class="params">target, eventName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> observer.next(e);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Add the event handler to the target</span></span><br><span class="line">    target.addEventListener(eventName, handler);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Detach the event handler from the target</span></span><br><span class="line">      target.removeEventListener(eventName, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你就可以使用这个函数来创建可发布 <code>keydown</code> 事件的可观察对象了：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ESC_KEY = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> nameInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;name&#x27;</span>) <span class="keyword">as</span> HTMLInputElement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscription = fromEvent(nameInput, <span class="string">&#x27;keydown&#x27;</span>)</span><br><span class="line">  .subscribe(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === ESC_KEY) &#123;</span><br><span class="line">      nameInput.value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>多播</p><p>典型的可观察对象会为每一个观察者创建一次新的、独立的执行。 当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。</p><p>有时候，不应该对每一个订阅者都独立执行一次，你可能会希望每次订阅都得到同一批值 —— 即使是那些你已经发送过的。这在某些情况下有用，比如用来发送 <code>document</code> 上的点击事件的可观察对象。</p><p><em>多播</em>用来让可观察对象在一次执行中同时广播给多个订阅者。借助支持多播的可观察对象，你不必注册多个监听器，而是复用第一个（<code>next</code>）监听器，并且把值发送给各个订阅者。</p><p>当创建可观察对象时，你要决定你希望别人怎么用这个对象以及是否对它的值进行多播。</p><p>来看一个从 1 到 3 进行计数的例子，它每发出一个数字就会等待 1 秒。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Will run through an array of numbers, emitting one value</span></span><br><span class="line">  <span class="comment">// per second until it gets to the end of the array.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">arr, idx</span>) </span>&#123;</span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      observer.next(arr[idx]);</span><br><span class="line">      <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        observer.complete();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doSequence(arr, ++idx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  doSequence(seq, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Unsubscribe should clear the timeout to stop execution</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="function"><span class="title">unsubscribe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create a new Observable that will deliver the above sequence</span></span><br><span class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</span><br><span class="line"> </span><br><span class="line">sequence.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(num); &#125;,</span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Finished sequence&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// (at 1 second): 1</span></span><br><span class="line"><span class="comment">// (at 2 seconds): 2</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 3</span></span><br><span class="line"><span class="comment">// (at 3 seconds): Finished sequence</span></span><br></pre></td></tr></table></figure><p>注意，如果你订阅了两次，就会有两个独立的流，每个流都会每秒发出一个数字。代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Subscribe starts the clock, and will emit after 1 second</span></span><br><span class="line">sequence.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;1st subscribe: &#x27;</span> + num); &#125;,</span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;1st sequence finished.&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// After 1/2 second, subscribe again.</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  sequence.subscribe(&#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;2nd subscribe: &#x27;</span> + num); &#125;,</span><br><span class="line">    <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;2nd sequence finished.&#x27;</span>); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// (at 1 second): 1st subscribe: 1</span></span><br><span class="line"><span class="comment">// (at 1.5 seconds): 2nd subscribe: 1</span></span><br><span class="line"><span class="comment">// (at 2 seconds): 1st subscribe: 2</span></span><br><span class="line"><span class="comment">// (at 2.5 seconds): 2nd subscribe: 2</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 1st subscribe: 3</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 1st sequence finished</span></span><br><span class="line"><span class="comment">// (at 3.5 seconds): 2nd subscribe: 3</span></span><br><span class="line"><span class="comment">// (at 3.5 seconds): 2nd sequence finished</span></span><br></pre></td></tr></table></figure><p>修改这个可观察对象以支持多播，代码如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicastSequenceSubscriber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="comment">// Keep track of each observer (one for every active subscription)</span></span><br><span class="line">  <span class="keyword">const</span> observers = [];</span><br><span class="line">  <span class="comment">// Still a single timeoutId because there will only ever be one</span></span><br><span class="line">  <span class="comment">// set of values being generated, multicasted to each subscriber</span></span><br><span class="line">  <span class="keyword">let</span> timeoutId;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Return the subscriber function (runs when subscribe()</span></span><br><span class="line">  <span class="comment">// function is invoked)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">    observers.push(observer);</span><br><span class="line">    <span class="comment">// When this is the first subscription, start the sequence</span></span><br><span class="line">    <span class="keyword">if</span> (observers.length === <span class="number">1</span>) &#123;</span><br><span class="line">      timeoutId = doSequence(&#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">          <span class="comment">// Iterate through observers and notify all subscriptions</span></span><br><span class="line">          observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.next(val));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="comment">// Notify all complete callbacks</span></span><br><span class="line">          observers.slice(<span class="number">0</span>).forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.complete());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, seq, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">unsubscribe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Remove from the observers array so it&#x27;s no longer notified</span></span><br><span class="line">        observers.splice(observers.indexOf(observer), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// If there&#x27;s no more listeners, do cleanup</span></span><br><span class="line">        <span class="keyword">if</span> (observers.length === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Run through an array of numbers, emitting one value</span></span><br><span class="line"><span class="comment">// per second until it gets to the end of the array.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">observer, arr, idx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    observer.next(arr[idx]);</span><br><span class="line">    <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      observer.complete();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doSequence(observer, arr, ++idx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create a new Observable that will deliver the above sequence</span></span><br><span class="line"><span class="keyword">const</span> multicastSequence = <span class="keyword">new</span> Observable(multicastSequenceSubscriber());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Subscribe starts the clock, and begins to emit after 1 second</span></span><br><span class="line">multicastSequence.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;1st subscribe: &#x27;</span> + num); &#125;,</span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;1st sequence finished.&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// After 1 1/2 seconds, subscribe again (should &quot;miss&quot; the first value).</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  multicastSequence.subscribe(&#123;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;2nd subscribe: &#x27;</span> + num); &#125;,</span><br><span class="line">    <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;2nd sequence finished.&#x27;</span>); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">1500</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Logs:</span></span><br><span class="line"><span class="comment">// (at 1 second): 1st subscribe: 1</span></span><br><span class="line"><span class="comment">// (at 2 seconds): 1st subscribe: 2</span></span><br><span class="line"><span class="comment">// (at 2 seconds): 2nd subscribe: 2</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 1st subscribe: 3</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 1st sequence finished</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 2nd subscribe: 3</span></span><br><span class="line"><span class="comment">// (at 3 seconds): 2nd sequence finished</span></span><br></pre></td></tr></table></figure></li><li><p>错误处理</p><p>由于可观察对象会异步生成值，所以用 <code>try/catch</code> 是无法捕获错误的。你应该在观察者中指定一个 <code>error</code> 回调来处理错误。发生错误时还会导致可观察对象清理现有的订阅，并且停止生成值。可观察对象可以生成值（调用 <code>next</code> 回调），也可以调用 <code>complete</code> 或 <code>error</code> 回调来主动结束。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">myObservable.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">num</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Next num: &#x27;</span> + num)&#125;,</span><br><span class="line">  <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Received an errror: &#x27;</span> + err)&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2-RxJS库"><a href="#5-2-RxJS库" class="headerlink" title="5.2-RxJS库"></a>5.2-RxJS库</h2><p>响应式编程是一种面向数据流和变更传播的异步编程范式（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">Wikipedia</a>）。RxJS（响应式扩展的 JavaScript 版）是一个使用可观察对象进行响应式编程的库，它让组合异步代码和基于回调的代码变得更简单 (<a target="_blank" rel="noopener" href="http://reactivex.io/rxjs/">RxJS Docs</a>)。</p><p>RxJS 提供了一种对 <code>Observable</code> 类型的实现，直到 <code>Observable</code> 成为了 JavaScript 语言的一部分并且浏览器支持它之前，它都是必要的。这个库还提供了一些工具函数，用于创建和使用可观察对象。这些工具函数可用于：</p><ul><li>把现有的异步代码转换成可观察对象</li><li>迭代流中的各个值</li><li>把这些值映射成其它类型</li><li>对流进行过滤</li><li>组合多个流</li></ul><ol><li><p>创建可观察对象的函数</p><p>RxJS 提供了一些用来创建可观察对象的函数。这些函数可以简化根据某些东西创建可观察对象的过程，比如事件、定时器、承诺等等。</p><p>比如：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">from</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an Observable out of a promise</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">from</span>(fetch(<span class="string">&#x27;/api/endpoint&#x27;</span>));</span><br><span class="line"><span class="comment">// Subscribe to begin listening for async result</span></span><br><span class="line">data.subscribe(&#123;</span><br><span class="line"> <span class="function"><span class="title">next</span>(<span class="params">response</span>)</span> &#123; <span class="built_in">console</span>.log(response); &#125;,</span><br><span class="line"> <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123; <span class="built_in">console</span>.error(<span class="string">&#x27;Error: &#x27;</span> + err); &#125;,</span><br><span class="line"> <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Completed&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; interval &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an Observable that will publish a value on an interval</span></span><br><span class="line"><span class="keyword">const</span> secondsCounter = interval(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// Subscribe to begin publishing values</span></span><br><span class="line">secondsCounter.subscribe(<span class="function"><span class="params">n</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`It&#x27;s been <span class="subst">$&#123;n&#125;</span> seconds since subscribing!`</span>));</span><br></pre></td></tr></table></figure></li><li><p>操作符</p><p>操作符是基于可观察对象构建的一些对集合进行复杂操作的函数。RxJS 定义了一些操作符，比如 <code>map()</code>、<code>filter()</code>、<code>concat()</code> 和 <code>flatMap()</code>。</p><p>操作符接受一些配置项，然后返回一个以来源可观察对象为参数的函数。当执行这个返回的函数时，这个操作符会观察来源可观察对象中发出的值，转换它们，并返回由转换后的值组成的新的可观察对象。</p><p>下面是一个简单的例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> squareValues = map(<span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val * val);</span><br><span class="line"><span class="keyword">const</span> squaredNums = squareValues(nums);</span><br><span class="line"> </span><br><span class="line">squaredNums.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><p>你可以使用<em>管道</em>来把这些操作符链接起来。管道让你可以把多个由操作符返回的函数组合成一个。<code>pipe()</code> 函数以你要组合的这些函数作为参数，并且返回一个新的函数，当执行这个新函数时，就会顺序执行那些被组合进去的函数。</p><p>应用于某个可观察对象上的一组操作符就像一个菜谱 —— 也就是说，对你感兴趣的这些值进行处理的一组操作步骤。这个菜谱本身不会做任何事。你需要调用 <code>subscribe()</code> 来通过这个菜谱生成一个结果。</p><p>例子如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create a function that accepts an Observable.</span></span><br><span class="line"><span class="keyword">const</span> squareOddVals = pipe(</span><br><span class="line">  filter(<span class="function">(<span class="params">n: <span class="built_in">number</span></span>) =&gt;</span> n % <span class="number">2</span> !== <span class="number">0</span>),</span><br><span class="line">  map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create an Observable that will run the filter and map functions</span></span><br><span class="line"><span class="keyword">const</span> squareOdd = squareOddVals(nums);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Subscribe to run the combined functions</span></span><br><span class="line">squareOdd.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><p><code>pipe()</code> 函数也同时是 RxJS 的 <code>Observable</code> 上的一个方法，所以你可以用下列简写形式来达到同样的效果：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> squareOdd = <span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">  .pipe(</span><br><span class="line">    filter(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> !== <span class="number">0</span>),</span><br><span class="line">    map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe to get values</span></span><br><span class="line">squareOdd.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><p>RxJS 提供了很多操作符，不过只有少数是常用的。 下面是一个常用操作符的列表和用法范例，参见 <a target="_blank" rel="noopener" href="https://rxjs-dev.firebaseapp.com/api">RxJS API 文档</a>。</p></li><li><p>错误处理</p><p>除了可以在订阅时提供 <code>error()</code> 处理器外，RxJS 还提供了 <code>catchError</code> 操作符，它允许你在管道中处理已知错误。</p><p>假设你有一个可观察对象，它发起 API 请求，然后对服务器返回的响应进行映射。如果服务器返回了错误或值不存在，就会生成一个错误。如果你捕获这个错误并提供了一个默认值，流就会继续处理这些值，而不会报错。</p><p>下面是使用 <code>catchError</code> 操作符实现这种效果的例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/ajax&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; map, catchError &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"><span class="comment">// Return &quot;response&quot; from the API. If an error happens,</span></span><br><span class="line"><span class="comment">// return an empty array.</span></span><br><span class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">&#x27;/api/data&#x27;</span>).pipe(</span><br><span class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.response) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Value expected!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.response;</span><br><span class="line">  &#125;),</span><br><span class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> <span class="keyword">of</span>([]))</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">apiData.subscribe(&#123;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">x</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;data: &#x27;</span>, x); &#125;,</span><br><span class="line">  <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;errors already caught... will not run&#x27;</span>); &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-3-Angular中的可观察对象"><a href="#5-3-Angular中的可观察对象" class="headerlink" title="5.3-Angular中的可观察对象"></a>5.3-Angular中的可观察对象</h2><p>Angular 使用可观察对象作为处理各种常用异步操作的接口。比如：</p><ul><li><code>EventEmitter</code> 类派生自 <code>Observable</code>。</li><li>HTTP 模块使用可观察对象来处理 AJAX 请求和响应。</li><li>路由器和表单模块使用可观察对象来监听对用户输入事件的响应。</li></ul><ol><li><p>事件发送器 EventEmitter</p><p>Angular 提供了一个 <code>EventEmitter</code> 类，它用来从组件的 <code>@Output()</code> 属性中发布一些值。<code>EventEmitter</code> 扩展了 <code>Observable</code>，并添加了一个 <code>emit()</code> 方法，这样它就可以发送任意值了。当你调用 <code>emit()</code> 时，就会把所发送的值传给订阅上来的观察者的 <code>next()</code> 方法。</p><p>这种用法的例子参见 <a target="_blank" rel="noopener" href="https://angular.cn/api/core/EventEmitter">EventEmitter</a> 文档。下面这个范例组件监听了 <code>open</code> 和 <code>close</code> 事件：</p><p>``</p><p>组件的定义如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;zippy&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;zippy&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div (click)=&quot;toggle()&quot;&gt;Toggle&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div [hidden]=&quot;!visible&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;ng-content&gt;&lt;/ng-content&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ZippyComponent</span> </span>&#123;</span><br><span class="line">  visible = <span class="literal">true</span>;</span><br><span class="line">  <span class="meta">@Output</span>() open = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line">  <span class="meta">@Output</span>() close = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">any</span>&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">toggle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.visible = !<span class="built_in">this</span>.visible;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.visible) &#123;</span><br><span class="line">      <span class="built_in">this</span>.open.emit(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.close.emit(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HTTP</p><p>Angular 的 <code>HttpClient</code> 从 HTTP 方法调用中返回了可观察对象。例如，<code>http.get(‘/api’)</code> 就会返回可观察对象。相对于基于承诺（Promise）的 HTTP API，它有一系列优点：</p><ul><li>可观察对象不会修改服务器的响应（和在承诺上串联起来的 <code>.then()</code> 调用一样）。反之，你可以使用一系列操作符来按需转换这些值。</li><li>HTTP 请求是可以通过 <code>unsubscribe()</code> 方法来取消的。</li><li>请求可以进行配置，以获取进度事件的变化。</li><li>失败的请求很容易重试。</li></ul></li><li><p>Async管道</p><p><a target="_blank" rel="noopener" href="https://angular.cn/api/common/AsyncPipe">AsyncPipe</a> 会订阅一个可观察对象或承诺，并返回其发出的最后一个值。当发出新值时，该管道就会把这个组件标记为需要进行变更检查的（译注：因此可能导致刷新界面）。</p><p>下面的例子把 <code>time</code> 这个可观察对象绑定到了组件的视图中。这个可观察对象会不断使用当前时间更新组件的视图。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;async-observable-pipe&#x27;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&lt;code&gt;observable|async&lt;/code&gt;:</span></span><br><span class="line"><span class="string">       Time: &#123;&#123; time | async &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncObservablePipeComponent</span> </span>&#123;</span><br><span class="line">  time = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> observer.next(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>路由器 (router)</p><p><a target="_blank" rel="noopener" href="https://angular.cn/api/router/Router#events"><code>Router.events</code></a> 以可观察对象的形式提供了其事件。 你可以使用 RxJS 中的 <code>filter()</code> 操作符来找到感兴趣的事件，并且订阅它们，以便根据浏览过程中产生的事件序列作出决定。</p><p>例子如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router, NavigationStart &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; filter &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-routable&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./routable.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./routable.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Routable1Component</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="attr">navStart</span>: Observable&lt;NavigationStart&gt;;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Create a new Observable that publishes only the NavigationStart event</span></span><br><span class="line">    <span class="built_in">this</span>.navStart = router.events.pipe(</span><br><span class="line">      filter(<span class="function"><span class="params">evt</span> =&gt;</span> evt <span class="keyword">instanceof</span> NavigationStart)</span><br><span class="line">    ) <span class="keyword">as</span> Observable&lt;NavigationStart&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.navStart.subscribe(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Navigation Started!&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://angular.cn/api/router/ActivatedRoute">ActivatedRoute</a> 是一个可注入的路由器服务，它使用可观察对象来获取关于路由路径和路由参数的信息。比如，<code>ActivateRoute.url</code> 包含一个用于汇报路由路径的可观察对象。</p><p>例子如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/router&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-routable&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./routable.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./routable.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Routable2Component</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> activatedRoute: ActivatedRoute</span>)</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.activatedRoute.url</span><br><span class="line">      .subscribe(<span class="function"><span class="params">url</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;The URL changed to: &#x27;</span> + url));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="6-NgModule"><a href="#6-NgModule" class="headerlink" title="6-NgModule"></a>6-NgModule</h1><p><strong>NgModules</strong> 用于配置注入器和编译器，并帮你把那些相关的东西组织在一起。</p><p>NgModule 是一个带有 <code>@NgModule</code> 装饰器的类。 <code>@NgModule</code> 的参数是一个元数据对象，用于描述如何编译组件的模板，以及如何在运行时创建注入器。 它会标出该模块自己的组件、指令和管道，通过 <code>exports</code> 属性公开其中的一部分，以便外部组件使用它们。 <code>NgModule</code> 还能把一些服务提供商添加到应用的依赖注入器中。</p><h2 id="6-1-启动过程"><a href="#6-1-启动过程" class="headerlink" title="6.1-启动过程"></a>6.1-启动过程</h2><p>NgModule 用于描述应用的各个部分如何组织在一起。 每个应用有至少一个 Angular 模块，<em>根</em>模块就是你用来启动此应用的模块。 按照惯例，它通常命名为 <code>AppModule</code>。</p><p>如果你使用 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/cli">Angular CLI</a> 来生成一个应用，其默认的 <code>AppModule</code> 是这样的：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JavaScript imports */</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/forms&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/common/http&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.component&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* the AppModule class with the @NgModule decorator */</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule,</span><br><span class="line">    HttpClientModule</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">providers</span>: [],</span><br><span class="line">  <span class="attr">bootstrap</span>: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>在 <code>import</code> 语句之后，是一个带有 <strong><code>@NgModule</code></strong> <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/glossary#decorator">装饰器</a>的类。</p><p><code>@NgModule</code> 装饰器表明 <code>AppModule</code> 是一个 <code>NgModule</code> 类。 <code>@NgModule</code> 获取一个元数据对象，它会告诉 Angular 如何编译和启动本应用。</p><ul><li><strong>declarations</strong> —— 该应用所拥有的组件。</li><li><strong>imports</strong> —— 导入 <code>BrowserModule</code> 以获取浏览器特有的服务，比如 DOM 渲染、无害化处理和位置（location）。</li><li><strong>providers</strong> —— 各种服务提供商。</li><li><strong>bootstrap</strong> —— <em>根</em>组件，Angular 创建它并插入 <code>index.html</code> 宿主页面。</li></ul><p>Angular CLI 创建的默认应用只有一个组件 <code>AppComponent</code>，所以它会同时出现在 <code>declarations</code> 和 <code>bootstrap</code> 数组中。</p><ol><li><p>declarations 数组</p><p>该模块的 <code>declarations</code> 数组告诉 Angular 哪些组件属于该模块。 当你创建更多组件时，也要把它们添加到 <code>declarations</code> 中。</p><p>每个组件都应该（且只能）声明（declare）在一个 <code>NgModule</code> 类中。 如果你使用了未声明过的组件，Angular 就会报错。</p><p><code>declarations</code> 数组只能接受可声明对象。可声明对象包括组件、<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/attribute-directives">指令</a>和<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/pipes">管道</a>。 一个模块的所有可声明对象都必须放在 <code>declarations</code> 数组中。 可声明对象必须只能属于一个模块，如果同一个类被声明在了多个模块中，编译器就会报错。</p><p>这些可声明的类在当前模块中是可见的，但是对其它模块中的组件是不可见的 —— 除非把它们从当前模块导出， 并让对方模块导入本模块</p><p>下面是哪些类可以添加到 <code>declarations</code> 数组中的例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">declarations: [</span><br><span class="line">  YourComponent,</span><br><span class="line">  YourPipe,</span><br><span class="line">  YourDirective</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>每个可声明对象都只能属于一个模块，所以只能把它声明在一个 <code>@NgModule</code> 中。当你需要在其它模块中使用它时，就要在那里导入包含这个可声明对象的模块。</p><p><strong>只有 <code>@NgModule</code></strong> 可以出现在 <code>imports</code> 数组中。</p></li><li><p>imports 数组模块的 <code>imports</code> 数组只会出现在 <code>@NgModule</code> 元数据对象中。 它告诉 Angular 该模块想要正常工作，还需要哪些模块。</p><p>列表中的模块导出了本模块中的各个组件模板中所引用的各个组件、指令或管道。在这个例子中，当前组件是 <code>AppComponent</code>，它引用了导出自 <code>BrowserModule</code>、<code>FormsModule</code> 或 <code>HttpClientModule</code> 的组件、指令或管道。 总之，组件的模板中可以引用在当前模块中声明的或从其它模块中导入的组件、指令、管道。</p></li><li><p>providers 数组</p><p><code>providers</code> 数组中列出了该应用所需的服务。当直接把服务列在这里时，它们是全应用范围的。 当你使用特性模块和惰性加载时，它们是范围化的。</p></li><li><p>bootstrap 数组</p><p>应用是通过引导根模块 <code>AppModule</code> 来启动的，根模块还引用了 <code>entryComponent</code>。 此外，引导过程还会创建 <code>bootstrap</code> 数组中列出的组件，并把它们逐个插入到浏览器的 DOM 中。</p><p>每个被引导的组件都是它自己的组件树的根。 插入一个被引导的组件通常触发一系列组件的创建并形成组件树。</p><p>虽然也可以在宿主页面中放多个组件，但是大多数应用只有一个组件树，并且只从一个根组件开始引导。</p><p>这个根组件通常叫做 <code>AppComponent</code>，并且位于根模块的 <code>bootstrap</code> 数组中。</p></li></ol><h2 id="6-2-常用模块"><a href="#6-2-常用模块" class="headerlink" title="6.2-常用模块"></a>6.2-常用模块</h2><ol><li><p>Angular模块化</p><p>模块是组织应用和使用外部库扩展应用的最佳途径。</p><p>Angular 自己的库都是 NgModule，比如 <code>FormsModule</code>、<code>HttpClientModule</code> 和 <code>RouterModule</code>。 很多第三方库也是 NgModule，比如 <a target="_blank" rel="noopener" href="https://material.angular.cn/">Material Design</a>、 <a target="_blank" rel="noopener" href="http://ionicframework.com/">Ionic</a> 和 <a target="_blank" rel="noopener" href="https://github.com/angular/angularfire2">AngularFire2</a>。</p><p>NgModule 把组件、指令和管道打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。</p><p>模块还可以把服务加到应用中。 这些服务可能是内部开发的（比如你自己写的），或者来自外部的（比如 Angular 的路由和 HTTP 客户端）。</p><p>模块可以在应用启动时急性加载，也可以由路由器进行异步的惰性加载。</p><p>NgModule 的元数据会做这些：</p><ul><li>声明某些组件、指令和管道属于这个模块。</li><li>公开其中的部分组件、指令和管道，以便其它模块中的组件模板中可以使用它们。</li><li>导入其它带有组件、指令和管道的模块，这些模块中的元件都是本模块所需的。</li><li>提供一些供应用中的其它组件使用的服务。</li></ul><p>每个 Angular 应用都至少有一个模块，也就是根模块。 你可以<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/bootstrapping">引导</a>那个模块，以启动该应用。</p><p>对于那些只有少量组件的简单应用，根模块就是你所需的一切。 随着应用的成长，你要把这个根模块重构成一些<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/feature-modules">特性模块</a>，它们代表一组密切相关的功能集。 然后你再把这些模块导入到根模块中。</p></li><li><p>常用模块</p><table><thead><tr><th>NgModule</th><th>导入自</th><th>为何使用</th></tr></thead><tbody><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/platform-browser/BrowserModule">BrowserModule</a></td><td>@angular/platform-browser</td><td>当你想要在浏览器中运行应用时</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/common/CommonModule">CommonModule</a></td><td>@angular/common</td><td>当你想要使用 <code>NgIf</code> 和 <code>NgFor</code> 时</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/forms/FormsModule">FormsModule</a></td><td>@angular/forms</td><td>当要构建模板驱动表单时（它包含 <code>NgModel</code> ）</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/forms/ReactiveFormsModule">ReactiveFormsModule</a></td><td>@angular/forms</td><td>当要构建响应式表单时</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/router/RouterModule">RouterModule</a></td><td>@angular/router</td><td>要使用路由功能，并且你要用到 <code>RouterLink</code>,<code>.forRoot()</code> 和 <code>.forChild()</code> 时</td></tr><tr><td><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/common/http/HttpClientModule">HttpClientModule</a></td><td>@angular/common/<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/api/common/http">http</a></td><td>当你要和服务器对话时</td></tr></tbody></table></li></ol><h1 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7-依赖注入"></a>7-依赖注入</h1><p>依赖注入（DI）是一种重要的应用设计模式。 Angular 有自己的 DI 框架，在设计应用时常会用到它，以提升它们的开发效率和模块化程度。</p><p>依赖，是当类需要执行其功能时，所需要的服务或对象。 DI 是一种编码模式，其中的类会从外部源中请求获取依赖，而不是自己创建它们。</p><p>在 Angular 中，DI 框架会在实例化该类时向其提供这个类所声明的依赖项。本指南介绍了 DI 在 Angular 中的工作原理，以及如何借助它来让你的应用更灵活、高效、健壮，以及可测试、可维护。</p><h2 id="7-1-创建和注册可注入的服务"><a href="#7-1-创建和注册可注入的服务" class="headerlink" title="7.1-创建和注册可注入的服务"></a>7.1-创建和注册可注入的服务</h2><p>DI 框架让你能从一个可注入的<em>服务</em>类（独立文件）中为组件提供数据。为了演示，我们还会创建一个用来提供英雄列表的、可注入的服务类，并把它注册为该服务的提供商。</p><ul><li><p>创建可注册的服务类</p><p><a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/cli">Angular CLI</a> 可以用下列命令在 <code>src/app/heroes</code> 目录下生成一个新的 <code>HeroService</code> 类。</p><p><code>ng generate service heroes/hero</code></p><p>下列命令会创建 <code>HeroService</code> 的骨架。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Injectable()</code> 是每个 Angular 服务定义中的基本要素。该类的其余部分导出了一个 <code>getHeroes</code> 方法，它会返回像以前一样的模拟数据。（真实的应用可能会从远程服务器中异步获取这些数据，不过这里我们先忽略它，专心实现服务的注入机制。）</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HEROES &#125; <span class="keyword">from</span> <span class="string">&#x27;./mock-heroes&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  <span class="comment">// we declare that this service should be created</span></span><br><span class="line">  <span class="comment">// by the root application injector.</span></span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getHeroes</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> HEROES; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用服务提供商配置注入器</p><p>我们创建的类提供了一个服务。<code>@Injectable()</code> 装饰器把它标记为可供注入的服务，不过在你使用该服务的 <a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/glossary#provider">provider</a> 提供商配置好 Angular 的<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/glossary#injector">依赖注入器</a>之前，Angular 实际上无法将其注入到任何位置。</p><p>该注入器负责创建服务实例，并把它们注入到像 <code>HeroListComponent</code> 这样的类中。 你很少需要自己创建 Angular 的注入器。Angular 会在执行应用时为你创建注入器，第一个注入器是<em>根注入器</em>，创建于<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/bootstrapping">启动过程</a>中。</p><p>提供商会告诉注入器<em>如何创建该服务</em>。 要想让注入器能够创建服务（或提供其它类型的依赖），你必须使用某个提供商配置好注入器。</p><p>提供商可以是服务类本身，因此注入器可以使用 <code>new</code> 来创建实例。 你还可以定义多个类，以不同的方式提供同一个服务，并使用不同的提供商来配置不同的注入器。</p><p>你可以在三种位置之一设置元数据，以便在应用的不同层级使用提供商来配置注入器：</p><ul><li>在服务本身的 <code>@Injectable()</code> 装饰器中。</li><li>在 NgModule 的 <code>@NgModule()</code> 装饰器中。</li><li>在组件的 <code>@Component()</code> 装饰器中。</li></ul><p><code>@Injectable()</code> 装饰器具有一个名叫 <code>providedIn</code> 的元数据选项，在那里你可以指定把被装饰类的提供商放到 <code>root</code> 注入器中，或某个特定 NgModule 的注入器中。</p><p><code>@NgModule()</code> 和 <code>@Component()</code> 装饰器都有用一个 <code>providers</code> 元数据选项，在那里你可以配置 NgModule 级或组件级的注入器。</p></li><li><p>注入服务</p><p><code>HeroListComponent</code> 要想从 <code>HeroService</code> 中获取英雄列表，就得要求注入 <code>HeroService</code>，而不是自己使用 <code>new</code> 来创建自己的 <code>HeroService</code> 实例。</p><p>你可以通过制定<strong>带有依赖类型的构造函数参数</strong>来要求 Angular 在组件的构造函数中注入依赖项。下面的代码是 <code>HeroListComponent</code> 的构造函数，它要求注入 <code>HeroService</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(heroService: HeroService)</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-2-依赖注入实战"><a href="#7-2-依赖注入实战" class="headerlink" title="7.2-依赖注入实战"></a>7.2-依赖注入实战</h2><p>下面的例子往 <code>AppComponent</code> 里声明它依赖 <code>LoggerService</code> 和 <code>UserContext</code>。</p><p>src/app/app.component.ts</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">logger: LoggerService, <span class="keyword">public</span> userContext: UserContextService</span>)</span> &#123;</span><br><span class="line">  userContext.loadUser(<span class="built_in">this</span>.userId);</span><br><span class="line">  logger.logInfo(<span class="string">&#x27;AppComponent initialized&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserContext</code> 转而依赖 <code>LoggerService</code> 和 <code>UserService</code>（这个服务用来收集特定用户信息）。</p><p>user-context.service.ts (injection)</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContextService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> userService: UserService, <span class="keyword">private</span> loggerService: LoggerService</span>)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Angular 新建 <code>AppComponent</code> 时，依赖注入框架会先创建一个 <code>LoggerService</code> 的实例，然后创建 <code>UserContextService</code> 实例。 <code>UserContextService</code> 也需要框架刚刚创建的这个 <code>LoggerService</code> 实例，这样框架才能为它提供同一个实例。<code>UserContextService</code> 还需要框架创建过的 <code>UserService</code>。 <code>UserService</code> 没有其它依赖，所以依赖注入框架可以直接 <code>new</code> 出该类的一个实例，并把它提供给 <code>UserContextService</code> 的构造函数。</p><p>父组件 <code>AppComponent</code> 不需要了解这些依赖的依赖。 只要在构造函数中声明自己需要的依赖即可（这里是 <code>LoggerService</code> 和 <code>UserContextService</code>），框架会帮你解析这些嵌套的依赖。</p><p>当所有的依赖都就位之后，<code>AppComponent</code> 就会显示该用户的信息。</p><h1 id="8-HttpClient"><a href="#8-HttpClient" class="headerlink" title="8-HttpClient"></a>8-HttpClient</h1><p>大多数前端应用都需要通过 HTTP 协议与后端服务器通讯。现代浏览器支持使用两种不同的 API 发起 HTTP 请求：<code>XMLHttpRequest</code> 接口和 <code>fetch()</code> API。</p><p><code>@angular/common/http</code> 中的 <code>HttpClient</code> 类为 Angular 应用程序提供了一个简化的 API 来实现 HTTP 客户端功能。它基于浏览器提供的 <code>XMLHttpRequest</code> 接口。 <code>HttpClient</code> 带来的其它优点包括：可测试性、强类型的请求和响应对象、发起请求与接收响应时的拦截器支持，以及更好的、基于可观察（Observable）对象的 API 以及流式错误处理机制。</p><p>要想使用 <code>HttpClient</code>，就要先导入 Angular 的 <code>HttpClientModule</code>。大多数应用都会在根模块 <code>AppModule</code> 中导入它。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;         <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125;    <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClientModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/common/http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    <span class="comment">// import HttpClientModule after BrowserModule.</span></span><br><span class="line">    HttpClientModule,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">bootstrap</span>: [ AppComponent ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AppModule</code> 中导入 <code>HttpClientModule</code> 之后，你可以把 <code>HttpClient</code> 注入到应用类中，就像下面的 <code>ConfigService</code> 例子中这样。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpClient &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/common/http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> http: HttpClient</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-1-获取json数据"><a href="#8-1-获取json数据" class="headerlink" title="8.1-获取json数据"></a>8.1-获取json数据</h2><p>应用通常会从服务器上获取 JSON 数据。 比如，该应用可能要从服务器上获取配置文件 <code>config.json</code>，其中指定了一些特定资源的 URL。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;heroesUrl&quot;</span>: <span class="string">&quot;api/heroes&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;textfile&quot;</span>: <span class="string">&quot;assets/textfile.txt&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfigService</code> 会通过 <code>HttpClient</code> 的 <code>get()</code> 方法取得这个文件。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">configUrl = <span class="string">&#x27;assets/config.json&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getConfig</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.http.get(<span class="built_in">this</span>.configUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像 <code>ConfigComponent</code> 这样的组件会注入 <code>ConfigService</code>，并调用其 <code>getConfig</code> 方法。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">showConfig</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.configService.getConfig()</span><br><span class="line">    .subscribe(<span class="function">(<span class="params">data: Config</span>) =&gt;</span> <span class="built_in">this</span>.config = &#123;</span><br><span class="line">        <span class="attr">heroesUrl</span>: data[<span class="string">&#x27;heroesUrl&#x27;</span>],</span><br><span class="line">        <span class="attr">textfile</span>:  data[<span class="string">&#x27;textfile&#x27;</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个服务方法返回配置数据的 <code>Observable</code> 对象，所以组件要<strong>订阅（subscribe）</strong> 该方法的返回值。 订阅时的回调函数会把这些数据字段复制到组件的 <code>config</code> 对象中，它会在组件的模板中绑定，以供显示。</p><h2 id="8-2-发起http请求"><a href="#8-2-发起http请求" class="headerlink" title="8.2-发起http请求"></a>8.2-发起http请求</h2><ul><li><p>post请求</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">addHero (hero: Hero): Observable&lt;Hero&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.http.post&lt;Hero&gt;(<span class="built_in">this</span>.heroesUrl, hero, httpOptions)</span><br><span class="line">    .pipe(</span><br><span class="line">      catchError(<span class="built_in">this</span>.handleError(<span class="string">&#x27;addHero&#x27;</span>, hero))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpClient.post()</code> 方法像 <code>get()</code> 一样也有类型参数（你会希望服务器返回一个新的英雄对象），它包含一个资源 URL。</p><p>它还接受另外两个参数：</p><ol><li><code>hero</code> - 要 <code>POST</code> 的请求体数据。</li><li><code>httpOptions</code> - 这个例子中，该方法的选项<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/http#adding-headers">指定了所需的请求头</a>。</li></ol><p>当然，它捕获错误的方式很像<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/http#error-details">前面描述的</a>操作方式。</p><p><code>HeroesComponent</code> 通过订阅该服务方法返回的 <code>Observable</code> 发起了一次实际的 <code>POST</code> 操作。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.heroesService.addHero(newHero)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">hero</span> =&gt;</span> <span class="built_in">this</span>.heroes.push(hero));</span><br></pre></td></tr></table></figure><p>当服务器成功做出响应时，会带有这个新创建的英雄，然后该组件就会把这个英雄添加到正在显示的 <code>heroes</code> 列表中。</p></li><li><p>delete请求</p><p>该应用可以把英雄的 id 传给 <code>HttpClient.delete</code> 方法的请求 URL 来删除一个英雄。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">deleteHero (id: <span class="built_in">number</span>): Observable&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.heroesUrl&#125;</span>/<span class="subst">$&#123;id&#125;</span>`</span>; <span class="comment">// DELETE api/heroes/42</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.http.delete(url, httpOptions)</span><br><span class="line">    .pipe(</span><br><span class="line">      catchError(<span class="built_in">this</span>.handleError(<span class="string">&#x27;deleteHero&#x27;</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>HeroesComponent</code> 订阅了该服务方法返回的 <code>Observable</code> 时，就会发起一次实际的 <code>DELETE</code> 操作。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.heroesService.deleteHero(hero.id).subscribe();</span><br></pre></td></tr></table></figure><p>该组件不会等待删除操作的结果，所以它的 subscribe （订阅）中没有回调函数。不过就算你不关心结果，也仍然要订阅它。调用 <code>subscribe()</code> 方法会<strong>执行</strong>这个可观察对象，这时才会真的发起 DELETE 请求。</p></li></ul><h1 id="9-路由与导航"><a href="#9-路由与导航" class="headerlink" title="9-路由与导航"></a>9-路由与导航</h1><p>在用户使用应用程序时，Angular 的***路由器***能让用户从一个<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/glossary#view">视图</a>导航到另一个视图。</p><p>浏览器具有熟悉的导航模式：</p><ul><li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li><li>在页面中点击链接，浏览器就会导航到一个新页面。</li><li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li></ul><p>Angular 的 <code>Router</code>（即“路由器”）借鉴了这个模型。它把浏览器中的 URL 看做一个操作指南， 据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。 你可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。 当用户点击按钮、从下拉框中选取，或响应来自任何地方的事件时，你也可以在代码控制下进行导航。 路由器还在浏览器的历史日志中记录下这些活动，这样浏览器的前进和后退按钮也能照常工作。</p><h2 id="9-1-配置"><a href="#9-1-配置" class="headerlink" title="9.1-配置"></a>9.1-配置</h2><p>每个带路由的 Angular 应用都有一个*<code>Router</code>（路由器）*服务的单例对象。 当浏览器的 URL 变化时，路由器会查找对应的 <code>Route</code>（路由），并据此决定该显示哪个组件。</p><p>路由器需要先配置才会有路由信息。 下面的例子创建了五个路由定义，并用 <code>RouterModule.forRoot()</code> 方法来配置路由器， 并把它的返回值添加到 <code>AppModule</code> 的 <code>imports</code> 数组中。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> appRoutes: Routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;crisis-center&#x27;</span>, <span class="attr">component</span>: CrisisListComponent &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;hero/:id&#x27;</span>,      <span class="attr">component</span>: HeroDetailComponent &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;heroes&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: HeroListComponent,</span><br><span class="line">    <span class="attr">data</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;Heroes List&#x27;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">redirectTo</span>: <span class="string">&#x27;/heroes&#x27;</span>,</span><br><span class="line">    <span class="attr">pathMatch</span>: <span class="string">&#x27;full&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;**&#x27;</span>, <span class="attr">component</span>: PageNotFoundComponent &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    RouterModule.forRoot(</span><br><span class="line">      appRoutes,</span><br><span class="line">      &#123; <span class="attr">enableTracing</span>: <span class="literal">true</span> &#125; <span class="comment">// &lt;-- debugging purposes only</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// other imports here</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>这里的路由数组 <code>appRoutes</code> 描述如何进行导航。 把它传给 <code>RouterModule.forRoot()</code> 方法并传给本模块的 <code>imports</code> 数组就可以配置路由器。</p><p>每个 <code>Route</code> 都会把一个 URL 的 <code>path</code> 映射到一个组件。 注意，<code>path</code> 不能以<em>斜杠（<code>/</code>）</em>开头。 路由器会为解析和构建最终的 URL，这样当你在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。</p><p>第二个路由中的 <code>:id</code> 是一个路由参数的令牌(Token)。比如 <code>/hero/42</code> 这个 URL 中，“42”就是 <code>id</code> 参数的值。 此 URL 对应的 <code>HeroDetailComponent</code> 组件将据此查找和展现 <code>id</code> 为 42 的英雄。 在本章中稍后的部分，你将会学习关于路由参数的更多知识。</p><p>第三个路由中的 <code>data</code> 属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如 页标题、面包屑以及其它静态只读数据。本章稍后的部分，你将使用<a target="_blank" rel="noopener" href="http://angular-doc.paas.cmbchina.cn/guide/router#resolve-guard">resolve 守卫</a>来获取动态数据。</p><p>第四个路由中的空路径（<code>&#39;&#39;</code>）表示应用的默认路径，当 URL 为空时就会访问那里，因此它通常会作为起点。 这个默认路由会重定向到 URL <code>/heroes</code>，并显示 <code>HeroesListComponent</code>。</p><p>最后一个路由中的 <code>**</code> 路径是一个<strong>通配符</strong>。当所请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。 这个特性可用于显示“404 - Not Found”页，或自动重定向到其它路由。</p><p><strong>这些路由的定义顺序</strong>是刻意如此设计的。路由器使用<strong>先匹配者优先</strong>的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上<em>每一个 URL</em>，因此应该<strong>只有在</strong>前面找不到其它能匹配的路由时才匹配它。</p><p>如果你想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的 <strong>enableTracing</strong> 选项。它会把每个导航生命周期中的事件输出到浏览器的控制台。 这应该只用于<em>调试</em>。你只需要把 <code>enableTracing: true</code> 选项作为第二个参数传给 <code>RouterModule.forRoot()</code> 方法就可以了。</p><h2 id="9-2-路由出口"><a href="#9-2-路由出口" class="headerlink" title="9.2-路由出口"></a>9.2-路由出口</h2><p><code>RouterOutlet</code> 是一个来自路由模块中的指令，它的用法类似于组件。 它扮演一个占位符的角色，用于在模板中标出一个位置，路由器将会把要显示在这个出口处的组件显示在这里。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Routed components go here --&gt;</span></span><br></pre></td></tr></table></figure><p>有了这份配置，当本应用在浏览器中的 URL 变为 <code>/heroes</code> 时，路由器就会匹配到 <code>path</code> 为 <code>heroes</code> 的 <code>Route</code>，并在宿主视图中的*<code>RouterOutlet</code>*之后显示 <code>HeroListComponent</code> 组件。</p><h2 id="9-3-路由链接"><a href="#9-3-路由链接" class="headerlink" title="9.3-路由链接"></a>9.3-路由链接</h2><p>现在，你已经有了配置好的一些路由，还找到了渲染它们的地方，但又该如何导航到它呢？固然，从浏览器的地址栏直接输入 URL 也能做到，但是大多数情况下，导航是某些用户操作的结果，比如点击一个 A 标签。</p><p>考虑下列模板：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Angular Router<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">&quot;/crisis-center&quot;</span> <span class="attr">routerLinkActive</span>=<span class="string">&quot;active&quot;</span>&gt;</span>Crisis Center<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">&quot;/heroes&quot;</span> <span class="attr">routerLinkActive</span>=<span class="string">&quot;active&quot;</span>&gt;</span>Heroes<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/01/15/Angular%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://lemon-cs.github.io/2020/01/15/Angular%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/Angular/">Angular</a></div><div class="post_share"><div class="social-share" data-image="https://static01.imgkr.com/temp/b12638cdfe384f10ae77ede2ae7d804c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/16/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2021/12/6c4bf5b41815150b.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/11/Kafka%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://s3.bmp.ovh/imgs/2021/12/a560e450dd631e8f.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Kafka入门学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/01/18/CSS%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="CSS入门学习笔记"><img class="cover" src="https://s3.bmp.ovh/imgs/2022/01/759f29a6471f2f3b.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-18</div><div class="title">CSS入门学习笔记</div></div></a></div><div><a href="/2020/01/18/HTML%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="HTML入门学习笔记"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-18</div><div class="title">HTML入门学习笔记</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Angular%E5%85%A5%E9%97%A8"><span class="toc-text">1-Angular入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-text">1.1-开发环境的搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">1.2-新建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-text">1.3-常见命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99"><span class="toc-text">1.4-参考网站</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Angular%E5%9F%BA%E7%A1%80"><span class="toc-text">2-Angular基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-text">2.1-架构概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.2-基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%A8%A1%E5%9D%97"><span class="toc-text">2.2.1-模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E7%BB%84%E4%BB%B6"><span class="toc-text">2.2.2-组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%A8%A1%E6%9D%BF%E3%80%81%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">2.2.3-模板、指令和数据绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">2.2.4-服务与依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E8%B7%AF%E7%94%B1"><span class="toc-text">2.2.5-路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%A8%A1%E5%9D%97NgModule"><span class="toc-text">2.3-模块NgModule</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BB%84%E4%BB%B6"><span class="toc-text">2.4-组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">2.5-服务与依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E5%B7%A7"><span class="toc-text">2.6-工具与技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">响应式编程工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92%E5%B7%A5%E5%85%B7"><span class="toc-text">客户端与服务器的交互工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%93"><span class="toc-text">特定领域的库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%BC%80%E5%8F%91%E5%91%A8%E6%9C%9F%E6%8F%90%E4%BE%9B%E6%94%AF%E6%8C%81"><span class="toc-text">为开发周期提供支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%81%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE"><span class="toc-text">环境搭建、构建与开发配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="toc-text">3-组件与模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="toc-text">3.1-显示数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">3.2-模板语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-text">3.3-用户输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-text">3.4-生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-text">3.5-组件之间的交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%AE%A1%E9%81%93"><span class="toc-text">3.6-管道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%A1%A8%E5%8D%95"><span class="toc-text">4-表单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%A1%A8%E5%8D%95%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1-表单简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%93%8D%E5%BA%94%E5%BC%8F%E8%A1%A8%E5%8D%95"><span class="toc-text">4.2-响应式表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%A8%A1%E6%9D%BF%E9%A9%B1%E5%8A%A8%E8%A1%A8%E5%8D%95"><span class="toc-text">4.3-模板驱动表单</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Observable%E5%92%8CRxJS"><span class="toc-text">5-Observable和RxJS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%AF%B9%E8%B1%A1%EF%BC%88Observable%EF%BC%89"><span class="toc-text">5.1-可观察对象（Observable）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-RxJS%E5%BA%93"><span class="toc-text">5.2-RxJS库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Angular%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.3-Angular中的可观察对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-NgModule"><span class="toc-text">6-NgModule</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">6.1-启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">6.2-常用模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">7-依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8C%E5%8F%AF%E6%B3%A8%E5%85%A5%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-text">7.1-创建和注册可注入的服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98"><span class="toc-text">7.2-依赖注入实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-HttpClient"><span class="toc-text">8-HttpClient</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E8%8E%B7%E5%8F%96json%E6%95%B0%E6%8D%AE"><span class="toc-text">8.1-获取json数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82"><span class="toc-text">8.2-发起http请求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%AF%BC%E8%88%AA"><span class="toc-text">9-路由与导航</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E9%85%8D%E7%BD%AE"><span class="toc-text">9.1-配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E8%B7%AF%E7%94%B1%E5%87%BA%E5%8F%A3"><span class="toc-text">9.2-路由出口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E8%B7%AF%E7%94%B1%E9%93%BE%E6%8E%A5"><span class="toc-text">9.3-路由链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://static01.imgkr.com/temp/953b596e44e34fd69bd8b7f88dc1b5f1.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2021/12/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2021-12-03T14:09:50.000Z" title="发表于 2021-12-03 22:09:50">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/16/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB"><img src="https://static01.imgkr.com/temp/67e21ea4f0cb464cb52de4d60aad3962.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go操作MongoDB"></a><div class="content"><a class="title" href="/2021/11/16/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB">Go操作MongoDB</a><time datetime="2021-11-16T14:09:50.000Z" title="发表于 2021-11-16 22:09:50">2021-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/24/Netty%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Netty入门学习笔记"><img src="https://s3.bmp.ovh/imgs/2021/12/7f02b700ddd8d712.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Netty入门学习笔记"></a><div class="content"><a class="title" href="/2020/06/24/Netty%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Netty入门学习笔记">Netty入门学习笔记</a><time datetime="2020-06-24T06:31:42.000Z" title="发表于 2020-06-24 14:31:42">2020-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BD%8D%E5%9B%BE/" title="布隆过滤器和位图"><img src="/./images/wolf.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="布隆过滤器和位图"></a><div class="content"><a class="title" href="/2020/06/07/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BD%8D%E5%9B%BE/" title="布隆过滤器和位图">布隆过滤器和位图</a><time datetime="2020-06-07T13:20:01.000Z" title="发表于 2020-06-07 21:20:01">2020-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/05/20/%E5%88%86%E5%B8%83%E5%BC%8FSession%E5%92%8C%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" title="分布式Session和单点登录"><img src="https://s3.bmp.ovh/imgs/2022/01/759f29a6471f2f3b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="分布式Session和单点登录"></a><div class="content"><a class="title" href="/2020/05/20/%E5%88%86%E5%B8%83%E5%BC%8FSession%E5%92%8C%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" title="分布式Session和单点登录">分布式Session和单点登录</a><time datetime="2020-05-20T14:25:10.000Z" title="发表于 2020-05-20 22:25:10">2020-05-20</time></div></div></div></div></div></div><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>