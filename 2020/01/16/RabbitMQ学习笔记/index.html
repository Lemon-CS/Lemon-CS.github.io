<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RabbitMQ学习笔记 | Lemon-CS</title><meta name="keywords" content="RabbitMQ"><meta name="author" content="空白格"><meta name="copyright" content="空白格"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RabbitMQ入门学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ学习笔记"><meta property="og:url" content="https://lemon-cs.github.io/2020/01/16/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="Lemon-CS"><meta property="og:description" content="RabbitMQ入门学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg"><meta property="article:published_time" content="2020-01-16T14:09:50.000Z"><meta property="article:modified_time" content="2020-01-19T03:37:35.000Z"><meta property="article:author" content="空白格"><meta property="article:tag" content="消息队列"><meta property="article:tag" content="RabbitMQ"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg"><link rel="shortcut icon" href="https://gitee.com/lemon-cs/images/raw/master/Blog.png"><link rel="canonical" href="https://lemon-cs.github.io/2020/01/16/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 空白格",link:"链接: ",source:"来源: Lemon-CS",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"RabbitMQ学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-01-19 11:37:35"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const d=saveToLocal.get("global-font-size");void 0!==d&&document.documentElement.style.setProperty("--global-font-size",d+"px");const r=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};r(),document.addEventListener("pjax:complete",r)})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lemon-CS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-01-16T14:09:50.000Z" title="发表于 2020-01-16 22:09:50">2020-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-01-19T03:37:35.000Z" title="更新于 2020-01-19 11:37:35">2020-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="RabbitMQ学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RabbitMQ学习笔记"><a href="#RabbitMQ学习笔记" class="headerlink" title="RabbitMQ学习笔记"></a>RabbitMQ学习笔记</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1-简介"></a>1-简介</h2><p>RabbitMQ是最受欢迎的开源消息中间件之一，在全球范围内被广泛应用。RabbitMQ是轻量级且易于部署的，能支持多种消息协议。RabbitMQ可以部署在分布式系统中，以满足大规模、高可用的要求。</p><h3 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1-相关概念"></a>1.1-相关概念</h3><p>我们先来了解下RabbitMQ中的相关概念，这里以5种消息模式中的<code>路由模式</code>为例。<br><img src="https://gitee.com/lemon-cs/images/raw/master/RabbitMQ.png"></p><h3 id="1-2-RabbitMQ的安装和配置"><a href="#1-2-RabbitMQ的安装和配置" class="headerlink" title="1.2-RabbitMQ的安装和配置"></a>1.2-RabbitMQ的安装和配置</h3><p>我们在Docker中安装RabbitMQ</p><ul><li>下载<code>rabbitmq 3.7.15</code>的Docker镜像；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.15</span><br></pre></td></tr></table></figure><ul><li>使用Docker命令启动服务；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 5672:5672 -p 15672:15672 --name rabbitmq \</span><br><span class="line">-d rabbitmq:3.7.15</span><br></pre></td></tr></table></figure><ul><li>进入容器并开启管理功能；</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it rabbitmq /bin/bash</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><ul><li>开启防火墙便于外网访问。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><ul><li><p>访问RabbitMQ管理页面地址，查看是否安装成功（Linux下使用服务器IP访问即可）：<code>http://localhost:15672/</code></p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%AE%BF%E9%97%AERabbitMQ.png"></p></li><li><p>输入账号密码并登录，这里使用默认账号密码登录：guest guest</p></li><li><p>创建帐号并设置其角色为管理员：mall mall</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7.png"></p></li><li><p>创建一个新的虚拟host为：/mall</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9Fhost.png"></p></li><li><p>点击mall用户进入用户配置页面；</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE.png"></p></li><li><p>给mall用户配置该虚拟host的权限；</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9Fhost%E6%9D%83%E9%99%90.png"></p></li><li><p>至此，RabbitMQ的配置完成。</p></li></ul><h3 id="1-3-AMQP协议"><a href="#1-3-AMQP协议" class="headerlink" title="1.3-AMQP协议"></a>1.3-AMQP协议</h3><p><strong>核心概念</strong></p><ol><li>server：又称broker，接受客户端连接，实现AMQP实体服务。</li><li>connection：连接和具体broker网络连接。</li><li>channel：网络信道，几乎所有操作都在channel中进行，channel是消息读写的通道。客户端可以建立多个channel，每个channel表示一个会话任务。</li><li>message：消息，服务器和应用程序之间传递的数据，由properties和body组成。properties可以对消息进行修饰，比如消息的优先级，延迟等高级特性；body是消息实体内容。</li><li>Virtual host：虚拟主机，用于逻辑隔离，最上层消息的路由。一个Virtual host可以若干个Exchange和Queue，同一个Virtual host不能有同名的Exchange或Queue。</li><li>Exchange：交换机，接受消息，根据路由键转发消息到绑定的队列上。</li><li>banding：Exchange和Queue之间的虚拟连接，binding中可以包括routing key</li><li>routing key：一个路由规则，虚拟机根据他来确定如何路由 一条消息。</li><li>Queue：消息队列，用来存放消息的队列。</li></ol><h3 id="1-4-Exchange"><a href="#1-4-Exchange" class="headerlink" title="1.4-Exchange"></a>1.4-Exchange</h3><p><img src="https://gitee.com/lemon-cs/images/raw/master/Exchange.png"></p><p>交换机的类型，direct、topic、fanout、headers，durability（是否需要持久化true需要）auto delete当最后一个绑定Exchange上的队列被删除Exchange也删除。</p><ol><li>Direct Exchange,所有发送到Direct Exchange的消息被转发到RouteKey 中指定的Queue,Direct Exchange可以使用默认的默认的Exchange （default Exchange），默认的Exchange会绑定所有的队列，所以Direct可以直接使用Queue名（作为routing key ）绑定。或者消费者和生产者的routing key完全匹配。</li><li>Toptic Exchange,是指发送到Topic Exchange的消息被转发到所有关心的Routing key中指定topic的Queue上。Exchange 将routing key和某Topic进行模糊匹配，此时队列需要绑定一个topic。所谓模糊匹配就是可以使用通配符，“#”可以匹配一个或多个词，“”只匹配一个词比如“log.#”可以匹配“log.info.test” “log. “就只能匹配log.error。</li><li>Fanout Exchange:不处理路由键，只需简单的将队列绑定到交换机上。发送到改交换机上的消息都会被发送到与该交换机绑定的队列上。Fanout转发是最快的。</li></ol><h3 id="1-5-消息队列解决了什么问题"><a href="#1-5-消息队列解决了什么问题" class="headerlink" title="1.5-消息队列解决了什么问题?"></a>1.5-消息队列解决了什么问题?</h3><ul><li>异步处理</li><li>应用解耦</li><li>流量削锋</li><li>日志处理</li><li>……</li></ul><h2 id="2-5种消息模式"><a href="#2-5种消息模式" class="headerlink" title="2-5种消息模式"></a>2-5种消息模式</h2><h3 id="2-1-简单模式"><a href="#2-1-简单模式" class="headerlink" title="2.1-简单模式"></a>2.1-简单模式</h3><blockquote><p>简单模式是最简单的消息模式，它包含一个生产者、一个消费者和一个队列。生产者向队列里发送消息，消费者从队列中获取消息并消费。</p></blockquote><h4 id="1-模式示意图"><a href="#1-模式示意图" class="headerlink" title="1. 模式示意图"></a>1. 模式示意图</h4><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F.png"></p><ul><li>P：消息生产者</li><li>红色：队列</li><li>C：消息消费者</li></ul><p>包含三个对象：生产者、队列、消费者</p><h4 id="2-Java实现"><a href="#2-Java实现" class="headerlink" title="2. Java实现"></a>2. Java实现</h4><ul><li><h5 id="获取mq连接"><a href="#获取mq连接" class="headerlink" title="获取mq连接"></a>获取mq连接</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取MQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">//AMQP的端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/vhost_mmr&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;rabbit&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_simple_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从连接中获取一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---send msg :&quot;</span> + msg);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_simple_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;msg receive : &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Spring-AMQP实现"><a href="#3-Spring-AMQP实现" class="headerlink" title="3. Spring AMQP实现"></a>3. Spring AMQP实现</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>: <span class="string">5672</span></span><br><span class="line"><span class="meta">virtual-host</span>: <span class="string">/mall</span></span><br><span class="line"><span class="attr">username</span>: <span class="string">mall</span></span><br><span class="line"><span class="attr">password</span>: <span class="string">mall</span></span><br><span class="line"><span class="meta">publisher-confirms</span>: <span class="string">true #消息发送到交换器确认</span></span><br><span class="line"><span class="meta">publisher-returns</span>: <span class="string">true #消息发送到队列确认</span></span><br></pre></td></tr></table></figure><ul><li>添加<code>简单模式</code>相关Java配置，创建一个名为<code>simple.hello</code>的队列、一个生产者和一个消费者；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Queue <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;simple.hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SimpleSender <span class="title">simpleSender</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SimpleSender();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SimpleReceiver <span class="title">simpleReceiver</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SimpleReceiver();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者通过<code>send方法</code>向队列<code>simple.hello</code>中发送消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleSender.class);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">&quot;simple.hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>.template.convertAndSend(queueName, message);</span><br><span class="line">  LOGGER.info(<span class="string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者从队列<code>simple.hello</code>中获取消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SimpleReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在controller中添加测试接口，调用该接口开始发送消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ功能测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rabbit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SimpleSender simpleSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;简单模式&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/simple&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">simpleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            simpleSender.send();</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-简单模式的不足"><a href="#4-简单模式的不足" class="headerlink" title="4. 简单模式的不足"></a>4. 简单模式的不足</h4><ul><li>耦合性高，生产者一一对应消费者，如果需要多个消费者消费队列中的消息，此时简单队列就无能为力了；</li><li>队列名变更，源码需要同时变更。</li></ul><h3 id="2-2-工作模式"><a href="#2-2-工作模式" class="headerlink" title="2.2-工作模式"></a>2.2-工作模式</h3><blockquote><p>工作模式是指向多个互相竞争的消费者发送消息的模式，它包含一个生产者、两个消费者和一个队列。两个消费者同时绑定到一个队列上去，当消费者获取消息处理耗时任务时，空闲的消费者从队列中获取并消费消息。</p></blockquote><h4 id="1-模式示意图-1"><a href="#1-模式示意图-1" class="headerlink" title="1. 模式示意图"></a>1. 模式示意图</h4><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png"></p><p>一个生产者将消息放入队列中，可以有多个消费者进行消费</p><p><strong>为什么会出现工作队列？</strong></p><p>Simple队列：是一一对应的，实际开发中，生产者改善消息是毫不费力的，而消费者一般需要跟业务相结合，消费者接收到消息之后就需要处理，可能需要花费时间，此时队列就会积压很多消息。</p><h4 id="2-Java实现-1"><a href="#2-Java实现-1" class="headerlink" title="2. Java实现"></a>2. Java实现</h4><h5 id="（1）-轮询分发"><a href="#（1）-轮询分发" class="headerlink" title="（1） 轮询分发"></a>（1） 轮询分发</h5><ul><li><p>生产消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从连接中获取一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;hello &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;---send msg :&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[1] msg recv1 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">true</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[2] msg recv1 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">true</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>现象</strong>：</p><p>消费者1和消费者2处理的消息是一样多的，这种分发方式称为轮询分发（round-robin），不管谁忙或者谁闲，都不会多给或者少给。任务均分。</p></li></ul><h5 id="（2）公平分发-fair-dispatch"><a href="#（2）公平分发-fair-dispatch" class="headerlink" title="（2）公平分发 fair dispatch"></a>（2）公平分发 fair dispatch</h5><p>保证一次发送给消费者的消息不超过一条</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个消费者发送确认消息之前，消息队列不发送下一个消息给消费者，消费者一次只处理一个消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 限制发送给同一个消费者不得超过一条消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> preFetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(preFetchCount);</span><br></pre></td></tr></table></figure><p>使用公平分发，必须关闭自动应答ack，改为手动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br></pre></td></tr></table></figure><ul><li><p><strong>生产消息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从连接中获取一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每个消费者发送确认消息之前，消息队列不发送下一个消息给消费者，消费者一次只处理一个消息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 限制发送给同一个消费者不得超过一条消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> preFetchCount = <span class="number">1</span>;</span><br><span class="line">        channel.basicQos(preFetchCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;hello &quot;</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;---send msg :&quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_work_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[2] msg recv1 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-消息应答与消息持久化"><a href="#3-消息应答与消息持久化" class="headerlink" title="3. 消息应答与消息持久化"></a>3. 消息应答与消息持久化</h4><ul><li><h5 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br></pre></td></tr></table></figure><p>ack = true时为自动确认模式，一旦rabbitMQ将消息分发给消费者，该消息就会在内存中删除；这种情况下，如果杀死正在处理消息的消费者，会丢失正在处理的消息；</p><p>ack = false时为手动回执（消息应答）模式，如果有一个消费者挂掉，就会将会给其他消费者，rabbitMQ支持消息应答，消费者发送一个消息应答，告诉rabbitMQ这个消息已经被处理，然后rabbitMQ就删除内存中的消息；</p><p>消息应答默认打开，即为false；</p><p>由于消息在内存中存储，如果rabbitMQ挂掉，消息仍然会丢失。</p></li><li><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">false</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>durable控制的属性就是消息的持久化。</p><p>已经声明好的队列，如果durable已经为false了，就无法修改为true，rabbitMQ不允许重新定义（不同参数）一个已存在的队列</p></li></ul><h4 id="4-Spring-AMQP实现"><a href="#4-Spring-AMQP实现" class="headerlink" title="4. Spring AMQP实现"></a>4. Spring AMQP实现</h4><ul><li>添加<code>工作模式</code>相关Java配置，创建一个名为<code>work.hello</code>的队列、一个生产者和两个消费者；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">workQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;work.hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WorkReceiver <span class="title">workReceiver1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WorkReceiver(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WorkReceiver <span class="title">workReceiver2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WorkReceiver(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WorkSender <span class="title">workSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WorkSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者通过<code>send方法</code>向队列<code>work.hello</code>中发送消息，消息中包含一定数量的<code>.</code>号；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WorkSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName = <span class="string">&quot;work.hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limitIndex = index % <span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limitIndex; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(index+<span class="number">1</span>);</span><br><span class="line">        String message = builder.toString();</span><br><span class="line">        template.convertAndSend(queueName, message);</span><br><span class="line">        LOGGER.info(<span class="string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两个消费者从队列<code>work.hello</code>中获取消息，名称分别为<code>instance 1</code>和<code>instance 2</code>，消息中包含<code>.</code>号越多，耗时越长；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WorkReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkReceiver</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, <span class="keyword">this</span>.instance, in);</span><br><span class="line">        doWork(in);</span><br><span class="line">        watch.stop();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Done in &#123;&#125;s&quot;</span>, <span class="keyword">this</span>.instance, watch.getTotalTimeSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在controller中添加测试接口，调用该接口开始发送消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ功能测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rabbit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WorkSender workSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;工作模式&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/work&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">workTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            workSender.send(i);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行后结果可以发现生产者往队列中发送包含不同数量<code>.</code>号的消息，<code>instance 1</code>和<code>instance 2</code>消费者互相竞争，分别消费了一部分消息。</li></ul><h3 id="2-3-发布-订阅模式"><a href="#2-3-发布-订阅模式" class="headerlink" title="2.3-发布/订阅模式"></a>2.3-发布/订阅模式</h3><blockquote><p>发布/订阅模式是指同时向多个消费者发送消息的模式（类似广播的形式），它包含一个生产者、两个消费者、两个队列和一个交换机。两个消费者同时绑定到不同的队列上去，两个队列绑定到交换机上去，生产者通过发送消息到交换机，所有消费者接收并消费消息。</p></blockquote><h4 id="1-模式示意图-2"><a href="#1-模式示意图-2" class="headerlink" title="1. 模式示意图"></a>1. 模式示意图</h4><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png"></p><ul><li>一个生产者，多个消费者；</li><li>每个消费者都有自己的队列；</li><li>生产者没有直接把消息发送到队列，而是发送至交换机(eXchange)</li><li>每个队列都要绑定到交换机上</li><li>生产者发送的消息，经过交换机，到达队列，就能实现一个消息被多个消费者消费</li></ul><h4 id="2-Java实现-2"><a href="#2-Java实现-2" class="headerlink" title="2. Java实现"></a>2. Java实现</h4><ul><li><p><strong>生产消息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_fanout&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;hello ps&quot;</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;Send &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>消费消息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_ps_fanout_email&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_fanout&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[1] msg recv1 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的队列做不同的事情。</p></li></ul><h4 id="3-Spring-AMQP实现-1"><a href="#3-Spring-AMQP实现-1" class="headerlink" title="3. Spring AMQP实现"></a>3. Spring AMQP实现</h4><ul><li>添加<code>发布/订阅模式</code>相关Java配置，创建一个名为<code>exchange.fanout</code>的交换机、一个生产者、两个消费者和两个匿名队列，将两个匿名队列都绑定到交换机；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;exchange.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBinding1</span><span class="params">(FanoutExchange fanout, Queue fanoutQueue1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBinding2</span><span class="params">(FanoutExchange fanout, Queue fanoutQueue2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutReceiver <span class="title">fanoutReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutReceiver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutSender <span class="title">fanoutSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者通过<code>send方法</code>向交换机<code>exchange.fanout</code>中发送消息，消息中包含一定数量的<code>.</code>号；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FanoutSender.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String exchangeName = <span class="string">&quot;exchange.fanout&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limitIndex = index % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limitIndex; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(index + <span class="number">1</span>);</span><br><span class="line">        String message = builder.toString();</span><br><span class="line">        template.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">        LOGGER.info(<span class="string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者从绑定的匿名队列中获取消息，消息中包含<code>.</code>号越多，耗时越长，由于该消费者可以从两个队列中获取并消费消息，可以看做两个消费者，名称分别为<code>instance 1</code>和<code>instance 2</code>；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(FanoutReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;#&#123;fanoutQueue1.name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">        receive(in, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;#&#123;fanoutQueue2.name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">        receive(in, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String in, <span class="keyword">int</span> receiver)</span> </span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, receiver, in);</span><br><span class="line">        doWork(in);</span><br><span class="line">        watch.stop();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Done in &#123;&#125;s&quot;</span>, receiver, watch.getTotalTimeSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在controller中添加测试接口，调用该接口开始发送消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ功能测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rabbit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FanoutSender fanoutSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;发布/订阅模式&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/fanout&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">fanoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            fanoutSender.send(i);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行后结果可以发现生产者往队列中发送包含不同数量<code>.</code>号的消息，<code>instance 1</code>和<code>instance 2</code>同时获取并消费了消息。</li></ul><h3 id="2-4-路由模式"><a href="#2-4-路由模式" class="headerlink" title="2.4-路由模式"></a>2.4-路由模式</h3><blockquote><p>路由模式是可以根据<code>路由键</code>选择性给多个消费者发送消息的模式，它包含一个生产者、两个消费者、两个队列和一个交换机。两个消费者同时绑定到不同的队列上去，两个队列通过<code>路由键</code>绑定到交换机上去，生产者发送消息到交换机，交换机通过<code>路由键</code>转发到不同队列，队列绑定的消费者接收并消费消息。</p></blockquote><h4 id="1-模式示意图-3"><a href="#1-模式示意图-3" class="headerlink" title="1. 模式示意图"></a>1. 模式示意图</h4><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F.png"></p><ul><li>声明exchange时指定为direct模式</li><li>绑定队列时，指定路由键</li></ul><h4 id="2-Java实现-3"><a href="#2-Java实现-3" class="headerlink" title="2. Java实现"></a>2. Java实现</h4><ul><li><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_direct&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明exchange</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;hello direct&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定路由键</span></span><br><span class="line">        String routingKey = <span class="string">&quot;warning&quot;</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;send msg:&quot;</span> + msg);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_direct&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_queue_direct&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定队列与交换机时，指定路由键</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[1] msg recv1 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_direct&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_queue_direct_2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定队列与交换机时，指定路由键</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[2] msg recv2 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Spring-AMQP实现-2"><a href="#3-Spring-AMQP实现-2" class="headerlink" title="3. Spring AMQP实现"></a>3. Spring AMQP实现</h4><ul><li>添加<code>路由模式</code>相关Java配置，创建一个名为<code>exchange.direct</code>的交换机、一个生产者、两个消费者和两个匿名队列，队列通过<code>路由键</code>都绑定到交换机，<code>队列1</code>的路由键为<code>orange</code>和<code>black</code>，<code>队列2</code>的路由键为<code>green</code>和<code>black</code>；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;exchange.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directBinding1a</span><span class="params">(DirectExchange direct, Queue directQueue1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(direct).with(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directBinding1b</span><span class="params">(DirectExchange direct, Queue directQueue1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(direct).with(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directBinding2a</span><span class="params">(DirectExchange direct, Queue directQueue2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(direct).with(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">directBinding2b</span><span class="params">(DirectExchange direct, Queue directQueue2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(direct).with(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectReceiver <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectReceiver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectSender <span class="title">directSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者通过<code>send方法</code>向交换机<code>exchange.direct</code>中发送消息，发送时使用不同的<code>路由键</code>，根据<code>路由键</code>会被转发到不同的队列；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String exchangeName = <span class="string">&quot;exchange.direct&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String[] keys = &#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;green&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DirectSender.class);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello to &quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> limitIndex = index % <span class="number">3</span>;</span><br><span class="line">  String key = keys[limitIndex];</span><br><span class="line">  builder.append(key).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  builder.append(index+<span class="number">1</span>);</span><br><span class="line">  String message = builder.toString();</span><br><span class="line">  template.convertAndSend(exchangeName, key, message);</span><br><span class="line">  LOGGER.info(<span class="string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者从自己绑定的匿名队列中获取消息，由于该消费者可以从两个队列中获取并消费消息，可以看做两个消费者，名称分别为<code>instance 1</code>和<code>instance 2</code>；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(DirectReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;#&#123;directQueue1.name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">        receive(in, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;#&#123;directQueue2.name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">        receive(in, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String in, <span class="keyword">int</span> receiver)</span></span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, receiver, in);</span><br><span class="line">        doWork(in);</span><br><span class="line">        watch.stop();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Done in &#123;&#125;s&quot;</span>, receiver, watch.getTotalTimeSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在controller中添加测试接口，调用该接口开始发送消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ功能测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rabbit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DirectSender directSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;路由模式&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/direct&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">directTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            directSender.send(i);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行后结果中可以发现生产者往队列中发送包含不同<code>路由键</code>的消息，<code>instance 1</code>获取到了<code>orange</code>和<code>black</code>消息，<code>instance 2</code>获取到了<code>green</code>和<code>black</code>消息。</li></ul><h3 id="2-5-Topic模式"><a href="#2-5-Topic模式" class="headerlink" title="2.5-Topic模式"></a>2.5-Topic模式</h3><blockquote><p>通配符模式是可以根据<code>路由键匹配规则</code>选择性给多个消费者发送消息的模式，它包含一个生产者、两个消费者、两个队列和一个交换机。两个消费者同时绑定到不同的队列上去，两个队列通过<code>路由键匹配规则</code>绑定到交换机上去，生产者发送消息到交换机，交换机通过<code>路由键匹配规则</code>转发到不同队列，队列绑定的消费者接收并消费消息。</p></blockquote><h4 id="1-模式示意图-4"><a href="#1-模式示意图-4" class="headerlink" title="1. 模式示意图"></a>1. 模式示意图</h4><p><img src="https://gitee.com/lemon-cs/images/raw/master/Topic%E6%A8%A1%E5%BC%8F.png"></p><ul><li><code>*</code>：只能匹配一个单词；</li><li><code>#</code>：可以匹配零个或多个单词。</li></ul><h4 id="2-Java实现-4"><a href="#2-Java实现-4" class="headerlink" title="2. Java实现"></a>2. Java实现</h4><ul><li><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明exchange,指定模式为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;商品....&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String routingKey = <span class="string">&quot;goods.delete&quot;</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;send msg:&quot;</span> + msg);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wangbin on 2018/6/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_topic&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_queue_topic_1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;goods.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[1] msg recv1 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mq.simple.utils.ConnectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by wangbin on 2018/6/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;test_exchange_topic&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;test_queue_topic_2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">&quot;goods.add&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[2] msg recv2 : &quot;</span> + msg);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">false</span>;<span class="comment">//自动应答改为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, ack, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，消费者1绑定路由键为<code>goods.#</code>，消费者2绑定路由键为<code>goods.add</code>。当生产者发送的消息路由键为<code>goods.add</code>时，两个消费者都会收到消息并处理；当生产者发送的消息路由键为<code>goods.update</code>时，只有消费者1可以接收到消息。</p></li></ul><h4 id="3-Spring-AMQP实现-3"><a href="#3-Spring-AMQP实现-3" class="headerlink" title="3. Spring AMQP实现"></a>3. Spring AMQP实现</h4><ul><li>添加<code>通配符模式</code>相关Java配置，创建一个名为<code>exchange.topic</code>的交换机、一个生产者、两个消费者和两个匿名队列，匹配<code>*.orange.*</code>和<code>*.*.rabbit</code>发送到<code>队列1</code>，匹配<code>lazy.#</code>发送到<code>队列2</code>；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">&quot;exchange.topic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnonymousQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1a</span><span class="params">(TopicExchange topic, Queue topicQueue1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue1).to(topic).with(<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1b</span><span class="params">(TopicExchange topic, Queue topicQueue1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue1).to(topic).with(<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding2a</span><span class="params">(TopicExchange topic, Queue topicQueue2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue2).to(topic).with(<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicReceiver <span class="title">topicReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicReceiver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicSender <span class="title">topicSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者通过<code>send方法</code>向交换机<code>exchange.topic</code>中发送消息，消息中包含不同的<code>路由键</code>；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String exchangeName = <span class="string">&quot;exchange.topic&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TopicSender.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String[] keys = &#123;<span class="string">&quot;quick.orange.rabbit&quot;</span>, <span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;quick.orange.fox&quot;</span>,</span><br><span class="line">   <span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;quick.brown.fox&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello to &quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> limitIndex = index%keys.length;</span><br><span class="line">  String key = keys[limitIndex];</span><br><span class="line">  builder.append(key).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  builder.append(index+<span class="number">1</span>);</span><br><span class="line">  String message = builder.toString();</span><br><span class="line">  template.convertAndSend(exchangeName, key, message);</span><br><span class="line">  LOGGER.info(<span class="string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>,message);</span><br><span class="line">  System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者从自己绑定的匿名队列中获取消息，由于该消费者可以从两个队列中获取并消费消息，可以看做两个消费者，名称分别为<code>instance 1</code>和<code>instance 2</code>；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TopicReceiver.class);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RabbitListener(queues = &quot;#&#123;topicQueue1.name&#125;&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">  receive(in, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RabbitListener(queues = &quot;#&#123;topicQueue2.name&#125;&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">  receive(in, <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String in, <span class="keyword">int</span> receiver)</span></span>&#123;</span><br><span class="line">  StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  watch.start();</span><br><span class="line">  LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, receiver, in);</span><br><span class="line">  doWork(in);</span><br><span class="line">  watch.stop();</span><br><span class="line">  LOGGER.info(<span class="string">&quot;instance &#123;&#125; [x] Done in &#123;&#125;s&quot;</span>, receiver, watch.getTotalTimeSeconds());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在controller中添加测试接口，调用该接口开始发送消息；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by macro on 2020/5/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;RabbitController&quot;, description = &quot;RabbitMQ功能测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/rabbit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopicSender topicSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;通配符模式&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/topic&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">topicTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            topicSender.send(i);</span><br><span class="line">            ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行后结果中可以发现生产者往队列中发送包含不同<code>路由键</code>的消息，<code>instance 1</code>和<code>instance 2</code>分别获取到了匹配的消息。</li></ul><h2 id="3-消息Ack确认机制"><a href="#3-消息Ack确认机制" class="headerlink" title="3-消息Ack确认机制"></a>3-消息Ack确认机制</h2><p>RabbitMQ的消息确认有两种。</p><ul><li><strong>消息发送确认</strong>：这种是用来确认生产者将消息发送给交换器，交换器传递给队列的过程中，消息是否成功投递。发送确认分为两步，一是确认是否到达交换器，二是确认是否到达队列。</li><li><strong>消费接收确认</strong>。这种是确认消费者是否成功消费了队列中的消息。</li></ul><h3 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1-环境配置"></a>3.1-环境配置</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">rabbitmq</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8084</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h4 id="3-配置类"><a href="#3-配置类" class="headerlink" title="3. 配置类"></a>3. 配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_A = <span class="string">&quot;confirm_queue_A&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_B = <span class="string">&quot;confirm_queue_B&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE = <span class="string">&quot;confirm_topic_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_A_RoutingKey=<span class="string">&quot;topic.message&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_B_RoutingKey=<span class="string">&quot;topic.#&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Json格式转换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageConverter jsonMessageConverter=<span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试队列A</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueryA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(CONFIRM_QUEUE_A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试队列B</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueryB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(CONFIRM_QUEUE_B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试交换机,类型为topic</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">confirmTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(CONFIRM_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定测试交换机和测试队列A</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingConfirmExchangeA</span><span class="params">(Queue confirmQueryA, TopicExchange confirmTopicExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueryA).to(confirmTopicExchange).with(CONFIRM_QUEUE_A_RoutingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定测试交换机和测试队列B</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingConfirmExchangeB</span><span class="params">(Queue confirmQueryB, TopicExchange confirmTopicExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueryB).to(confirmTopicExchange).with(CONFIRM_QUEUE_B_RoutingKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-消息发送确认"><a href="#3-2-消息发送确认" class="headerlink" title="3.2-消息发送确认"></a>3.2-消息发送确认</h3><h4 id="1-ConfirmCallback"><a href="#1-ConfirmCallback" class="headerlink" title="1. ConfirmCallback"></a>1. <strong>ConfirmCallback</strong></h4><p>通过实现ConfirmCallBack接口，消息发送到交换器<strong>Exchange</strong>后触发回调。</p><p>消息的确认，指生产者收到投递消息后，如果Broker收到消息就会给我们 的生产者一个应答，生产者接受应答来确认broker是否收到消息。</p><ul><li><p>ConfirmCallBackHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过实现ConfirmCallBack接口，消息发送到交换器Exchange后触发回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallBackHandler</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息唯一标识：&quot;</span>+correlationData);</span><br><span class="line">        System.out.println(<span class="string">&quot;确认结果：&quot;</span>+ack);</span><br><span class="line">        System.out.println(<span class="string">&quot;失败原因：&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在RabbitConfig中配置RabbitTempalte</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化加载方法，对RabbitTemplate进行配置</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//消息发送确认，发送到交换器Exchange后触发回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> ConfirmCallBackHandler());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>该功能需要开启确认，spring-boot中配置如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#消息发送交换机确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-ReturnCallback"><a href="#2-ReturnCallback" class="headerlink" title="2. ReturnCallback"></a>2. <strong>ReturnCallback</strong></h4><p>通过实现ReturnCallback接口，如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）。</p><p>Return消息机制处理一些不可路由的消息，我们的生产者通过指定一个Exchange和Routinkey，把消息送达到某一个队列中去，然后我们消费者监听队列进行消费处理！</p><p>在某些情况下，如果我们在发送消息的时候当Exchange不存在或者指定的路由key路由找不到，这个时候如果我们需要监听这种不可到达的消息，就要使用Return Listener！</p><p>Mandatory 设置为true则会监听器会接受到路由不可达的消息，然后处理。如果设置为false，broker将会自动删除该消息。</p><ul><li><p>ReturnCallBackHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过实现ReturnCallback接口</span></span><br><span class="line"><span class="comment">// 如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallBackHandler</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体 message：&quot;</span>+message);</span><br><span class="line">        System.out.println(<span class="string">&quot;应答码 replyCode: ：&quot;</span>+replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;原因描述 replyText：&quot;</span>+replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;交换机 exchange：&quot;</span>+exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由键 routingKey：&quot;</span>+routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在RabbitConfig中配置RabbitTempalte</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化加载方法，对RabbitTemplate进行配置</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rabbitTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//消息发送确认，发送到交换器Exchange后触发回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> ConfirmCallBackHandler());</span><br><span class="line">        <span class="comment">//消息发送确认，如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">new</span> ReturnCallBackHandler());</span><br><span class="line">        <span class="comment">//自定义格式转换</span></span><br><span class="line">        <span class="comment">//rabbitTemplate.setMessageConverter(jsonMessageConverter);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用该功能需要开启确认，spring-boot中配置如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#消息发送队列回调</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-定制化模板"><a href="#3-定制化模板" class="headerlink" title="3. 定制化模板"></a>3. 定制化模板</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制化amqp模版</span></span><br><span class="line"><span class="comment">     　　　* connectionFactory:包含了yml文件配置参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        <span class="comment">// 必须设置为 true，不然当 发送到交换器成功，但是没有匹配的队列，不会触发 ReturnCallback 回调</span></span><br><span class="line">        <span class="comment">// 而且 ReturnCallback 比 ConfirmCallback 先回调，意思就是 ReturnCallback 执行完了才会执行 ConfirmCallback</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置 ConfirmCallback 回调   yml需要配置 publisher-confirms: true</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果发送到交换器都没有成功（比如说删除了交换器），ack 返回值为 false</span></span><br><span class="line">            <span class="comment">// 如果发送到交换器成功，但是没有匹配的队列（比如说取消了绑定），ack 返回值为还是 true （这是一个坑，需要注意）</span></span><br><span class="line">            <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                String messageId = correlationData.getId();</span><br><span class="line">                System.out.println(<span class="string">&quot;confirm:&quot;</span>+messageId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 设置 ReturnCallback 回调   yml需要配置 publisher-returns: true</span></span><br><span class="line">        <span class="comment">// 如果发送到交换器成功，但是没有匹配的队列，就会触发这个回调</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText,</span><br><span class="line">                                          exchange, routingKey) -&gt; &#123;</span><br><span class="line">            String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">            System.out.println(<span class="string">&quot;return:&quot;</span>+messageId);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-消息接收确认"><a href="#3-3-消息接收确认" class="headerlink" title="3.3-消息接收确认"></a>3.3-消息接收确认</h3><h4 id="1-确认模式"><a href="#1-确认模式" class="headerlink" title="1.  确认模式"></a>1. 确认模式</h4><ul><li>AcknowledgeMode.NONE：不确认</li><li>AcknowledgeMode.AUTO：自动确认</li><li>AcknowledgeMode.MANUAL：手动确认</li></ul><p>spring-boot中配置方法：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span> = <span class="string">manual</span></span><br></pre></td></tr></table></figure><h4 id="2-手动确认"><a href="#2-手动确认" class="headerlink" title="2. 手动确认"></a>2. 手动确认</h4><ul><li><p>成功确认</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li><p>deliveryTag：该消息的index</p></li><li><p>multiple：是否批量. true：将一次性ack所有小于deliveryTag的消息。</p></li></ul><p>消费者成功处理后，调用channel.basicAck(message.getMessageProperties().getDeliveryTag(), false)方法对消息进行确认。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_queue_B&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message, Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ReceiverA：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>失败确认</p><ol><li><p>失败确认1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>deliveryTag：该消息的index。</li><li>multiple：是否批量. true：将一次性拒绝所有小于deliveryTag的消息。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_queue_B&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processJsonMessage</span><span class="params">(<span class="meta">@Payload</span> String body, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> deliveryTag, Message message,Channel channel)</span></span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;ReceiverA：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicNack(deliveryTag,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>失败确认2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>deliveryTag：该消息的index。</li><li>requeue：被拒绝的是否重新入队列。</li></ul><p><code>channel.basicNack</code> 与 <code>channel.basicReject</code> 的区别在于<code>basicNack</code>可以批量拒绝多条消息，而<code>basicReject</code>一次只能拒绝一条消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_queue_B&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processJsonMessage</span><span class="params">(<span class="meta">@Payload</span> String body, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> deliveryTag, Message message,Channel channel)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;ReceiverA：&quot;</span>+<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicReject(deliveryTag,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="3-思考"><a href="#3-思考" class="headerlink" title="3. 思考"></a>3. 思考</h4><ul><li><p>手动确认模式，消息手动拒绝中如果requeue为true会重新放入队列，但是如果消费者在处理过程中一直抛出异常，会导致入队-》拒绝-》入队的循环，该怎么处理呢？</p><blockquote><ol><li>根据异常类型来选择是否重新放入队列；</li><li>先成功确认，然后通过**channel.basicPublish()**重新发布这个消息。重新发布的消息网上说会放到队列后面，进而不会影响已经进入队列的消息处理。</li></ol></blockquote></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, <span class="keyword">boolean</span> immediate, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li><p>消息确认的作用是什么？</p><p>为了防止消息丢失。消息丢失分为发送丢失和消费者处理丢失，相应的也有两种确认机制。</p></li><li><p>处理模板案例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;confirm_queue_B&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AckTempalte</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Action</span></span>&#123;</span><br><span class="line">        ACCEPT, <span class="comment">// 处理成功</span></span><br><span class="line">        RETRY, <span class="comment">// 可以重试的错误</span></span><br><span class="line">        REJECT, <span class="comment">// 无需重试的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processJsonUser</span><span class="params">(Message message, Channel channel)</span></span>&#123;</span><br><span class="line">        Action action=Action.ACCEPT;</span><br><span class="line">        <span class="keyword">long</span> tag=message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            message.getMessageProperties().getConsumerTag();</span><br><span class="line">            System.out.println( message.getMessageProperties().getConsumerTag());</span><br><span class="line">            String message1 = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;获取消息&#x27;&quot;</span> + message1 + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 根据异常种类决定是ACCEPT、RETRY还是 REJECT</span></span><br><span class="line">            action = Action.RETRY;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过finally块来保证Ack/Nack会且只会执行一次</span></span><br><span class="line">                <span class="keyword">if</span> (action == Action.ACCEPT) &#123;</span><br><span class="line">                    channel.basicAck(tag, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// 重试</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == Action.RETRY) &#123;</span><br><span class="line">                    channel.basicNack(tag, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                    <span class="comment">// 拒绝消息也相当于主动删除mq队列的消息</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.basicNack(tag, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-RabbitMQ的消费端限流"><a href="#4-RabbitMQ的消费端限流" class="headerlink" title="4-RabbitMQ的消费端限流"></a>4-RabbitMQ的消费端限流</h2><h3 id="4-1-为什么需要限流？"><a href="#4-1-为什么需要限流？" class="headerlink" title="4.1-为什么需要限流？"></a>4.1-为什么需要限流？</h3><ul><li>假设一个场景，我们Rabbitmq服务器有上万条未处理的消息，我们随便打开一个消费者客户端，会出现这种情况：巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据!此时很有可能导致服务器崩溃，严重的可能导致线上的故障。</li><li>除了这种场景，还有一些其他的场景，比如说单个生产者一分钟生产出了几百条数据，但是单个消费者一分钟可能只能处理60条数据，这个时候生产端和消费端肯定是不平衡的。通常生产端是没办法做限制的。所以消费端肯定需要做一些限流措施，否则如果超出最大负载，可能导致消费端性能下降，服务器卡顿甚至崩溃等一系列严重后果。</li></ul><h3 id="4-2-消费端限流机制"><a href="#4-2-消费端限流机制" class="headerlink" title="4.2-消费端限流机制"></a>4.2-消费端限流机制</h3><p>RabbitMQ提供了一种<code>qos</code> (服务质量保证)功能，即在非自动确认消息的前提下，如果一定数目的消息 (通过基于consume或者channel设置Qos的值) 未被确认前，不进行消费新的消息。<br>需要注意：</p><ol><li>不能设置自动签收功能(autoAck = false)</li><li>如果消息没被确认，就不会到达消费端，目的就是给消费端减压</li></ol><h3 id="4-3-限流相关API"><a href="#4-3-限流相关API" class="headerlink" title="4.3-限流相关API"></a>4.3-限流相关API</h3><h4 id="1-限流设置"><a href="#1-限流设置" class="headerlink" title="1. 限流设置"></a>1. 限流设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQOS</span><span class="params">(unit prefetchSize,ushort prefetchCount,Boolean global)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>prefetchSize:</code> 单条消息的大小限制，消费端通常设置为0，表示不做限制；</li><li><code>prefetchCount:</code> 一次最多能处理多少条消息，通常设置为1；</li><li><code>global:</code> 是否将上面设置应用于channel，false代表consumer级别；</li></ul><h4 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h4><p><code>prefetchCount</code>在 <code>autoAck=false</code> 的情况下生效，即在自动应答的情况下这个值是不生效的。</p><h4 id="3-手工ACK-basicAck"><a href="#3-手工ACK-basicAck" class="headerlink" title="3. 手工ACK - basicAck()"></a>3. 手工ACK - basicAck()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicAck</span><span class="params">(Integer deliveryTag，<span class="keyword">boolean</span> multiple)</span></span></span><br></pre></td></tr></table></figure><p>手工ACK，调用这个方法就会主动回送给Broker一个应答，表示这条消息我处理完了，你可以给我下一条了。参数<code>multiple</code>表示是否批量签收，由于我们是一次处理一条消息，所以设置为false</p><h4 id="4-限流显示"><a href="#4-限流显示" class="headerlink" title="4. 限流显示"></a>4. 限流显示</h4><p>消费者：关闭autoACK，进行限流设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.43.157&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//2 获取Connection</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3 通过Connection创建一个新的Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        String exchangeName = <span class="string">&quot;test_qos_exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test_qos_queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;qos.#&quot;</span>;</span><br><span class="line">        <span class="comment">//4 声明交换机和队列，然后进行绑定设置路由Key</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行参数设置：单条消息的大小限制，一次最多能处理多少条消息，是否将上面设置应用于channel</span></span><br><span class="line">        channel.basicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//限流： autoAck设置为 false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-如何保证消息的幂等性？"><a href="#5-如何保证消息的幂等性？" class="headerlink" title="5-如何保证消息的幂等性？"></a>5-如何保证消息的幂等性？</h2><p>消息的幂等性，即如何保证消费不被重复消费。</p><h3 id="5-1-什么是幂等性？"><a href="#5-1-什么是幂等性？" class="headerlink" title="5.1-什么是幂等性？"></a>5.1-什么是幂等性？</h3><p>可以参考数据库乐观锁机制，比如执行一条更新库存的 SQL 语句，在并发场景，为了性能和数据可靠性，会在更新时加上查询时的版本，并且更新这个版本信息。可能你要对一个事情进行操作，这个操作可能会执行成百上千次，但是操作结果都是相同的，这就是幂等性。</p><h3 id="5-2-非幂等的情况"><a href="#5-2-非幂等的情况" class="headerlink" title="5.2-非幂等的情况"></a>5.2-非幂等的情况</h3><ol><li><p>生产者已把消息发送到mq，在mq给生产者返回ack的时候网络中断，故生产者未收到确定信息，生产者认为消息未发送成功，但实际情况是，mq已成功接收到了消息，在网络重连后，生产者会重新发送刚才的消息，造成mq接收了重复的消息;</p><blockquote><p>解决办法：</p><p>mq内部会为每条消息生成一个全局唯一、与业务无关的消息id，当mq接收到消息时，会先根据该id判断消息是否重复发送，mq再决定是否接收该消息。</p></blockquote></li><li><p>消费者在消费mq中的消息时，mq已把消息发送给消费者，消费者在给mq返回ack时网络中断，故mq未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息；</p><blockquote><p>解决办法：</p><p>也可利用mq的该id来判断，或者可按自己的规则生成一个全局唯一id，每次消费消息时用该id先判断该消息是否已消费过。</p></blockquote></li></ol><h3 id="5-3-消费端的幂等性保障"><a href="#5-3-消费端的幂等性保障" class="headerlink" title="5.3-消费端的幂等性保障"></a>5.3-消费端的幂等性保障</h3><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p><p>业界主流的幂等性有两种操作：</p><ul><li><strong>唯一 ID + 指纹码 机制：</strong><ol><li>指纹码(就是时间戳 + 业务的一些规则， 来保证id + 指纹码在同一时刻是唯一的，不会出现重复)</li><li>唯一ID + 指纹码机制，利用数据库主键去重；</li><li>select count(1) from t_order where id = 唯一ID + 指纹码;</li><li>好处：实现简单；</li><li>坏处：高并发下有数据库写入的瓶颈；</li><li>解决方案：跟进ID进行分库分表进行算法路由；</li></ol></li><li><strong>利用Redis的原子性实现</strong></li></ul><h4 id="1-唯一-ID-指纹码-机制"><a href="#1-唯一-ID-指纹码-机制" class="headerlink" title="1. 唯一 ID + 指纹码 机制"></a>1. 唯一 ID + 指纹码 机制</h4><p>大家肯定懂唯一 ID 的，就不多说了，为什么需要指纹码呢？这是为了应对用户在一瞬间的频繁操作，这个指纹码可能是我们的一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个id是否存在数据库中。</p><p><strong>好处</strong>就是实现简单，就一个拼接，然后查询判断是否重复。</p><p><strong>坏处</strong>就是在高并发时，如果是单个数据库就会有写入性能瓶颈</p><p><strong>解决方案 ：</strong>根据 ID 进行分库分表，对 id 进行算法路由，落到一个具体的数据库，然后当这个 id 第二次来又会落到这个数据库，这时候就像我单库时的查重一样了。利用算法路由把单库的幂等变成多库的幂等，分摊数据流量压力，提高性能。</p><h4 id="2-利用-redis-的原子性去实现"><a href="#2-利用-redis-的原子性去实现" class="headerlink" title="2. 利用 redis 的原子性去实现"></a>2. 利用 redis 的原子性去实现</h4><p>使用 redis 的原子性去实现需要考虑两个点：</p><ul><li>一是 是否 要进行数据落库，如果落库的话，关键解决的问题是数据库和缓存如何做到原子性？ 数据库与缓存进行同步肯定要进行写操作，到底先写 redis 还是先写数据库，这是个问题，涉及到缓存更新与淘汰的问题</li><li>二是如果不落库，那么都存储到缓存中，如何设置定时同步的策略？ 不入库的话，可以使用双重缓存等策略，保障一个消息副本，具体同步可以使用类似 databus 这种同步工具。</li></ul><h2 id="6-TTL队列-消息和死信队列"><a href="#6-TTL队列-消息和死信队列" class="headerlink" title="6-TTL队列/消息和死信队列"></a>6-TTL队列/消息和死信队列</h2><h3 id="6-1-TTL消息和TTL队列"><a href="#6-1-TTL消息和TTL队列" class="headerlink" title="6.1-TTL消息和TTL队列"></a>6.1-TTL消息和TTL队列</h3><p>TTL是<code>Time To Live</code>的缩写，也就是生存时间</p><h4 id="1-TTL消息"><a href="#1-TTL消息" class="headerlink" title="1. TTL消息"></a>1. TTL消息</h4><p>RabbitMQ支持消息的过期时间，在消息发送时可以进行指定。</p><h4 id="2-TTL队列"><a href="#2-TTL队列" class="headerlink" title="2. TTL队列"></a>2. TTL队列</h4><p>RabbitMQ支持为每个队列设置消息的超时时间，从消息入队列开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除。</p><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h4><ul><li>两者的区别是设置队列的过期时间是对该队列的所有消息生效的。</li><li>为消息设置TTL有一个问题：RabbitMQ只对处于队头的消息判断是否过期（即不会扫描队列），所以，很可能队列中已存在死消息，但是队列并不知情。这会影响队列统计数据的正确性，妨碍队列及时释放资源。</li></ul><h3 id="6-2-死信队列"><a href="#6-2-死信队列" class="headerlink" title="6.2-死信队列"></a>6.2-死信队列</h3><h4 id="1-死信队列介绍"><a href="#1-死信队列介绍" class="headerlink" title="1. 死信队列介绍"></a>1. 死信队列介绍</h4><p>死信队列：DLX，<code>dead-letter-exchange</code></p><p>利用DLX，当消息在一个队列中变成死信 <code>(dead message，就是没有任何消费者消费）)</code> 之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。</p><h4 id="2-消息变成死信有以下几种情况"><a href="#2-消息变成死信有以下几种情况" class="headerlink" title="2. 消息变成死信有以下几种情况"></a>2. 消息变成死信有以下几种情况</h4><ul><li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><h4 id="3-死信处理过程"><a href="#3-死信处理过程" class="headerlink" title="3. 死信处理过程"></a>3. 死信处理过程</h4><ul><li>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。</li><li>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</li><li>可以监听这个队列中的消息做相应的处理。</li></ul><h4 id="4-死信队列设置"><a href="#4-死信队列设置" class="headerlink" title="4. 死信队列设置"></a>4. 死信队列设置</h4><ol><li>首先需要设置死信队列的exchange和queue，然后进行绑定：</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Exchange</span>: <span class="string">dlx.exchange</span></span><br><span class="line"><span class="attr">Queue</span>: <span class="string">dlx.queue</span></span><br><span class="line"><span class="attr">RoutingKey</span>: <span class="string">#</span></span><br><span class="line"><span class="comment">#表示只要有消息到达了Exchange，那么都会路由到这个queue上</span></span><br></pre></td></tr></table></figure><ol><li>然后需要有一个监听，去监听这个队列进行处理</li><li>然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：<code>arguments.put(&quot; x-dead-letter-exchange&quot;，&quot;dlx.exchange&quot;);</code>，这样消息在过期、requeue、 队列在达到最大长度时，消息就可以直接路由到死信队列！</li></ol><h4 id="5-死信队列案例"><a href="#5-死信队列案例" class="headerlink" title="5. 死信队列案例"></a>5. 死信队列案例</h4><ul><li><h6 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1 创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.43.157&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//2 获取Connection</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//3 通过Connection创建一个新的Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        String exchange = <span class="string">&quot;test_dlx_exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;dlx.save&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ DLX Message&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">                .expiration(<span class="string">&quot;10000&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        channel.basicPublish(exchange, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h6 id="自定义消费者"><a href="#自定义消费者" class="headerlink" title="自定义消费者"></a>自定义消费者</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;-----------consume message----------&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;consumerTag: &quot;</span> + consumerTag);</span><br><span class="line">        System.err.println(<span class="string">&quot;envelope: &quot;</span> + envelope);</span><br><span class="line">        System.err.println(<span class="string">&quot;properties: &quot;</span> + properties);</span><br><span class="line">        System.err.println(<span class="string">&quot;body: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h6 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h6><ul><li>声明正常处理消息的交换机、队列及绑定规则</li><li>在正常交换机上指定死信发送的Exchange</li><li>声明死信交换机、队列及绑定规则</li><li>监听死信队列，进行后续处理，这里省略</li></ul><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.43.157&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明一个普通的交换机 和 队列 以及路由</span></span><br><span class="line">        <span class="built_in">String</span> exchangeName = <span class="string">&quot;test_dlx_exchange&quot;</span>;</span><br><span class="line">        <span class="built_in">String</span> routingKey = <span class="string">&quot;dlx.#&quot;</span>;</span><br><span class="line">        <span class="built_in">String</span> queueName = <span class="string">&quot;test_dlx_queue&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//指定死信发送的Exchange</span></span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; agruments = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;();</span><br><span class="line">        agruments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx.exchange&quot;</span>);</span><br><span class="line">        <span class="comment">//这个agruments属性，要设置到声明队列上</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, agruments);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//要进行死信队列的声明</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;dlx.exchange&quot;</span>, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;dlx.queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;dlx.queue&quot;</span>, <span class="string">&quot;dlx.exchange&quot;</span>, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> MyConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h6 id="运行说明"><a href="#运行说明" class="headerlink" title="运行说明"></a>运行说明</h6><p>启动消费端，此时查看管控台，新增了两个Exchange，两个Queue。在<code>test_dlx_queue</code>上我们设置了DLX，也就代表死信消息会发送到指定的Exchange上，最终其实会路由到<code>dlx.queue</code>上。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%971.png"></p><p>此时关闭消费端，然后启动生产端，查看管控台队列的消息情况，<code>test_dlx_queue</code>的值为1，而<code>dlx_queue</code>的值为0。<br>10s后的队列结果如图，由于生产端发送消息时指定了消息的过期时间为10s，而此时没有消费端进行消费，消息便被路由到死信队列中。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%972.png"></p><p>实际环境我们还需要对死信队列进行一个监听和处理，当然具体的处理逻辑和业务相关，这里只是简单演示死信队列是否生效。</p></li></ul><h2 id="7-RabbitMQ的集群模式"><a href="#7-RabbitMQ的集群模式" class="headerlink" title="7-RabbitMQ的集群模式"></a>7-RabbitMQ的集群模式</h2><h3 id="7-1-主备模式"><a href="#7-1-主备模式" class="headerlink" title="7.1-主备模式"></a>7.1-主备模式</h3><p>实现RabbitMQ的高可用集群，一般在并发和数据量不高的情况下，这种模式非常的好且简单。主备模式也称为Warren模式</p><blockquote><p><code>主备模式</code>：主节点提供读写，从节点不提供读写服务，只是负责提供备份服务，如果主节点宕机备份从节点会自动切换成主节点，提供服务。<br><code>主从模式</code>：主节点提供读写，从节点只读。</p></blockquote><ul><li><code>主备模式</code>：所谓rabbitmq另外一种模式就是warren（兔子窝），就是一个主/备方案（主节点如果挂了，从节点提供服务而已，和activemq利用zookeeper做主/备一样）</li></ul><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E4%B8%BB%E5%A4%87%E6%A8%A1%E5%BC%8F.png"></p><ul><li>HaProxy配置：</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">listen rabbitmq_cluster</span><br><span class="line">bind <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">5672</span> </span><br><span class="line">mode tcp  #配置TCP模式</span><br><span class="line">balance roundrobin #简单的轮询</span><br><span class="line">server bhz76 <span class="number">192.168</span>.<span class="number">11.12</span>:<span class="number">5672</span> check inter <span class="number">5000</span> rise <span class="number">2</span> fall <span class="number">3</span> #主节点</span><br><span class="line">server bhz77 <span class="number">192.168</span>.<span class="number">11.13</span>:<span class="number">5672</span> backup check inter <span class="number">5000</span> rise <span class="number">2</span> fall <span class="number">3</span> #备用节点</span><br></pre></td></tr></table></figure><p><code>备注：</code>rabbitmq集群节点配置 <code>inter</code> 每隔5秒对mq集群做健康检查，2次正确证明服务器可用，3次失败证明服务器不可用，并且配置主备机制</p><h3 id="7-2-远程模式（不常用）"><a href="#7-2-远程模式（不常用）" class="headerlink" title="7.2-远程模式（不常用）"></a>7.2-远程模式（不常用）</h3><p>远程模式：远距离通信和复制，所谓Shovel就是我们可以把消息进行不同数据中心的复制工作，我们可以跨地域的让两个mq集群互联。我们下面看一下Shovel架构模型：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Shovel%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B.png"></p><p>在使用了shovel插件后，模型变成了<code>近端同步确认</code>，<code>远端异步确认</code>方式，大大提高了订单确认速度，并且还能保证可靠性。</p><ul><li><p>远程模式：Shovel集群的拓补图：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Shovel%E9%9B%86%E7%BE%A4%E7%9A%84%E6%8B%93%E8%A1%A5%E5%9B%BE.png"></p></li><li><p>Shovel集群的配置，首先启动rabbitmq插件，命令如下：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> amqp_client</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_shovel</span><br></pre></td></tr></table></figure><ul><li>创建rabbitmq.conf文件：touch /etc/rabbitmq/rabbitmq.config</li><li>添加配置见rabbitmq.config</li><li>最后我们需要资源服务器和目的服务器都使用相同的配置文件（rabbitmq.config）</li></ul><h3 id="7-3-镜像模式（常用"><a href="#7-3-镜像模式（常用" class="headerlink" title="7.3-镜像模式（常用)"></a>7.3-镜像模式（<code>常用</code>)</h3><ul><li>镜像模式：集群模式非常经典的就是Mirror镜像模式，保证100%数据不丢失，在实际工作中用的最多的。并且实现集群非常的简单，一般互联网大厂都会构建这种镜像集群模式。</li><li>Mirror镜像队列，目的是为了保证rabbitmq数据的高可靠性解决方案，主要就是实现数据的同步，一般来讲是2-3个实现数据同步（对于100%数据可靠性解决方案一般是3个节点）集群架构如下：</li></ul><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97.png"></p><h3 id="7-4-多活模式"><a href="#7-4-多活模式" class="headerlink" title="7.4-多活模式"></a>7.4-多活模式</h3><ul><li><p>多活模式：这种模式也是实现异地数据复制的主流模式，因为Shovel模式配置比较复杂，所以一般来说实现异地集群都是使用双活或者多活模式来实现的。这种模式需要依赖rabbitmq的federation插件，可以实现继续的可靠AMQP数据通信，多活模式在实际配置与应用非常的简单。</p></li><li><p>RabbitMQ部署架构采用双中心模式（多中心），那么在两套（或多套）数据中心中各部署一套RabbitMQ集群，各中心之间还需要实现部分队列消息共享。多活集群架构如下：</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/%E5%A4%9A%E6%B4%BB%E6%A8%A1%E5%BC%8F.png"></p></li><li><p><code>Federation插件</code>是一个不需要构建Cluster，而在Brokers之间传输消息的高性能插件，Federation插件可以在Brokers或者Cluster之间传输消息，连接双方可以使用不同的users和vistual hosts，双方也可以使用版本不同的RabbitMQ和Erlang。Federation插件使用AMQP协议通信，可以接收不连续的传输。</p><p><img src="https://gitee.com/lemon-cs/images/raw/master/Federation.png"></p></li><li><p>Federation Exchanges,可以看成Downstream从Upstream主动拉取消息，但并不是拉取所有消息，必须是在Downstream上已经明确定义Bindings关系的Exchange，也就是有实际的物理Queue来接收消息，才会从Upstream拉取消息到Downstream。使用AMQP协议实施代理间通信，Downstream会将绑定关系组合在一起，绑定/解绑命令将会发送到Upstream交换机。因此，FederationExchange只接收具有订阅的消息。</p></li></ul><h3 id="7-5-RabbitMQ集群镜像模式从0到1"><a href="#7-5-RabbitMQ集群镜像模式从0到1" class="headerlink" title="7.5-RabbitMQ集群镜像模式从0到1"></a>7.5-RabbitMQ集群镜像模式从0到1</h3><ul><li><p>RabbitMQ集群环境节点说明</p><p>!<img src="https://gitee.com/lemon-cs/images/raw/master/RabbitMQ%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83.png"></p></li><li><p><strong>详细步骤：</strong><br><a target="_blank" rel="noopener" href="https://github.com/pyygithub/springboot-rabbitmq/blob/master/RabbitMQ%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf">RabbitMQ镜像集群搭建步骤</a></p><blockquote><ul><li><code>HAProxy</code>是一款提供高可用性、<code>负载均衡</code>以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，他是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在时下的硬件上，完全可以支撑数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。</li><li>HAProxy借助于OS上几种常见的技术来实现性能的最大化：</li></ul><ol><li>单进程、时间驱动模型显著降低上下文切换的开销及内存占用</li><li>在任何可用的情况下，单缓冲（single buffering）机制能以不复制任何数据的方式完成读写操作，这会节约大量的CPU时钟周期及内存带宽</li><li>借助于Linux2.6上的splice()系统调用，HAProxy可以实现零复制转发（Zero-copy- forwarding），在linux3.5及以上的OS上还可以实现零复制启动（zero-starting）</li></ol></blockquote></li><li><p><code>KeepAlived</code>软件主要是通过VRRP协议实现<code>高可用</code>功能的。VRRP是Virtual Router RedundancyProtocol（虚拟路由器冗余协议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能保证党个别节点宕机时，整个网络可以不间断地运行，所以，KeepAlived一方面具有配置管理LVS的功能，同时还具备对LVS下面节点进行健康检查差的功能，另一方面可实现系统网络服务的高可用功能。</p><p>KeepAlived服务的三个重要功能：</p><ol><li>管理LVS负载均衡软件</li><li>实现LVS集群节点的健康检查</li><li>作为系统网络服务的高可用性（failover）</li></ol></li><li><p><code>KeepAlived高可用原理</code><br>KeepAlived高可用服务对之间的故障转移，是通过VRRP（Virtual Router Redundancy Protocol,虚拟路由器冗余协议）来实现的。在KeepAlived服务正常工作是，主Master节点会不断地向备节点发送（多播的方式）心跳消息，用以告诉备Backup节点自己还活着，当主master节点发生故障时，就无法发送心跳消息，备节点也就因此无法继续监测到来自主Master节点的心跳了，于是调用自身的接管程序，接管主Master节点 的IP资源及服务。当主Master节点恢复时，备Backup节点又会释放主节点故障时自身接管的IP资源和服务，恢复到原来的备用角色。</p></li></ul><p>参考</p><p>——<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/588e1c959f03">https://www.jianshu.com/p/588e1c959f03</a></p><p>——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YDGWbdYgWy6ttUxjWYCIjw">https://mp.weixin.qq.com/s/YDGWbdYgWy6ttUxjWYCIjw</a></p><p>——<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qGg3etLnI38i-G8aFbulWw">https://mp.weixin.qq.com/s/qGg3etLnI38i-G8aFbulWw</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">空白格</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lemon-cs.github.io/2020/01/16/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://lemon-cs.github.io/2020/01/16/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lemon-cs.github.io" target="_blank">Lemon-CS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/18/HTML%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://s3.bmp.ovh/imgs/2021/12/6c4bf5b41815150b.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML入门学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/15/Angular%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://s4.ax1x.com/2022/02/15/HRSa9J.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Angular入门学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/01/11/Kafka%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kafka入门学习笔记"><img class="cover" src="https://s3.bmp.ovh/imgs/2021/12/53c29bb95b335067.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-11</div><div class="title">Kafka入门学习笔记</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTAxNC8zMTQ4Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./images/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">空白格</div><div class="author-info__description">杯中的水是亮闪闪的,海里的水是黑沉沉的!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lemon-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lemon-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:591930734@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Lemon-CS</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">RabbitMQ学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1-简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1-相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-text">1.2-RabbitMQ的安装和配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-AMQP%E5%8D%8F%E8%AE%AE"><span class="toc-text">1.3-AMQP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Exchange"><span class="toc-text">1.4-Exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">1.5-消息队列解决了什么问题?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E7%A7%8D%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F"><span class="toc-text">2-5种消息模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.1-简单模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">1. 模式示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. Java实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96mq%E8%BF%9E%E6%8E%A5"><span class="toc-text">获取mq连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF"><span class="toc-text">生产消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-text">消费消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Spring-AMQP%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. Spring AMQP实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-text">4. 简单模式的不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2-工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1"><span class="toc-text">1. 模式示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">2. Java实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8F%91"><span class="toc-text">（1） 轮询分发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91-fair-dispatch"><span class="toc-text">（2）公平分发 fair dispatch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94%E4%B8%8E%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">3. 消息应答与消息持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-text">消息应答</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">消息持久化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Spring-AMQP%E5%AE%9E%E7%8E%B0"><span class="toc-text">4. Spring AMQP实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3-发布&#x2F;订阅模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-2"><span class="toc-text">1. 模式示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">2. Java实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Spring-AMQP%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">3. Spring AMQP实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.4-路由模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-3"><span class="toc-text">1. 模式示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">2. Java实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Spring-AMQP%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">3. Spring AMQP实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Topic%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.5-Topic模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-4"><span class="toc-text">1. 模式示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Java%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">2. Java实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Spring-AMQP%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">3. Spring AMQP实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AFAck%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">3-消息Ack确认机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">3.1-环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">1. 引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">2. 配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">3. 配置类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4"><span class="toc-text">3.2-消息发送确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ConfirmCallback"><span class="toc-text">1. ConfirmCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ReturnCallback"><span class="toc-text">2. ReturnCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9A%E5%88%B6%E5%8C%96%E6%A8%A1%E6%9D%BF"><span class="toc-text">3. 定制化模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E7%A1%AE%E8%AE%A4"><span class="toc-text">3.3-消息接收确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AE%E8%AE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. 确认模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%8B%E5%8A%A8%E7%A1%AE%E8%AE%A4"><span class="toc-text">2. 手动确认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%9D%E8%80%83"><span class="toc-text">3. 思考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-RabbitMQ%E7%9A%84%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81"><span class="toc-text">4-RabbitMQ的消费端限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-text">4.1-为什么需要限流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81%E6%9C%BA%E5%88%B6"><span class="toc-text">4.2-消费端限流机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3API"><span class="toc-text">4.3-限流相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%99%90%E6%B5%81%E8%AE%BE%E7%BD%AE"><span class="toc-text">1. 限流设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2. 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%8B%E5%B7%A5ACK-basicAck"><span class="toc-text">3. 手工ACK - basicAck()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%99%90%E6%B5%81%E6%98%BE%E7%A4%BA"><span class="toc-text">4. 限流显示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F"><span class="toc-text">5-如何保证消息的幂等性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F"><span class="toc-text">5.1-什么是幂等性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%9D%9E%E5%B9%82%E7%AD%89%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">5.2-非幂等的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-text">5.3-消费端的幂等性保障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%94%AF%E4%B8%80-ID-%E6%8C%87%E7%BA%B9%E7%A0%81-%E6%9C%BA%E5%88%B6"><span class="toc-text">1. 唯一 ID + 指纹码 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8-redis-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8E%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. 利用 redis 的原子性去实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-TTL%E9%98%9F%E5%88%97-%E6%B6%88%E6%81%AF%E5%92%8C%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">6-TTL队列&#x2F;消息和死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-TTL%E6%B6%88%E6%81%AF%E5%92%8CTTL%E9%98%9F%E5%88%97"><span class="toc-text">6.1-TTL消息和TTL队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-TTL%E6%B6%88%E6%81%AF"><span class="toc-text">1. TTL消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TTL%E9%98%9F%E5%88%97"><span class="toc-text">2. TTL队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">6.2-死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. 死信队列介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%8F%98%E6%88%90%E6%AD%BB%E4%BF%A1%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">2. 消息变成死信有以下几种情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AD%BB%E4%BF%A1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">3. 死信处理过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AE"><span class="toc-text">4. 死信队列设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E6%A1%88%E4%BE%8B"><span class="toc-text">5. 死信队列案例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%AB%AF"><span class="toc-text">生产端</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">自定义消费者</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF"><span class="toc-text">消费端</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E8%AF%B4%E6%98%8E"><span class="toc-text">运行说明</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-RabbitMQ%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">7-RabbitMQ的集群模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%B8%BB%E5%A4%87%E6%A8%A1%E5%BC%8F"><span class="toc-text">7.1-主备模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%BF%9C%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">7.2-远程模式（不常用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8"><span class="toc-text">7.3-镜像模式（常用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%A4%9A%E6%B4%BB%E6%A8%A1%E5%BC%8F"><span class="toc-text">7.4-多活模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-RabbitMQ%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E4%BB%8E0%E5%88%B01"><span class="toc-text">7.5-RabbitMQ集群镜像模式从0到1</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/30/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/" title="Netty知识点详解"><img src="https://s3.bmp.ovh/imgs/2021/12/b7f532171b88483b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Netty知识点详解"></a><div class="content"><a class="title" href="/2021/12/30/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/" title="Netty知识点详解">Netty知识点详解</a><time datetime="2021-12-30T06:31:42.000Z" title="发表于 2021-12-30 14:31:42">2021-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/28/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统"><img src="https://s3.bmp.ovh/imgs/2021/12/468eb316ff103180.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go语言实现分布式crontab任务系统"></a><div class="content"><a class="title" href="/2021/12/28/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8Fcrontab%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/" title="Go语言实现分布式crontab任务系统">Go语言实现分布式crontab任务系统</a><time datetime="2021-12-28T14:09:50.000Z" title="发表于 2021-12-28 22:09:50">2021-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/26/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB"><img src="https://s3.bmp.ovh/imgs/2021/12/2de6481e0a4697bf.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Go操作MongoDB"></a><div class="content"><a class="title" href="/2021/12/26/Go%E6%93%8D%E4%BD%9CMongoDB/" title="Go操作MongoDB">Go操作MongoDB</a><time datetime="2021-12-26T14:09:50.000Z" title="发表于 2021-12-26 22:09:50">2021-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/15/SpringBoot%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="SpringBoot之源码分析"><img src="https://static01.imgkr.com/temp/fa403895570e4cafb459adbcdca97dbe.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot之源码分析"></a><div class="content"><a class="title" href="/2020/08/15/SpringBoot%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="SpringBoot之源码分析">SpringBoot之源码分析</a><time datetime="2020-08-15T14:09:50.000Z" title="发表于 2020-08-15 22:09:50">2020-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/10/SpringBoot%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="SpringBoot之基础回顾"><img src="https://static01.imgkr.com/temp/31d9be0ee4fc43549ffe1bd007bc4e59.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot之基础回顾"></a><div class="content"><a class="title" href="/2020/08/10/SpringBoot%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="SpringBoot之基础回顾">SpringBoot之基础回顾</a><time datetime="2020-08-10T14:09:50.000Z" title="发表于 2020-08-10 22:09:50">2020-08-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 空白格</div><div class="footer_custom_text">欢迎来到Lemon-CS</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere(){var e,t,o,r;"object"==typeof LivereTower?window.LivereTower.init():(e=document,t="script",r=e.getElementsByTagName(t)[0],"function"!=typeof LivereTower&&((o=e.createElement(t)).src="https://cdn-city.livere.com/js/embed.dist.js",o.async=!0,r.parentNode.insertBefore(o,r)))}{function loadOtherComment(){loadLivere()}loadLivere()}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];pjaxSelectors.unshift('meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]');var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>